import { defineComponent, openBlock, createElementBlock, createElementVNode, ref, onMounted, onBeforeMount, onBeforeUnmount, watch, nextTick, computed, resolveComponent, createBlock, Teleport, normalizeClass, createVNode, Transition, withCtx, withDirectives, normalizeStyle, vShow, renderSlot, createCommentVNode } from 'vue';
import { disableBodyScroll, enableBodyScroll } from 'body-scroll-lock';

var script$1 = defineComponent({
    name: 'SidePanelCloseButton',
    emits: ['close'],
});

const _hoisted_1 = /*#__PURE__*/createElementVNode("span", { class: "vsp-close__x" }, null, -1 /* HOISTED */);
const _hoisted_2 = [
  _hoisted_1
];

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", {
    class: "vsp-close",
    onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('close')))
  }, _hoisted_2))
}

script$1.render = render$1;
script$1.__file = "src/components/SidePanelCloseButton.vue";

var script = defineComponent({
    name: 'VueSidePanel',
    components: {
        SidePanelCloseButton: script$1,
    },
    props: {
        idName: {
            type: String,
            default: 'vsp-container',
        },
        hideCloseBtn: {
            type: Boolean,
            default: false,
        },
        noClose: {
            type: Boolean,
            default: false,
        },
        side: {
            type: String,
            validator: (value) => ['top', 'right', 'bottom', 'left'].includes(value),
            default: 'right',
        },
        rerender: {
            type: Boolean,
            default: false,
        },
        zIndex: {
            type: [Number, String],
            default: 'auto',
        },
        width: {
            type: String,
            default: 'auto',
        },
        height: {
            type: String,
            default: 'auto',
        },
        lockScroll: {
            type: Boolean,
            default: false,
        },
        lockScrollHtml: {
            type: Boolean,
            default: true,
        },
        modelValue: {
            type: Boolean,
            default: false,
            required: true,
        },
        overlayColor: {
            type: String,
            default: 'black',
        },
        overlayOpacity: {
            type: Number,
            default: 0.5,
        },
        overlayDuration: {
            type: Number,
            default: 500,
        },
        panelColor: {
            type: String,
            default: 'white',
        },
        panelDuration: {
            type: Number,
            default: 300,
        },
        transitionName: {
            type: String,
            default: undefined,
        },
        headerClass: {
            type: String,
            default: '',
        },
        bodyClass: {
            type: String,
            default: '',
        },
        footerClass: {
            type: String,
            default: '',
        },
    },
    emits: ['update:modelValue'],
    setup(props, { emit, attrs }) {
        let teleportContainer = undefined;
        const panel = ref(null);
        const overlay = ref(null);
        const footer = ref(null);
        const header = ref(null);
        const body = ref(null);
        const footerHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerHeight = ref(0);
        const panelHeight = ref(0);
        const windowHeight = ref(0);
        const zIndex = ref();
        const isBodyAlreadyLocked = ref(false);
        const calculateRightSize = async () => {
            if (window?.innerHeight > 0)
                windowHeight.value = window.innerHeight;
            footerHeight.value = footer.value ? footer.value.clientHeight : 0;
            headerHeight.value = header.value ? header.value.clientHeight : 0;
            bodyScrollHeight.value = body.value ? body.value.scrollHeight : 0;
            panelHeight.value = panel.value ? panel.value.clientHeight : 0;
        };
        const closePanel = () => emit('update:modelValue', false);
        const lockUnlockBodyScroll = (elem, lock) => {
            if (lock) {
                setTimeout(() => {
                    disableBodyScroll(elem, { reserveScrollBarGap: true });
                    if (props.lockScrollHtml)
                        document.documentElement.style.overflow = 'hidden';
                }, 0);
                return;
            }
            enableBodyScroll(elem);
            if (props.lockScrollHtml)
                document.documentElement.style.removeProperty('overflow');
        };
        const getMaxZIndex = () => Math.max(...Array.from(document.querySelectorAll('body *'), (el) => parseFloat(window.getComputedStyle(el).zIndex)).filter((zIndex) => !Number.isNaN(zIndex)), 0);
        onMounted(() => {
            zIndex.value = props.zIndex === 'auto' ? getMaxZIndex() : props.zIndex;
        });
        onBeforeMount(() => {
            const alreadyCreatedTarget = document.getElementById(props.idName);
            if (!!alreadyCreatedTarget)
                return;
            teleportContainer = document.createElement('div');
            teleportContainer.setAttribute('id', props.idName);
            document.body.appendChild(teleportContainer);
        });
        onBeforeUnmount(() => {
            const { modelValue, lockScroll } = props;
            if (lockScroll && panel.value && modelValue)
                lockUnlockBodyScroll(panel.value, false);
            if (teleportContainer)
                document.body.removeChild(teleportContainer);
            window.removeEventListener('resize', calculateRightSize);
        });
        watch(() => [header.value, footer.value, props.height, props.width, props.side, props.modelValue], () => {
            nextTick(() => calculateRightSize());
        });
        watch(() => [props.modelValue, panel.value], (newP, oldP) => {
            const wasShown = oldP ? oldP[0] : false;
            const [isShown, panelEl] = newP;
            const isOpening = isShown;
            const isClosing = wasShown && !isShown;
            if (!panelEl)
                return;
            if (isOpening)
                isBodyAlreadyLocked.value = !!document.body.style.overflow;
            if (isShown) {
                if (props.lockScroll)
                    lockUnlockBodyScroll(panelEl, true);
                calculateRightSize();
                window.addEventListener('resize', calculateRightSize);
                return;
            }
            if (!props.lockScroll || !isClosing || isBodyAlreadyLocked.value)
                return;
            setTimeout(() => {
                if (panelEl)
                    lockUnlockBodyScroll(panelEl, false);
            }, props.panelDuration);
            window.removeEventListener('resize', calculateRightSize);
        }, { immediate: true });
        const bodyHeight = computed(() => {
            if (!panelHeight.value)
                return;
            const panelMaxHeight = bodyScrollHeight.value + headerHeight.value + footerHeight.value;
            let height = panelHeight.value - headerHeight.value - footerHeight.value;
            if (['top', 'bottom'].includes(props.side) && props.height === 'auto') {
                height =
                    windowHeight.value >= panelMaxHeight
                        ? bodyScrollHeight.value
                        : windowHeight.value - headerHeight.value - footerHeight.value;
            }
            return height;
        });
        const overlayStyles = computed(() => ({
            zIndex: zIndex.value,
            animationDuration: `${props.overlayDuration}ms`,
            '--overlay-opacity': props.overlayOpacity,
            opacity: props.modelValue ? props.overlayOpacity : 0,
            backgroundColor: props.overlayColor,
            pointerEvents: !props.modelValue ? 'none' : 'all',
        }));
        const panelStyles = computed(() => ({
            width: ['left', 'right'].includes(props.side) ? props.width : undefined,
            maxWidth: '100%',
            ...(['top', 'bottom'].includes(props.side)
                ? {
                    // minHeight: props.height,
                    height: props.height,
                    maxHeight: '100%',
                }
                : {}),
            zIndex: zIndex.value,
            backgroundColor: props.panelColor,
            animationDuration: `${props.panelDuration}ms`,
            ...Object.assign({}, attrs.style),
        }));
        return {
            body,
            panel,
            overlay,
            overlayStyles,
            header,
            footer,
            closePanel,
            panelStyles,
            bodyHeight,
        };
    },
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SidePanelCloseButton = resolveComponent("SidePanelCloseButton");

  return (openBlock(), createBlock(Teleport, {
    to: `#${_ctx.idName}`
  }, [
    createElementVNode("div", {
      class: normalizeClass(["vsp-wrapper", [_ctx.modelValue && 'vsp-wrapper--active']])
    }, [
      createVNode(Transition, {
        name: "overlay",
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", {
            ref: "overlay",
            class: "vsp-overlay",
            style: normalizeStyle(_ctx.overlayStyles),
            onClick: _cache[0] || (_cache[0] = () => (_ctx.noClose ? undefined : _ctx.closePanel()))
          }, null, 4 /* STYLE */), [
            [vShow, _ctx.modelValue]
          ])
        ]),
        _: 1 /* STABLE */
      }),
      createVNode(Transition, {
        name: _ctx.transitionName || `slide-${_ctx.side}`
      }, {
        default: withCtx(() => [
          (_ctx.rerender ? _ctx.modelValue : true)
            ? withDirectives((openBlock(), createElementBlock("div", {
                key: 0,
                ref: "panel",
                class: normalizeClass(["vsp", [`vsp--${_ctx.side}-side`, _ctx.$attrs.class]]),
                style: normalizeStyle(_ctx.panelStyles)
              }, [
                (!!_ctx.$slots.header)
                  ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      ref: "header",
                      class: normalizeClass([_ctx.headerClass, 'vsp__header'])
                    }, [
                      renderSlot(_ctx.$slots, "header", { close: _ctx.closePanel })
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  ref: "body",
                  class: normalizeClass([_ctx.bodyClass, 'vsp__body']),
                  style: normalizeStyle({ height: `${_ctx.bodyHeight}px` })
                }, [
                  renderSlot(_ctx.$slots, "default", { close: _ctx.closePanel }),
                  (!_ctx.hideCloseBtn)
                    ? (openBlock(), createBlock(_component_SidePanelCloseButton, {
                        key: 0,
                        onClose: _ctx.closePanel
                      }, null, 8 /* PROPS */, ["onClose"]))
                    : createCommentVNode("v-if", true)
                ], 6 /* CLASS, STYLE */),
                (!!_ctx.$slots.footer)
                  ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      ref: "footer",
                      class: normalizeClass([_ctx.footerClass, 'vsp__footer'])
                    }, [
                      renderSlot(_ctx.$slots, "footer")
                    ], 2 /* CLASS */))
                  : createCommentVNode("v-if", true)
              ], 6 /* CLASS, STYLE */)), [
                [vShow, _ctx.rerender ? true : _ctx.modelValue]
              ])
            : createCommentVNode("v-if", true)
        ]),
        _: 3 /* FORWARDED */
      }, 8 /* PROPS */, ["name"])
    ], 2 /* CLASS */)
  ], 8 /* PROPS */, ["to"]))
}

script.render = render;
script.__file = "src/components/SidePanel.vue";

var VueSidePanelPlugin = {
    install(app) {
        app.component('VueSidePanel', script);
    },
};

export { script as VueSidePanel, VueSidePanelPlugin as default };
//# sourceMappingURL=vue3-side-panel.esm.js.map
