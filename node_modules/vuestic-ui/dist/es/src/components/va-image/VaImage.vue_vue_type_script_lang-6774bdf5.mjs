import { defineComponent, ref, computed, onBeforeMount, onBeforeUnmount, watch, nextTick } from "vue";
import { p as pick } from "../../../vendor-fff696df.mjs";
import { V as VaAspectRatio } from "../va-aspect-ratio/index-691ee637.mjs";
import { V as VaFallback } from "../va-fallback/index-e34db7ca.mjs";
import { u as useNativeImgAttributesProps, a as useNativeImgAttributes } from "./hooks/useNativeImgAttributes-8e457ff7.mjs";
import { u as useDeprecated } from "../../composables/useDeprecated-76095652.mjs";
import { u as useIntersectionObserver } from "../../composables/useIntersectionObserver-4f12fe5b.mjs";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options-6b96d215.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset-0dfbd395.mjs";
import { u as useIsMounted } from "../../composables/useIsMounted-a63f9559.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props-9727421a.mjs";
import { u as useGlobalConfig } from "../../composables/useGlobalConfig-29bee2de.mjs";
const VaFallbackProps = extractComponentProps(VaFallback);
const _sfc_main = defineComponent({
  name: "VaImage",
  components: { VaAspectRatio, VaFallback },
  emits: ["loaded", "error", "fallback"],
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: Number,
      default: 0,
      validator: (v) => v >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" },
    // TODO: delete in 1.7.0
    contain: { type: Boolean, default: false }
  },
  setup(props, { emit, slots }) {
    useDeprecated(["contain"]);
    const root = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a = image.value) == null ? void 0 : _a.currentSrc;
      getImgSizes();
      emit("loaded", currentImage.value);
    };
    const handleError = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root, props.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a;
        if (!((_a = image.value) == null ? void 0 : _a.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props.src, init);
    const isPlaceholderPassed = computed(() => {
      var _a;
      return ((_a = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a;
      return isLoading.value && !((_a = slots == null ? void 0 : slots.loader) == null ? void 0 : _a.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a;
      return isError.value && (!((_a = slots == null ? void 0 : slots.error) == null ? void 0 : _a.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a = useGlobalConfig()) == null ? void 0 : _a.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => {
      if (props.contain) {
        return "contain";
      }
      return props.fit;
    });
    return {
      fitComputed,
      root,
      image,
      isLoading,
      handleLoad,
      isError,
      handleError,
      isReadyForRender,
      isPlaceholderShown,
      isSuccessfullyLoaded,
      imgAttributesComputed,
      aspectRationAttributesComputed,
      isAnyFallbackPassed,
      fallbackProps
    };
  }
});
export {
  _sfc_main as _
};

import '../../../VaImage.css';
//# sourceMappingURL=VaImage.vue_vue_type_script_lang-6774bdf5.mjs.map
