import { defineComponent, shallowRef, computed, ref, watch } from "vue";
import { p as pick } from "../../../../../vendor-fff696df.mjs";
import { s as scrollToElement } from "../../../../utils/scroll-to-element-c97eed1f.mjs";
import { V as VaVirtualScroller } from "../../../va-virtual-scroller/index-c6f356cf.mjs";
import { V as VaSelectOption } from "../VaSelectOption/index-69ff2ec1.mjs";
import { i as isNilValue } from "../../../../utils/isNilValue-745d19e7.mjs";
import { u as useObjectRefs } from "../../../../composables/useObjectRefs-a4ca85fa.mjs";
import { a as useColorProps } from "../../../../composables/useColors-f23d24ff.mjs";
import { u as useComponentPresetProp } from "../../../../composables/useComponentPreset-0dfbd395.mjs";
import { u as useSelectableListProps, a as useSelectableList } from "../../../../composables/useSelectableList-a02a95a9.mjs";
import { u as useThrottleProps, a as useThrottleValue } from "../../../../composables/useThrottle-cdbdff3a.mjs";
import { e as extractHTMLElement } from "../../../../composables/useHTMLElement-beee793a.mjs";
const _sfc_main = defineComponent({
  name: "VaSelectOptionList",
  components: { VaVirtualScroller, VaSelectOption },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hoveredOption: { type: [String, Number, Boolean, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: Number, default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const root = shallowRef();
    const focus = () => {
      var _a;
      (_a = root.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a;
      return ((_a = root.value) == null ? void 0 : _a.clientHeight) ?? 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props.hoveredOption ?? null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const currentSelectedOptionText = computed(() => {
      var _a;
      const selected = (_a = props.options) == null ? void 0 : _a.find((option) => props.getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a;
      return currentSelectedOptionText.value.toLowerCase() === ((_a = props.search) == null ? void 0 : _a.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (!props.search || props.search.length < props.minSearchChars || isSearchedOptionSelected.value) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = getText(option).toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      const groupBy = getGroupBy(option);
      if (!groupBy) {
        groups._noGroup.push(option);
      } else {
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !isNilValue(value);
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option ?? null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option ?? null, "keyboard");
    };
    const selectHoveredOption = () => {
      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? { ...previousOptionComputed.value } : previousOptionComputed.value;
      emit("select-option");
      if (props.selectedTopShown) {
        updateHoveredOption(previousOption);
      }
    };
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick(props, ["getSelectedState", "color", "search", "highlightMatchedText", "minSearchChars"]),
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const previousOptionComputed = computed(() => {
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        return findNextActiveOption(currentOptionIndex.value - 1, true);
      }
      return void 0;
    });
    const selectOption = (option) => {
      updateHoveredOption(option);
      emit("select-option");
    };
    const handleMouseMove = (option) => {
      if (!props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const handleMouseEnter = (option) => {
      if (props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      if (isValueExists(previousOptionComputed.value)) {
        updateFocusedOption(previousOptionComputed.value);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a;
      if (!isValueExists(option)) {
        return;
      }
      const element = itemRefs.value[getTrackBy(option)];
      if (element) {
        scrollToElement(extractHTMLElement(element));
      }
      if (props.virtualScroller) {
        (_a = virtualScrollerRef.value) == null ? void 0 : _a[0].virtualScrollTo(currentOptionIndex.value);
      }
    };
    const publicMethods = {
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    return {
      root,
      virtualScrollerRef,
      rootHeight,
      optionGroups: optionGroupsThrottled,
      filteredOptions,
      selectOptionProps,
      currentOptionComputed,
      onScroll,
      getTrackBy,
      setItemRef,
      getDisabled,
      selectHoveredOption,
      handleMouseMove,
      handleMouseEnter,
      updateHoveredOption,
      handleScrollToBottom,
      selectOption,
      ...publicMethods
    };
  }
});
export {
  _sfc_main as _
};

import '../../../../../VaSelectOptionList.css';
//# sourceMappingURL=VaSelectOptionList.vue_vue_type_script_lang-a3932d6a.mjs.map
