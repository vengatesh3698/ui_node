import { defineComponent, shallowRef, ref, computed, onMounted, provide, toRef } from "vue";
import { V as VaFileUploadKey } from "./types.js";
import { V as VaFileUploadList } from "./VaFileUploadList/index.js";
import { V as VaModal } from "../va-modal/VaModal.js";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.js";
import { V as VaButton } from "../va-button/index.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { u as useColors } from "../../composables/useColors.js";
import { u as useBem } from "../../composables/useBem.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
const VaFileUploadListProps = extractComponentProps(VaFileUploadList);
const _sfc_main = defineComponent({
  name: "VaFileUpload",
  components: {
    VaModal,
    VaButton,
    VaFileUploadList
  },
  props: {
    ...useComponentPresetProp,
    ...VaFileUploadListProps,
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    undoButtonText: { type: String, default: "$t:undo" },
    dropZoneText: { type: String, default: "$t:dropzone" },
    uploadButtonText: { type: String, default: "$t:uploadFile" },
    deletedFileMessage: { type: String, default: "$t:fileDeleted" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(props, { emit }) {
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const validateFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t) => props.fileTypes.includes(t));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e) => {
      var _a, _b;
      const f = ((_a = e.target) == null ? void 0 : _a.files) || ((_b = e.dataTransfer) == null ? void 0 : _b.files);
      if (!f) {
        return;
      }
      const validatedFiles = props.fileTypes ? validateFiles(Array.from(f)) : f;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e) => {
      uploadFile(e);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        files.value = validateFiles(files.value);
      }
    });
    const { tp } = useTranslation();
    provide(VaFileUploadKey, {
      undo: toRef(props, "undo"),
      disabled: toRef(props, "disabled"),
      undoDuration: toRef(props, "undoDuration"),
      undoButtonText: computed(() => tp(props.undoButtonText)),
      deletedFileMessage: computed(() => tp(props.deletedFileMessage))
    });
    return {
      fileUploadListProps: filterComponentProps(VaFileUploadListProps),
      modal,
      dropzoneHighlight,
      fileInputRef,
      colorComputed,
      computedStyle,
      computedClasses,
      files,
      tp,
      uploadFile,
      changeFieldValue,
      removeFile,
      removeSingleFile,
      callFileDialogue
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaFileUpload.vue_vue_type_script_lang.js.map
