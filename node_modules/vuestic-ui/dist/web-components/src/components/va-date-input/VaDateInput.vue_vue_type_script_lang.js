import { defineComponent, shallowRef, ref, toRefs, computed, watch, nextTick } from "vue";
import { o as omit } from "../../../vendor.js";
import { u as useSyncProp } from "../va-date-picker/hooks/sync-prop.js";
import { u as useRangeModelValueGuard } from "./hooks/range-model-value-guard.js";
import { u as useDateParser } from "./hooks/input-text-parser.js";
import { i as isDates, a as isSingleDate, b as isRange } from "../va-date-picker/utils/date-utils.js";
import { _ as _VaDatePicker } from "../va-date-picker/VaDatePicker.js";
import { V as VaDropdown } from "../va-dropdown/index.js";
import { V as VaIcon } from "../va-icon/index.js";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.js";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.js";
import { u as useParsable } from "../../composables/useParsable.js";
import { e as extractComponentProps, a as extractComponentEmits } from "../../utils/component-options/extract-component-options.js";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.js";
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from "../../composables/useValidation.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";
import { a as useFocusEmits, u as useFocus } from "../../composables/useFocus.js";
import { u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.js";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.js";
import { u as useTranslation } from "../../composables/useTranslation.js";
const VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const VaDatePickerProps = extractComponentProps(_VaDatePicker);
const VaDropdownProps = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "keyboardNavigation", "modelValue"]
);
const _sfc_main = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon
  },
  props: {
    ...VaDropdownProps,
    ...useClearableProps,
    ...VaInputWrapperProps,
    ...VaDatePickerProps,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...VaDropdownProps.offset, default: () => [2, 0] },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" },
    ariaToggleDropdownLabel: { type: String, default: "$t:toggleDropdown" },
    ariaResetLabel: { type: String, default: "$t:resetDate" },
    ariaSelectedDateLabel: { type: String, default: "$t:selectedDate" }
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp(isOpen, "is-open", emit, false);
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      ariaHidden: false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { tp } = useTranslation();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || tp(props.ariaSelectedDateLabel),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const filteredProps = filterComponentProps(VaDropdownProps);
    const dropdownPropsComputed = computed(() => ({
      ...filteredProps.value,
      stateful: false,
      closeOnAnchorClick: false,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      tp,
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      isFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(VaDatePickerProps),
      dropdownPropsComputed,
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      cursorStyleComputed,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaDateInput.vue_vue_type_script_lang.js.map
