import { computed, getCurrentInstance } from "vue";
import { u as useGlobalConfig } from "./useGlobalConfig.mjs";
const useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: void 0 },
  replace: { type: Boolean, default: void 0 },
  append: { type: Boolean, default: void 0 },
  exact: { type: Boolean, default: void 0 },
  activeClass: { type: String, default: void 0 },
  exactActiveClass: { type: String, default: void 0 },
  href: { type: String, default: void 0 },
  target: { type: String, default: void 0 },
  disabled: { type: Boolean, default: false }
};
const useRouterLink = (props) => {
  var _a;
  const globalProperties = computed(() => {
    var _a2;
    return (_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext.config.globalProperties;
  });
  const vueRouter = computed(() => {
    var _a2;
    return (_a2 = globalProperties.value) == null ? void 0 : _a2.$router;
  });
  const vueRoute = computed(() => {
    var _a2;
    return (_a2 = globalProperties.value) == null ? void 0 : _a2.$route;
  });
  const { getGlobalConfig } = useGlobalConfig();
  const routerComponent = getGlobalConfig().routerComponent;
  const isNuxt = !!((_a = globalProperties.value) == null ? void 0 : _a.$nuxt);
  const isNuxtLink = computed(() => !!(!props.disabled && props.to && isNuxt && routerComponent));
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    if (isNuxtLink.value) {
      return routerComponent;
    }
    if (props.to) {
      return "router-link";
    }
    return props.tag || "div";
  });
  const isLinkTag = computed(() => isNuxtLink.value || ["a", "router-link"].includes(tagComputed.value));
  const linkAttributesComputed = computed(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props.target,
      href: hrefComputed.value
    } : {
      target: props.target,
      to: props.to,
      replace: props.replace,
      append: props.append,
      activeClass: props.activeClass,
      exact: props.exact,
      exactActiveClass: props.exactActiveClass
    };
  });
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a2;
    return props.href || (props.to ? (_a2 = vueRouter.value) == null ? void 0 : _a2.resolve(props.to, vueRoute.value).href : void 0);
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};
export {
  useRouterLink as a,
  useRouterLinkProps as u
};
//# sourceMappingURL=useRouterLink.mjs.map
