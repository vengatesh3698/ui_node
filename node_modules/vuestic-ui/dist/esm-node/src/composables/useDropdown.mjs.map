{"version":3,"file":"useDropdown.mjs","sources":["../../../../src/composables/useDropdown.ts"],"sourcesContent":["import { computed, unref, watchPostEffect, type Ref } from 'vue'\n\nimport { useDomRect } from './useDomRect'\nimport { useDocument } from './useDocument'\nimport { usePlacementAliases } from './usePlacementAliases'\n\nimport { unwrapEl } from '../utils/unwrapEl'\nimport { mapObject } from '../utils/map-object'\n\nimport type {\n  PlacementAlignment,\n  PlacementPosition,\n  UsePlacementAliasesProps,\n  ParsedPlacement,\n} from './usePlacementAliases'\n\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (\n  position: PlacementPosition,\n  align: PlacementAlignment,\n  anchor: DOMRect,\n  content: DOMRect,\n) => {\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (position: PlacementPosition, offset: Offset): Coords => {\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, viewport: DOMRect) => {\n  const xMax = viewport.right\n  const yMax = viewport.bottom\n  const xMin = viewport.left\n  const yMin = viewport.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, viewport: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (\n  position: PlacementPosition,\n  align: PlacementAlignment,\n  coords: Coords,\n  content: DOMRect,\n  viewport: DOMRect,\n): ParsedPlacement => {\n  const overflow = calculateContentOverflow(coords, content, viewport)\n  const convertPlacement = (position: PlacementPosition, align: PlacementAlignment) => ({ position, align })\n\n  const newPlacements: Record<PlacementPosition, PlacementPosition> = {\n    top: 'bottom',\n    bottom: 'top',\n    right: 'left',\n    left: 'right',\n  }\n\n  if (!overflow[position]) { return convertPlacement(position, align) }\n\n  // TODO: This is not recursive, if there is overflow in left and right - still will be a problem\n  // Might need to use some different algorithm here\n  const newPlacement = newPlacements[position]\n\n  if (newPlacement === 'bottom' || newPlacement === 'top') {\n    // cross: →\n    if (overflow.left) { return convertPlacement(newPlacement, 'start') }\n    if (overflow.right) { return convertPlacement(newPlacement, 'end') }\n  }\n\n  if (newPlacement === 'left' || newPlacement === 'right') {\n    // cross: ↓\n    if (overflow.top) { return convertPlacement(newPlacement, 'start') }\n    if (overflow.bottom) { return convertPlacement(newPlacement, 'end') }\n  }\n\n  return convertPlacement(newPlacement, 'center')\n}\n\nconst findFirstRelativeParent = (el: Element | null) => {\n  while (el) {\n    // TODO: Remove the el.style.position after fix of this issue: https://github.com/nuxt/framework/issues/3587\n    // TODO: Remove from the va-dropdown.vue the inline style (position: relative)\n    const positionValue = window.getComputedStyle(el).getPropertyValue('position') ||\n      (el as HTMLElement).style.position\n\n    if (positionValue === 'relative') { return el }\n\n    el = el.parentElement\n  }\n\n  return document.body\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string | HTMLElement,\n  viewport?: HTMLElement,\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param anchorRef\n * @param contentRef\n * @param options make options reactive if you want popover to react on options change.\n * @param props\n */\nexport const useDropdown = (\n  anchorRef: Ref<HTMLElement | undefined>,\n  contentRef: Ref<HTMLElement | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n  props: UsePlacementAliasesProps,\n) => {\n  const documentRef = useDocument()\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) {\n      let el\n      if (typeof root === 'string') {\n        el = documentRef.value.querySelector(root)\n      } else {\n        el = root\n      }\n      if (!el) { return documentRef.value.body }\n      return findFirstRelativeParent(el)\n    }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const css = {\n    position: 'absolute',\n  }\n\n  const { position, align } = usePlacementAliases(props)\n  watchPostEffect(() => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    const { offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(position.value, align.value, anchorDomRect.value, contentDomRect.value)\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(position.value, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n    const viewportRect = unref(options).viewport?.getBoundingClientRect() ?? rootRect\n\n    if (autoPlacement) {\n      const { position: newPosition, align: newAlign } = getAutoPlacement(position.value, align.value, coords, contentDomRect.value, viewportRect)\n\n      if (newPosition !== position.value || newAlign !== align.value) {\n        coords = calculateContentCoords(newPosition, newAlign, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPosition, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect)\n    }\n\n    coords.x -= rootRect.x + rootRef.value.clientLeft\n    coords.y -= rootRect.y + rootRef.value.clientTop\n\n    if (unwrapEl(contentRef.value)) {\n      let widthCss = {}\n      if (keepAnchorWidth) {\n        const { width } = anchorDomRect.value\n        widthCss = { width: `${width}px`, maxWidth: `${width}px` }\n      }\n\n      Object.assign(unwrapEl(contentRef.value)!.style, {\n        ...css,\n        ...coordsToCss(coords),\n        ...widthCss,\n      })\n    }\n  })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n"],"names":["position","align"],"mappings":"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"}