import { u as useDomChangesObserver } from "./useDomChangesObserver.mjs";
import { g as getElementBackground } from "./utils.mjs";
import { ref, onMounted } from "vue";
import { u as useColors } from "../useColors.mjs";
import { u as useEl } from "../useEl.mjs";
import { u as useCache } from "../useCache.mjs";
import { e as applyColors } from "../../services/color/utils.mjs";
const isTransparent = (color) => color === "rgba(0, 0, 0, 0)";
const withCache = (cb) => {
  return (element, cache) => {
    if (!element) {
      return "#fff";
    }
    if (cache.has(element)) {
      return cache.get(element);
    }
    cache.set(element, cb(element, cache));
    return cache.get(element);
  };
};
const useElementBackground = (element) => {
  const el = element || useEl();
  const { getColor } = useColors();
  const background = ref(getColor("background-primary"));
  const { bgTempCache: tempCache } = useCache();
  const recursiveGetBackground = withCache((element2, cache) => {
    if (!element2) {
      return "#fff";
    }
    if (element2.nodeType !== Node.ELEMENT_NODE) {
      return recursiveGetBackground(element2.parentElement, cache);
    }
    const bg = getElementBackground(element2);
    if (!bg) {
      return recursiveGetBackground(element2.parentElement, cache);
    }
    if (isTransparent(bg)) {
      return recursiveGetBackground(element2.parentElement, cache);
    }
    return applyColors(recursiveGetBackground(element2.parentElement, cache), bg);
  });
  const updateBackground = (cache = tempCache) => {
    background.value = recursiveGetBackground(el.value, cache);
  };
  useDomChangesObserver(updateBackground, el);
  onMounted(updateBackground);
  return {
    background
  };
};
export {
  useElementBackground as u
};
//# sourceMappingURL=useElementBackground.mjs.map
