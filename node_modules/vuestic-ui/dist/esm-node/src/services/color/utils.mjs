import { k as kebabCase, j as camelCase } from "../../../vendor.mjs";
import { ColorTranslator } from "colortranslator";
const isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
const cssVariableName = (colorName) => `--va-${kebabCase(colorName)}`;
const normalizeColorName = (colorName) => camelCase(colorName);
const colorToRgba = (color, opacity) => {
  return new ColorTranslator(color).setA(opacity).RGBA;
};
const getColorLightness = (color) => {
  const { R, G, B } = new ColorTranslator(color);
  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);
};
const getBoxShadowColor = (color, opacity = 0.4) => {
  return new ColorTranslator(color).setA(opacity).RGBA;
};
const getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return new ColorTranslator(background).setA(opacity).RGBA;
};
const getHoverColor = (color, opacity = 0.2) => {
  return new ColorTranslator(color).setA(opacity).RGBA;
};
const getFocusColor = (color, opacity = 0.3) => {
  return new ColorTranslator(color).setA(opacity).RGBA;
};
const shiftHSLAColor = (color, offset) => {
  const result = new ColorTranslator(color);
  if (offset.h) {
    result.setH(result.H + offset.h);
  }
  if (offset.s) {
    result.setS(result.S + offset.s);
  }
  if (offset.l) {
    result.setL(result.L + offset.l);
  }
  if (offset.a) {
    result.setA(result.A + offset.a);
  }
  return result.HSLA;
};
const setHSLAColor = (color, newColor) => {
  const result = new ColorTranslator(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
const shiftGradientColor = (color) => {
  const newColor = ColorTranslator.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
const getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = ColorTranslator.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
const getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
const isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
const applyColors = (color1, color2) => {
  const c1 = new ColorTranslator(color1);
  const c2 = new ColorTranslator(color2);
  const weight = c2.A;
  if (weight === 1) {
    return c2.RGBA;
  }
  if (weight === 0) {
    return c1.RGBA;
  }
  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
  return c1.RGBA;
};
export {
  getBoxShadowColor as a,
  getFocusColor as b,
  getHoverColor as c,
  colorToRgba as d,
  applyColors as e,
  getBoxShadowColorFromBg as f,
  getGradientBackground as g,
  setHSLAColor as h,
  getStateMaskGradientBackground as i,
  cssVariableName as j,
  isColor as k,
  isCSSVariable as l,
  getColorLightness as m,
  normalizeColorName as n,
  shiftHSLAColor as s
};
//# sourceMappingURL=utils.mjs.map
