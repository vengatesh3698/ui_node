{"version":3,"file":"value-by-key.mjs","sources":["../../../../src/utils/value-by-key.ts"],"sourcesContent":["import isObject from 'lodash/isObject.js'\n\nimport { isNilValue } from './isNilValue'\n\ntype GetTypeByPath<T extends Record<string, any>, K extends string> =\nK extends keyof T\n    ? T[K]\n    : K extends `${infer TKey}.${infer Rest}`\n        ? GetTypeByPath<T[TKey], Rest>\n        : undefined\n\n/**\n * Resolve the path to the target property inside the provided object.\n *\n * @param option - Object to look properties inside.\n * @param propsArray - Ordered array of strings, where each string should correspond to one of the property names at the current level of the object.\n */\nexport const getNestedValue = (option: Record<string, any>, propsArray: string[]): any => {\n  if (propsArray.length === 0) { return option }\n\n  const nestedItem = option[propsArray[0]]\n  if (!isObject(nestedItem)) {\n    if (propsArray.length === 1) {\n      return nestedItem\n    }\n    return undefined\n  }\n  return getNestedValue(nestedItem, propsArray.slice(1))\n}\n\n/**\n * Finds value in the object using string with dots 'key.key.key'\n *\n * @param option - Object to look properties inside.\n * @param prop - String that contains a path to the property.\n */\nexport const getValueByPath = <\n  Key extends string, T extends Record<string | Key, unknown>\n>(option: T, prop: string | Key): GetTypeByPath<T, Key> => {\n  if (prop in option) {\n    return (option)[prop] as GetTypeByPath<T, Key>\n  }\n  prop = prop.replace(/^\\./, '') // remove first point symbol\n  return getNestedValue(option, prop.split('.'))\n}\n\n/**\n * Finds value of nested property inside an object.\n *\n * @param option - Object to look properties inside.\n * @param prop - String or function used to find nested property.\n */\nexport const getValueByKey = <\n  Option extends Record<string, unknown>, R\n>(\n    option: Option | string | boolean | number | ((...args: any[]) => any),\n    prop: string | ((option: Option) => R),\n  ) => {\n  if (isNilValue(option) || typeof option !== 'object' || Array.isArray(option)) { return undefined }\n\n  if (!prop) { return option }\n  if (typeof prop === 'string') { return getValueByPath(option, prop) }\n  if (typeof prop === 'function') { return prop(option) }\n\n  // if `prop` has different to string or function type and can't be processed\n  return option\n}\n"],"names":[],"mappings":";;AAiBa,MAAA,iBAAiB,CAAC,QAA6B,eAA8B;AACpF,MAAA,WAAW,WAAW,GAAG;AAAS,WAAA;AAAA,EAAO;AAE7C,QAAM,aAAa,OAAO,WAAW,CAAC,CAAC;AACnC,MAAA,CAAC,SAAS,UAAU,GAAG;AACrB,QAAA,WAAW,WAAW,GAAG;AACpB,aAAA;AAAA,IACT;AACO,WAAA;AAAA,EACT;AACA,SAAO,eAAe,YAAY,WAAW,MAAM,CAAC,CAAC;AACvD;AAQa,MAAA,iBAAiB,CAE5B,QAAW,SAA8C;AACzD,MAAI,QAAQ,QAAQ;AAClB,WAAQ,OAAQ,IAAI;AAAA,EACtB;AACO,SAAA,KAAK,QAAQ,OAAO,EAAE;AAC7B,SAAO,eAAe,QAAQ,KAAK,MAAM,GAAG,CAAC;AAC/C;AAQa,MAAA,gBAAgB,CAGzB,QACA,SACG;AACD,MAAA,WAAW,MAAM,KAAK,OAAO,WAAW,YAAY,MAAM,QAAQ,MAAM,GAAG;AAAS,WAAA;AAAA,EAAU;AAElG,MAAI,CAAC,MAAM;AAAS,WAAA;AAAA,EAAO;AACvB,MAAA,OAAO,SAAS,UAAU;AAAS,WAAA,eAAe,QAAQ,IAAI;AAAA,EAAE;AAChE,MAAA,OAAO,SAAS,YAAY;AAAE,WAAO,KAAK,MAAM;AAAA,EAAE;AAG/C,SAAA;AACT;"}