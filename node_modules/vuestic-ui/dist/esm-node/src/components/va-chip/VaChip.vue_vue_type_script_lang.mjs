import { defineComponent, computed, toRef } from "vue";
import { p as pick } from "../../../vendor.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { a as useColorProps, u as useColors } from "../../composables/useColors.mjs";
import { a as getBoxShadowColor, b as getFocusColor, c as getHoverColor } from "../../services/color/utils.mjs";
import { u as useStatefulEmits, a as useStatefulProps, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useRouterLinkProps, a as useRouterLink } from "../../composables/useRouterLink.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useTextColor } from "../../composables/useTextColor.mjs";
import { u as useKeyboardOnlyFocus } from "../../composables/useKeyboardOnlyFocus.mjs";
import { u as useHover } from "../../composables/useHover.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
const _sfc_main = defineComponent({
  name: "VaChip",
  components: { VaIcon },
  emits: [...useStatefulEmits, "focus"],
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    },
    ariaCloseLabel: { type: String, default: "$t:close" }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
    const size = {
      small: "0.875rem",
      medium: "1rem",
      large: "1.25rem"
    };
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    return {
      ...useTranslation(),
      keyboardFocusListeners,
      valueComputed,
      hrefComputed,
      tagComputed,
      onMouseEnter,
      onMouseLeave,
      isHovered,
      close: () => {
        if (!props.disabled) {
          valueComputed.value = false;
        }
      },
      iconSize: computed(() => size[props.size]),
      tabIndexComputed: computed(() => props.disabled ? -1 : 0),
      computedClass: useBem("va-chip", () => ({
        ...pick(props, ["disabled", "readonly", "square"]),
        small: props.size === "small",
        large: props.size === "large"
      })),
      computedStyle: computed(() => {
        const result = {
          color: textColorComputed.value,
          borderColor: borderColor.value,
          background: "",
          boxShadow: shadowStyle.value
        };
        if (props.outline || props.flat) {
          if (hasKeyboardFocus.value) {
            result.background = getFocusColor(colorComputed.value);
          } else if (!props.readonly && isHovered.value) {
            result.background = getHoverColor(colorComputed.value);
          }
        } else {
          result.background = colorComputed.value;
        }
        return result;
      })
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaChip.vue_vue_type_script_lang.mjs.map
