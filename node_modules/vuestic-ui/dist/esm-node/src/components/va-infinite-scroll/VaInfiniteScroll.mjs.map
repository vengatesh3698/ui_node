{"version":3,"file":"VaInfiniteScroll.mjs","sources":["../../../../../src/components/va-infinite-scroll/VaInfiniteScroll.vue"],"sourcesContent":["<template>\n  <component\n    :is=\"$props.tag as 'div'\"\n    ref=\"element\"\n    role=\"feed\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    :aria-busy=\"fetching\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      ref=\"spinnerSlotContainer\"\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n    >\n      <slot\n        v-if=\"!$props.disabled\"\n        name=\"loading\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, shallowRef, watch } from 'vue'\nimport debounce from 'lodash/debounce.js'\n\nimport { sleep } from '../../utils/sleep'\nimport { useColors } from '../../composables'\nimport { useScroll } from './hooks/useScroll'\n\nimport { VaProgressCircle } from '../va-progress-circle'\nimport { useComponentPresetProp } from '../../composables/useComponentPreset'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    ...useComponentPresetProp,\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [String, Object] as PropType<string | HTMLElement>, default: undefined },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n    const spinnerSlotContainer = shallowRef<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { getColor } = useColors()\n\n    const spinnerColor = computed(() => {\n      return error.value ? getColor('danger') : getColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n"],"names":["_resolveComponent","_openBlock","_createBlock","_resolveDynamicComponent","_normalizeClass","_withCtx","_renderSlot","_createElementVNode","_createVNode"],"mappings":";;;;;;wCA8BcA,iBA5BK,oBAAA;SAEVC,UAAM,GAAAC,YAAAC,wBAAA,KAAA,OAAA,GAAA,GAAA;AAAA,IACX,KAAK;AAAA,IAEJ,MAAA;AAAA,IAAA,OAAAC,eAAA,CAAA,sBAAA,EAAA,gCAAA,KAAA,OAAA,QAAA,CAAA,CAAA;AAAA,IAED,aAAA,KAAA;AAAA,EAAA,GAAA;AAAA,aAEAC,QAkBM,MAAA;AAAA,MAAAC,WAjBA,KAAsB,QAAA,SAAA;AAAA,MAAAC,mBACrB,OAAC;AAAA,QAAA,KAAA;AAAA,eAIGH,eAAe,CAAA,+BAAA,EAAA,0CAAA,CAAA,KAAA,SAAA,CAAA,CAAA;AAAA,MAAA,GAAA;AAAA,QAGtB,CAAA,KAAA,OAAA,WAAAE,WACE,KAKE,QAAA,WAAA,EAAA,KAAA,EAAA,GAAA,MAAA;AAAA,UAJYC,mBAAA,OAAA,YAAA;AAAA,YAAAC,YACA,+BAAI;AAAA,cACf,MAAK;AAAA,cACN,WAAA;AAAA,cAAA,OAAA,KAAA;AAAA;;;;;;;;;;"}