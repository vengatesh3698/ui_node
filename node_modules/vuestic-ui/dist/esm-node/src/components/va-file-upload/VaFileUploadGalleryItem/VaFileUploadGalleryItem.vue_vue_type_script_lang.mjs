import { defineComponent, ref, computed, onMounted, watch, toRef } from "vue";
import { V as VaFileUploadKey } from "../types.mjs";
import { u as useTextColor } from "../../../composables/useTextColor.mjs";
import { V as VaFileUploadUndo } from "../VaFileUploadUndo/index.mjs";
import { V as VaButton } from "../../va-button/index.mjs";
import { V as VaListItem, a as VaListItemSection } from "../../va-list/index.mjs";
import { d as colorToRgba } from "../../../services/color/utils.mjs";
import { u as useStrictInject } from "../../../composables/useStrictInject.mjs";
import { u as useFocus } from "../../../composables/useFocus.mjs";
import { u as useBem } from "../../../composables/useBem.mjs";
import { u as useTranslation } from "../../../composables/useTranslation.mjs";
const INJECTION_ERROR_MESSAGE = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
const _sfc_main = defineComponent({
  name: "VaFileUploadGalleryItem",
  components: {
    VaFileUploadUndo,
    VaButton,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: { type: String, default: "$t:removeFile" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, undoDuration.value ?? 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e) => {
          var _a, _b;
          if (((_a = e.target) == null ? void 0 : _a.result).includes("image")) {
            previewImage.value = (_b = e.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    return {
      ...useTranslation(),
      undo,
      ...useTextColor(toRef(props, "color")),
      removed,
      disabled,
      isFocused,
      previewImage,
      classesComputed,
      overlayStylesComputed,
      onBlur,
      onFocus,
      removeImage,
      recoverImage
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaFileUploadGalleryItem.vue_vue_type_script_lang.mjs.map
