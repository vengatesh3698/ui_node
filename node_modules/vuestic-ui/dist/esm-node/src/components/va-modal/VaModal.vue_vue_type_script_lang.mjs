import { defineComponent, h, Transition, shallowRef, toRef, computed, watchEffect, watch, onMounted, nextTick } from "vue";
import { V as VaButton } from "../va-button/index.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { u as useBlur } from "./hooks/useBlur.mjs";
import { u as useStatefulEmits, a as useStatefulProps, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useTrapFocus } from "../../composables/useTrapFocus.mjs";
import { u as useModalLevel } from "../../composables/useModalLevel.mjs";
import { u as useClickOutside } from "../../composables/useClickOutside.mjs";
import { u as useWindow } from "../../composables/useWindow.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
import { u as useTextColor } from "../../composables/useTextColor.mjs";
import { u as useDocument } from "../../composables/useDocument.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
const ModalElement = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a;
    return props.isTransition ? h(Transition, { ...attrs }, slots) : (_a = slots.default) == null ? void 0 : _a.call(slots, attrs);
  }
});
const _sfc_main = defineComponent({
  name: "VaModal",
  inheritAttrs: false,
  components: { VaButton, VaIcon, ModalElement },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  props: {
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    allowBodyScroll: { type: Boolean, default: false },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "$t:ok" },
    cancelText: { type: String, default: "$t:cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false },
    beforeClose: { type: Function },
    ariaCloseLabel: { type: String, default: "$t:close" }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const modalDialog = shallowRef();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding,
      [`va-modal--size-${props.size}`]: props.size !== "medium"
    }));
    const computedModalContainerStyle = computed(() => ({ "z-index": props.zIndex }));
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayStyles = computed(() => {
      if (!props.overlay || !isLowestLevelModal.value) {
        return;
      }
      return {
        "background-color": `rgba(0, 0, 0, ${props.overlayOpacity})`,
        "z-index": props.zIndex && Number(props.zIndex) - 1
      };
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = (cb) => {
      const _hide = () => {
        valueComputed.value = false;
        cb == null ? void 0 : cb();
      };
      props.beforeClose ? props.beforeClose(_hide) : _hide();
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      hide(() => emit("cancel"));
    };
    const ok = () => {
      hide(() => emit("ok"));
    };
    const trapFocusInModal = () => {
      nextTick(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e) => {
      const hideModal = () => {
        if (e.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    useClickOutside([modalDialog], () => {
      if (!valueComputed.value || props.noOutsideDismiss || props.noDismiss || !isTopLevelModal.value) {
        return;
      }
      emit("click-outside");
      cancel();
    });
    const window = useWindow();
    watchEffect(() => {
      var _a, _b;
      if (valueComputed.value) {
        (_a = window.value) == null ? void 0 : _a.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    useBlur(toRef(props, "blur"), valueComputed);
    const documentRef = useDocument();
    const setBodyOverflow = (overflow) => {
      if (!documentRef.value || props.allowBodyScroll) {
        return;
      }
      documentRef.value.body.style.overflow = overflow;
    };
    watch(valueComputed, (newValueComputed) => {
      if (newValueComputed) {
        registerModal();
        setBodyOverflow("hidden");
        return;
      }
      if (isLowestLevelModal.value) {
        freeFocus();
        setBodyOverflow("");
      }
      unregisterModal();
    });
    watch(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    });
    onMounted(() => {
      if (valueComputed.value) {
        registerModal();
      }
    });
    const publicMethods = {
      ...useTranslation(),
      show,
      hide,
      toggle,
      cancel,
      ok,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    };
    return {
      getColor,
      rootElement,
      modalDialog,
      valueComputed,
      computedClass,
      computedDialogStyle,
      computedModalContainerStyle,
      computedOverlayStyles,
      ...publicMethods
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaModal.vue_vue_type_script_lang.mjs.map
