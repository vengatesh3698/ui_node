import { defineComponent, ref, computed, onMounted, onBeforeUnmount } from "vue";
import { V as VaButton } from "../va-button/index.mjs";
import { i as isServer } from "../../utils/ssr.mjs";
import { w as warn } from "../../utils/console.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
const _sfc_main = defineComponent({
  name: "VaBacktop",
  components: { VaButton },
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    },
    ariaLabel: { type: String, default: "$t:backToTop" }
  },
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > props.visibilityHeight;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    return {
      computedStyle,
      visible,
      scrollToTop,
      ...useTranslation()
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaBacktop.vue_vue_type_script_lang.mjs.map
