import { computed, toRef } from "vue";
import { p as placementsPositionsWithAliases, u as usePlacementAliases } from "../../../composables/usePlacementAliases.mjs";
import { u as useParsableMeasure } from "../../../composables/useParsableMeasure.mjs";
const { isParsableMeasure, parseSizeValue } = useParsableMeasure();
const useFloatingPositionProps = {
  overlap: { type: Boolean, default: false },
  placement: {
    type: String,
    default: "top-end",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  },
  offset: {
    type: [Number, String],
    default: 0,
    validator: (value) => {
      if (typeof value === "string") {
        return isParsableMeasure(value);
      }
      return !isNaN(value);
    }
  }
};
const useFloatingPosition = (props, floating) => {
  if (!floating.value) {
    return {};
  }
  const { position, align } = usePlacementAliases(props);
  const centerAlignment = computed(() => align.value === "center" ? "-50%" : "0%");
  const transformComputed = computed(() => {
    const options = {
      top: { transform: `translateX(${centerAlignment.value}) translateY(-100%)` },
      bottom: { transform: "translateX(0) translateY(100%)" },
      left: { transform: "translateX(-100%) translateY(-50%)" },
      right: { transform: `translateX(100%) translateY(${centerAlignment.value})` }
    };
    return options[position.value];
  });
  const getOverlapMargin = computed(() => {
    var _a;
    if (!props.overlap) {
      return {};
    }
    const result = { [`margin-${position.value}`]: "var(--va-badge-overlap)" };
    const alignComplianceTable = {
      top: { end: "left", multiplier: -1 },
      bottom: { start: "left", multiplier: 1 }
    };
    const alignComplianceValue = (_a = alignComplianceTable[position.value]) == null ? void 0 : _a[align.value];
    if (alignComplianceValue) {
      Object.assign(result, {
        [`margin-${alignComplianceValue}`]: `calc(${alignComplianceTable[position.value].multiplier} * var(--va-badge-overlap))`
      });
    }
    return result;
  });
  const getAlignment = computed(() => {
    const baseSide = ["left", "right"].includes(position.value) ? "top" : "left";
    const alignmentOptions = { start: { [baseSide]: 0 }, center: { [baseSide]: "50%" }, end: { [baseSide]: "100%" } };
    return alignmentOptions[align.value];
  });
  const offset = toRef(props, "offset");
  return computed(() => ({
    [position.value]: `${parseSizeValue(offset)}px`,
    ...transformComputed.value,
    ...getAlignment.value,
    ...getOverlapMargin.value
  }));
};
export {
  useFloatingPosition as a,
  useFloatingPositionProps as u
};
//# sourceMappingURL=useFloatingPositionStyles.mjs.map
