import { defineComponent, shallowRef, computed, toRefs } from "vue";
import { o as omit, p as pick } from "../../../vendor.mjs";
import { u as useCleaveProps, a as useCleave } from "./hooks/useCleave.mjs";
import { V as VaInputWrapper } from "./components/VaInputWrapper/VaInputWrapper.mjs";
import { V as VaTextarea } from "./components/VaTextarea/VaTextarea.mjs";
import { V as VaIcon } from "../va-icon/VaIcon.mjs";
import { f as focusElement, b as blurElement } from "../../utils/focus.mjs";
import { u as unwrapEl } from "../../utils/unwrapEl.mjs";
import { u as useClearableProps, a as useClearableEmits, b as useClearable } from "../../composables/useClearable.mjs";
import { u as useValidationProps, a as useValidationEmits, b as useValidation } from "../../composables/useValidation.mjs";
import { u as useFocusDeep } from "../../composables/useFocusDeep.mjs";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.mjs";
import { u as useFormFieldProps } from "../../composables/useFormField.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.mjs";
import { u as useEmitProxy } from "../../composables/useEmitProxy.mjs";
const VaTextareaProps = extractComponentProps(VaTextarea);
const { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur"]
);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
const _sfc_main = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaTextarea, VaIcon },
  props: {
    ...useFormFieldProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useCleaveProps,
    ...VaTextareaProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [String, Number] },
    label: { type: String, default: "" },
    type: { type: String, default: "text" },
    loading: { type: Boolean, default: false },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    ariaLabel: { type: String, default: void 0 },
    counter: { type: Boolean, default: false },
    maxLength: { type: Number, default: void 0 },
    // style
    color: { type: String, default: "primary" },
    background: { type: String, default: "background-element" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false },
    ariaResetLabel: { type: String, default: "$t:reset" }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useStatefulEmits
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: "" });
    const isFocused = useFocusDeep();
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      blurElement(unwrapEl(input.value));
    };
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const computedCleaveTarget = computed(() => props.type === "textarea" ? void 0 : input.value);
    const { computedValue, onInput } = useCleave(computedCleaveTarget, props, valueComputed);
    const inputListeners = createInputListeners(emit);
    const onFocus = (e) => {
      inputListeners.onFocus(e);
      validationListeners.onFocus();
    };
    const onBlur = (e) => {
      inputListeners.onBlur(e);
      validationListeners.onBlur();
    };
    const inputEvents = {
      ...inputListeners,
      onFocus,
      onBlur,
      onInput
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => ({
      "aria-label": props.ariaLabel || props.label,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "minlength", "maxlength"])
    }));
    const valueLengthComputed = computed(
      () => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0
    );
    return {
      ...useTranslation(),
      input,
      inputEvents,
      isLoading,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      textareaProps: filterComponentProps(VaTextareaProps),
      computedValue,
      tabIndexComputed,
      // Validations
      computedError,
      computedErrorMessages,
      isFocused,
      // Icon
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      reset,
      focus,
      blur
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaInput.vue_vue_type_script_lang.mjs.map
