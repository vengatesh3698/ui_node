import { defineComponent, computed, toRef } from "vue";
import { p as pick } from "../../../../../vendor.mjs";
import { V as VaMessageList } from "../VaMessageList/index.mjs";
import { V as VaIcon } from "../../../va-icon/index.mjs";
import { u as useFormFieldProps } from "../../../../composables/useFormField.mjs";
import { u as useValidationProps } from "../../../../composables/useValidation.mjs";
import { u as useCSSVariables } from "../../../../composables/useCSSVariables.mjs";
import { u as useColors } from "../../../../composables/useColors.mjs";
import { u as useBem } from "../../../../composables/useBem.mjs";
import { u as useTextColor } from "../../../../composables/useTextColor.mjs";
const _sfc_main = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList, VaIcon },
  props: {
    ...useFormFieldProps,
    ...useValidationProps,
    counterValue: { type: Number, default: void 0 },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String, default: "background-element" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    error: { type: Boolean, default: false },
    success: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner"
  ],
  setup(props) {
    const { getColor } = useColors();
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick(props, ["outline", "bordered", "success", "focused", "error", "disabled", "readonly"]),
      labeled: !!props.label,
      solid: !props.outline && !props.bordered
    }));
    const wrapperStyle = useCSSVariables("va-input-wrapper", () => ({
      color: colorComputed.value
    }));
    const colorComputed = computed(() => getColor(props.color));
    const backgroundComputed = computed(() => getColor(props.background));
    const borderColorComputed = computed(() => props.focused ? colorComputed.value : void 0);
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const hasMessages = computed(() => {
      var _a;
      return Boolean(
        typeof messagesComputed.value === "string" ? messagesComputed.value : (_a = messagesComputed.value) == null ? void 0 : _a.length
      );
    });
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const containerStyle = computed(() => ({
      color: textColorComputed.value,
      "caret-color": textColorComputed.value,
      "--va-input-color": props.background ? getColor(props.background) : void 0,
      borderColor: borderColorComputed.value
    }));
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => props.counterValue !== void 0);
    const counterComputed = computed(
      () => props.maxLength !== void 0 ? `${props.counterValue}/${props.maxLength}` : props.counterValue
    );
    return {
      containerStyle,
      wrapperClass,
      wrapperStyle,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      backgroundComputed,
      borderColorComputed,
      messagesColor,
      messagesComputed,
      hasMessages,
      errorLimit
    };
  },
  methods: {
    focus() {
      this.$el.focus();
    },
    blur() {
      this.$el.blur();
    }
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaInputWrapper.vue_vue_type_script_lang.mjs.map
