import { defineComponent, shallowRef, computed, ref, onMounted, nextTick, onBeforeUnmount } from "vue";
import { n as noop } from "../../../vendor.mjs";
import { g as getWindow } from "../../utils/ssr.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useEventsHandlerWithThrottle, h as handleThrottledEvent, g as getWindowHeight } from "./VaAffix-utils.mjs";
const _sfc_main = defineComponent({
  name: "VaAffix",
  emits: ["change"],
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  },
  setup(props, { emit }) {
    const element = shallowRef();
    const getTargetElement = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement();
      if (!target) {
        return 0;
      }
      if (props.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props.offsetTop;
      }
      return props.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement();
      if (!target) {
        return 0;
      }
      if (props.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
      }
      return props.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop;
    onMounted(() => {
      var _a;
      initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return {
      computedClass,
      computedStyle,
      isAffixed,
      element
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaAffix.vue_vue_type_script_lang.mjs.map
