import { V as VaTimePickerColumnCell } from "../VaTimePickerColumnCell.mjs";
import { defineComponent, shallowRef, watch, onMounted, nextTick, computed } from "vue";
import { d as debounce } from "../../../../../vendor.mjs";
import { a as useFocusEmits, u as useFocus } from "../../../../composables/useFocus.mjs";
import { u as useSyncProp } from "../../../../composables/useSyncProp.mjs";
import { u as useElementBackground } from "../../../../composables/useElementBackground/useElementBackground.mjs";
import { u as useTextColor } from "../../../../composables/useTextColor.mjs";
const _sfc_main = defineComponent({
  name: "VaTimePickerColumn",
  components: { VaTimePickerColumnCell },
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        var _a, _b;
        (_b = (_a = rootElement.value) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
          behavior: animated ? "smooth" : "auto",
          top: index * props.cellHeight
        });
      });
    };
    const makeActiveByIndex = (index) => {
      syncActiveItemIndex.value = index;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n) => {
      if (!Number.isInteger(n)) {
        return n;
      }
      return Number(n) < 10 ? `0${n}` : `${n}`;
    };
    const { background } = useElementBackground(rootElement);
    const { textColorComputed } = useTextColor(background);
    const styleComputed = computed(() => ({
      color: textColorComputed.value
    }));
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max(
        (scrollTop - scrollTop % props.cellHeight) / props.cellHeight,
        scrollTop / props.cellHeight
      );
      if (calculatedIndex >= props.items.length) {
        return props.items.length - 1;
      }
      if (calculatedIndex < 0) {
        return 0;
      }
      if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    return {
      syncActiveItemIndex,
      rootElement,
      makeActiveNext,
      makeActivePrev,
      makeActiveByIndex,
      onScroll,
      onCellClick,
      formatCell,
      styleComputed,
      focus,
      blur
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaTimePickerColumn.vue_vue_type_script_lang.mjs.map
