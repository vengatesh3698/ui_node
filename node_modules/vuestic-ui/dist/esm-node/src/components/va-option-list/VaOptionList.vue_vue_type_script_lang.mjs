import { defineComponent, computed, onMounted } from "vue";
import { p as pick } from "../../../vendor.mjs";
import { i as isDev } from "../../utils/env.mjs";
import { V as VaCheckbox } from "../va-checkbox/index.mjs";
import { V as VaRadio } from "../va-radio/index.mjs";
import { V as VaSwitch } from "../va-switch/index.mjs";
import { V as VaMessageListWrapper } from "../va-input/components/VaMessageListWrapper.mjs";
import { u as useArrayRefs } from "../../composables/useArrayRefs.mjs";
import { u as useStatefulEmits, a as useStatefulProps, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.mjs";
import { u as useValidationProps, b as useValidation } from "../../composables/useValidation.mjs";
const _sfc_main = defineComponent({
  name: "VaOptionList",
  components: {
    VaRadio,
    VaCheckbox,
    VaSwitch,
    VaMessageListWrapper
  },
  emits: [...useStatefulEmits, "clear"],
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Boolean, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Boolean, Object, Array] }
  },
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: props.defaultValue });
    const { getValue, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue) : [value ? getValue(value) : value];
        }
      }
    });
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus, value: valueComputed });
    const computedProps = computed(() => pick(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (isDev && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    return {
      selectedValue,
      computedError,
      computedErrorMessages,
      getValue,
      getText,
      getTrackBy,
      isDisabled,
      reset,
      focus,
      setItemRef,
      computedProps
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaOptionList.vue_vue_type_script_lang.mjs.map
