import { defineComponent, shallowRef, computed, toRef, h, Fragment, Teleport, nextTick } from "vue";
import { p as pick, k as kebabCase } from "../../../vendor.mjs";
import { u as useAnchorSelector } from "./hooks/useAnchorSelector.mjs";
import { u as useCursorAnchor } from "./hooks/useCursorAnchor.mjs";
import { u as useKeyboardNavigation, a as useMouseNavigation } from "./hooks/useDropdownNavigation.mjs";
import { a as renderSlotNode } from "../../utils/headless.mjs";
import { w as warn } from "../../utils/console.mjs";
import { c as createStatefulProps, u as useStatefulEmits, b as useStateful } from "../../composables/useStateful.mjs";
import { a as usePlacementAliasesProps } from "../../composables/usePlacementAliases.mjs";
import { u as useDebounceFn } from "../../composables/useDebounce.mjs";
import { u as useHTMLElementSelector } from "../../composables/useHTMLElementSelector.mjs";
import { u as useDropdown } from "../../composables/useDropdown.mjs";
import { u as useIsMounted } from "../../composables/useIsMounted.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";
import { u as useBem } from "../../composables/useBem.mjs";
import { u as useHTMLElement } from "../../composables/useHTMLElement.mjs";
import { u as useClickOutside } from "../../composables/useClickOutside.mjs";
import { u as useDocument } from "../../composables/useDocument.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
const _sfc_main = defineComponent({
  name: "VaDropdown",
  inheritAttrs: false,
  props: {
    ...createStatefulProps(Boolean, true),
    ...useComponentPresetProp,
    ...usePlacementAliasesProps,
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    /** Viewport where dropdown will be rendered if preventOverflow is true. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    preventOverflow: { type: Boolean, default: false },
    keepAnchorWidth: { type: Boolean, default: false },
    isContentHoverable: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    offset: { type: [Array, Number], default: 0 },
    stickToEdges: { type: Boolean, default: false },
    autoPlacement: { type: Boolean, default: true },
    cursor: { type: Boolean, default: false },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: false },
    ariaLabel: { type: String, default: "$t:toggleDropdown" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit, slots, attrs }) {
    const contentRef = shallowRef();
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const computedClass = useBem("va-dropdown", () => pick(props, ["disabled"]));
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onMouseEnter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseLeave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    const emitAndClose = (eventName, close, e) => {
      emit(eventName, e);
      if (close && props.trigger !== "none") {
        valueComputed.value = false;
      }
    };
    const elRef = useHTMLElement("computedAnchorRef");
    if (props.keyboardNavigation) {
      useKeyboardNavigation(elRef, valueComputed);
    }
    useMouseNavigation(elRef, {
      click(e) {
        if (props.trigger !== "click" && kebabCase(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-click", props.closeOnAnchorClick, e);
        } else {
          if (props.trigger !== "click") {
            return;
          }
          valueComputed.value = true;
          emit("anchor-click", e);
        }
      },
      contextmenu(e) {
        if (kebabCase(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        e.preventDefault();
        if (valueComputed.value) {
          emitAndClose("anchor-right-click", props.closeOnAnchorClick, e);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-right-click", e);
        }
      },
      dblclick(e) {
        if (props.trigger !== "dblclick" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-dblclick", props.closeOnAnchorClick, e);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-dblclick", e);
        }
      },
      mouseenter: onMouseEnter,
      mouseleave: onMouseLeave
    });
    const { anchorRef: computedAnchorRef } = useAnchorSelector(props);
    useClickOutside([computedAnchorRef, contentRef], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    const cursorAnchor = useCursorAnchor(computedAnchorRef, valueComputed);
    const document = useDocument();
    const isPopoverFloating = computed(() => props.preventOverflow);
    const target = useHTMLElementSelector(computed(() => props.target || "body"));
    const teleport = useHTMLElementSelector(computed(() => props.teleport));
    const targetComputed = computed(() => {
      var _a, _b, _c;
      if (computedAnchorRef.value && !((_b = (_a = target.value) == null ? void 0 : _a.contains) == null ? void 0 : _b.call(_a, computedAnchorRef.value))) {
        return (_c = document.value) == null ? void 0 : _c.body;
      }
      return target.value;
    });
    const teleportTargetComputed = computed(() => {
      var _a;
      if (teleport.value) {
        return teleport.value;
      }
      if (!isPopoverFloating.value) {
        return ((_a = elRef.value) == null ? void 0 : _a.parentElement) || void 0;
      }
      return targetComputed.value;
    });
    const teleportDisabled = computed(() => {
      if (teleport.value) {
        return false;
      }
      return props.disabled || !isPopoverFloating.value;
    });
    useDropdown(
      computed(() => props.cursor ? cursorAnchor.value : computedAnchorRef.value),
      contentRef,
      computed(() => ({
        keepAnchorWidth: props.keepAnchorWidth,
        offset: props.offset,
        stickToEdges: props.stickToEdges,
        autoPlacement: props.autoPlacement,
        root: teleportTargetComputed.value,
        viewport: targetComputed.value
      })),
      props
    );
    const isMounted = useIsMounted();
    return {
      ...useTranslation(),
      isMounted,
      valueComputed,
      computedAnchorRef,
      computedClass,
      onMouseEnter,
      teleportTargetComputed,
      teleportDisabled,
      onMouseLeave,
      emitAndClose,
      contentRef
    };
  },
  render() {
    const slotBinds = {
      value: this.valueComputed.value,
      hide: () => {
        this.valueComputed.value = false;
      },
      show: () => {
        this.valueComputed.value = true;
      }
    };
    const defaultSlotVNode = renderSlotNode(this.$slots.default, slotBinds, {
      ref: "contentRef",
      class: "va-dropdown__content-wrapper",
      onMouseOver: () => this.$props.isContentHoverable && this.onMouseEnter(),
      onMouseOut: () => this.onMouseLeave(),
      onClick: () => this.emitAndClose("content-click", this.$props.closeOnContentClick)
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, slotBinds, {
      ref: "computedAnchorRef",
      role: "button",
      class: ["va-dropdown", ...this.computedClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": !!this.valueComputed.value,
      ...this.$attrs
    });
    if (!anchorSlotVNode) {
      warn("VaDropdown: You must provide an anchor slot");
      return;
    }
    if (!defaultSlotVNode) {
      warn("VaDropdown: default slot is missing");
      return h(anchorSlotVNode);
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      this.isMounted && this.valueComputed && h(
        Teleport,
        {
          to: this.teleportTargetComputed,
          disabled: this.teleportDisabled
        },
        [defaultSlotVNode]
      )
    ]);
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=VaDropdown.vue_vue_type_script_lang.mjs.map
