{"ast":null,"code":"import { computed, toRef } from \"vue\";\nimport { p as placementsPositionsWithAliases, u as usePlacementAliases } from \"../../../composables/usePlacementAliases-c092b4d3.mjs\";\nimport { u as useParsableMeasure } from \"../../../composables/useParsableMeasure-df21fd20.mjs\";\nconst {\n  isParsableMeasure,\n  parseSizeValue\n} = useParsableMeasure();\nconst useFloatingPositionProps = {\n  overlap: {\n    type: Boolean,\n    default: false\n  },\n  placement: {\n    type: String,\n    default: \"top-end\",\n    validator: position => placementsPositionsWithAliases.includes(position)\n  },\n  offset: {\n    type: [Number, String],\n    default: 0,\n    validator: value => {\n      if (typeof value === \"string\") {\n        return isParsableMeasure(value);\n      }\n      return !isNaN(value);\n    }\n  }\n};\nconst useFloatingPosition = (props, floating) => {\n  if (!floating.value) {\n    return {};\n  }\n  const {\n    position,\n    align\n  } = usePlacementAliases(props);\n  const centerAlignment = computed(() => align.value === \"center\" ? \"-50%\" : \"0%\");\n  const transformComputed = computed(() => {\n    const options = {\n      top: {\n        transform: `translateX(${centerAlignment.value}) translateY(-100%)`\n      },\n      bottom: {\n        transform: \"translateX(0) translateY(100%)\"\n      },\n      left: {\n        transform: \"translateX(-100%) translateY(-50%)\"\n      },\n      right: {\n        transform: `translateX(100%) translateY(${centerAlignment.value})`\n      }\n    };\n    return options[position.value];\n  });\n  const getOverlapMargin = computed(() => {\n    var _a;\n    if (!props.overlap) {\n      return {};\n    }\n    const result = {\n      [`margin-${position.value}`]: \"var(--va-badge-overlap)\"\n    };\n    const alignComplianceTable = {\n      top: {\n        end: \"left\",\n        multiplier: -1\n      },\n      bottom: {\n        start: \"left\",\n        multiplier: 1\n      }\n    };\n    const alignComplianceValue = (_a = alignComplianceTable[position.value]) == null ? void 0 : _a[align.value];\n    if (alignComplianceValue) {\n      Object.assign(result, {\n        [`margin-${alignComplianceValue}`]: `calc(${alignComplianceTable[position.value].multiplier} * var(--va-badge-overlap))`\n      });\n    }\n    return result;\n  });\n  const getAlignment = computed(() => {\n    const baseSide = [\"left\", \"right\"].includes(position.value) ? \"top\" : \"left\";\n    const alignmentOptions = {\n      start: {\n        [baseSide]: 0\n      },\n      center: {\n        [baseSide]: \"50%\"\n      },\n      end: {\n        [baseSide]: \"100%\"\n      }\n    };\n    return alignmentOptions[align.value];\n  });\n  const offset = toRef(props, \"offset\");\n  return computed(() => ({\n    [position.value]: `${parseSizeValue(offset)}px`,\n    ...transformComputed.value,\n    ...getAlignment.value,\n    ...getOverlapMargin.value\n  }));\n};\nexport { useFloatingPosition as a, useFloatingPositionProps as u };","map":{"version":3,"names":["isParsableMeasure","parseSizeValue","useParsableMeasure","useFloatingPositionProps","overlap","type","Boolean","default","placement","String","validator","position","placementsPositionsWithAliases","includes","offset","Number","value","isNaN","useFloatingPosition","props","floating","align","usePlacementAliases","centerAlignment","computed","transformComputed","options","top","transform","bottom","left","right","getOverlapMargin","result","alignComplianceTable","end","multiplier","start","alignComplianceValue","_a","Object","assign","getAlignment","baseSide","alignmentOptions","center","toRef"],"sources":["../../../../../../src/components/va-badge/hooks/useFloatingPositionStyles.ts"],"sourcesContent":["import { PropType, Ref, computed, ExtractPropTypes, toRef } from 'vue'\n\nimport { usePlacementAliases, placementsPositionsWithAliases, useParsableMeasure } from '../../../composables'\n\nimport type { PlacementAlignment, PlacementPosition, PlacementWithAlias } from '../../../composables'\ntype AlignComplianceTable = Record<PlacementPosition, Record<PlacementAlignment, string> & { multiplier: number }>\n\nconst { isParsableMeasure, parseSizeValue } = useParsableMeasure()\n\nexport const useFloatingPositionProps = {\n  overlap: { type: Boolean, default: false },\n  placement: {\n    type: String as PropType<PlacementWithAlias>,\n    default: 'top-end',\n    validator: (position: PlacementWithAlias) => placementsPositionsWithAliases.includes(position),\n  },\n  offset: {\n    type: [Number, String] as PropType<string | number>,\n    default: 0,\n    validator: (value: string | number) => {\n      if (typeof value === 'string') {\n        return isParsableMeasure(value)\n      }\n\n      return !isNaN(value)\n    },\n  },\n}\n\nexport const useFloatingPosition = (\n  props: ExtractPropTypes<typeof useFloatingPositionProps>,\n  floating: Ref<boolean>,\n) => {\n  if (!floating.value) { return {} }\n\n  const { position, align } = usePlacementAliases(props)\n  const centerAlignment = computed(() => align.value === 'center' ? '-50%' : '0%')\n  const transformComputed = computed(() => {\n    const options = {\n      top: { transform: `translateX(${centerAlignment.value}) translateY(-100%)` },\n      bottom: { transform: 'translateX(0) translateY(100%)' },\n      left: { transform: 'translateX(-100%) translateY(-50%)' },\n      right: { transform: `translateX(100%) translateY(${centerAlignment.value})` },\n    }\n\n    return options[position.value]\n  })\n\n  const getOverlapMargin = computed(() => {\n    if (!props.overlap) { return {} }\n\n    const result = { [`margin-${position.value}`]: 'var(--va-badge-overlap)' }\n\n    const alignComplianceTable = {\n      top: { end: 'left', multiplier: -1 },\n      bottom: { start: 'left', multiplier: 1 },\n    } as AlignComplianceTable\n\n    const alignComplianceValue = alignComplianceTable[position.value]?.[align.value]\n    if (alignComplianceValue) {\n      Object.assign(result, {\n        [`margin-${alignComplianceValue}`]: `calc(${alignComplianceTable[position.value].multiplier} * var(--va-badge-overlap))`,\n      })\n    }\n\n    return result\n  })\n\n  const getAlignment = computed(() => {\n    const baseSide = ['left', 'right'].includes(position.value) ? 'top' : 'left'\n    const alignmentOptions = { start: { [baseSide]: 0 }, center: { [baseSide]: '50%' }, end: { [baseSide]: '100%' } }\n    return alignmentOptions[align.value]\n  })\n\n  const offset = toRef(props, 'offset')\n\n  return computed(() => ({\n    [position.value]: `${parseSizeValue(offset)}px`,\n    ...transformComputed.value,\n    ...getAlignment.value,\n    ...getOverlapMargin.value,\n  }))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}