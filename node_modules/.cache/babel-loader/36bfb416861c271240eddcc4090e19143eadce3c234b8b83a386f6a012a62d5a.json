{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, shallowRef, computed, ref, watch } from \"vue\";\nimport { p as pick } from \"../../../../../vendor-fff696df.mjs\";\nimport { s as scrollToElement } from \"../../../../utils/scroll-to-element-c97eed1f.mjs\";\nimport { V as VaVirtualScroller } from \"../../../va-virtual-scroller/index-c6f356cf.mjs\";\nimport { V as VaSelectOption } from \"../VaSelectOption/index-69ff2ec1.mjs\";\nimport { i as isNilValue } from \"../../../../utils/isNilValue-745d19e7.mjs\";\nimport { u as useObjectRefs } from \"../../../../composables/useObjectRefs-a4ca85fa.mjs\";\nimport { a as useColorProps } from \"../../../../composables/useColors-f23d24ff.mjs\";\nimport { u as useComponentPresetProp } from \"../../../../composables/useComponentPreset-0dfbd395.mjs\";\nimport { u as useSelectableListProps, a as useSelectableList } from \"../../../../composables/useSelectableList-a02a95a9.mjs\";\nimport { u as useThrottleProps, a as useThrottleValue } from \"../../../../composables/useThrottle-cdbdff3a.mjs\";\nimport { e as extractHTMLElement } from \"../../../../composables/useHTMLElement-beee793a.mjs\";\nconst _sfc_main = defineComponent({\n  name: \"VaSelectOptionList\",\n  components: {\n    VaVirtualScroller,\n    VaSelectOption\n  },\n  emits: [\"select-option\", \"update:hoveredOption\", \"no-previous-option-to-hover\", \"scroll-bottom\"],\n  props: {\n    ...useColorProps,\n    ...useComponentPresetProp,\n    ...useSelectableListProps,\n    ...useThrottleProps,\n    noOptionsText: {\n      type: String,\n      default: \"Items not found\"\n    },\n    getSelectedState: {\n      type: Function,\n      required: true\n    },\n    multiple: {\n      type: Boolean,\n      default: false\n    },\n    search: {\n      type: String,\n      default: \"\"\n    },\n    tabindex: {\n      type: [String, Number],\n      default: 0\n    },\n    hoveredOption: {\n      type: [String, Number, Boolean, Object],\n      default: null\n    },\n    virtualScroller: {\n      type: Boolean,\n      default: true\n    },\n    highlightMatchedText: {\n      type: Boolean,\n      default: true\n    },\n    minSearchChars: {\n      type: Number,\n      default: 0\n    },\n    autoSelectFirstOption: {\n      type: Boolean,\n      default: false\n    },\n    selectedTopShown: {\n      type: Boolean,\n      default: false\n    }\n  },\n  setup(props, {\n    emit\n  }) {\n    const root = shallowRef();\n    const focus = () => {\n      var _a;\n      (_a = root.value) == null ? void 0 : _a.focus({\n        preventScroll: true\n      });\n    };\n    const rootHeight = computed(() => {\n      var _a;\n      return ((_a = root.value) == null ? void 0 : _a.clientHeight) ?? 200;\n    });\n    const handleScrollToBottom = () => emit(\"scroll-bottom\");\n    const onScroll = event => {\n      const target = event.target;\n      if (!target) {\n        return;\n      }\n      if (target.scrollTop + target.clientHeight === target.scrollHeight) {\n        handleScrollToBottom();\n      }\n    };\n    const lastInteractionSource = ref(\"\");\n    const currentOptionComputed = computed(() => props.hoveredOption ?? null);\n    const updateCurrentOption = (option, source) => {\n      emit(\"update:hoveredOption\", option);\n      lastInteractionSource.value = source;\n    };\n    const {\n      getText,\n      getGroupBy,\n      getTrackBy,\n      getDisabled\n    } = useSelectableList(props);\n    const currentSelectedOptionText = computed(() => {\n      var _a;\n      const selected = (_a = props.options) == null ? void 0 : _a.find(option => props.getSelectedState(option));\n      return selected ? getText(selected) : \"\";\n    });\n    const isSearchedOptionSelected = computed(() => {\n      var _a;\n      return currentSelectedOptionText.value.toLowerCase() === ((_a = props.search) == null ? void 0 : _a.toLowerCase());\n    });\n    const filteredOptions = computed(() => {\n      if (!props.search || props.search.length < props.minSearchChars || isSearchedOptionSelected.value) {\n        return props.options;\n      }\n      return props.options.filter(option => {\n        const optionText = getText(option).toUpperCase();\n        const search = props.search.toUpperCase();\n        return optionText.includes(search);\n      });\n    });\n    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {\n      const groupBy = getGroupBy(option);\n      if (!groupBy) {\n        groups._noGroup.push(option);\n      } else {\n        if (!groups[groupBy]) {\n          groups[groupBy] = [];\n        }\n        groups[groupBy].push(option);\n      }\n      return groups;\n    }, {\n      _noGroup: []\n    }));\n    const optionGroupsThrottled = useThrottleValue(optionGroups, props);\n    const isValueExists = value => !isNilValue(value);\n    const updateHoveredOption = option => {\n      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {\n        return;\n      }\n      updateCurrentOption(option ?? null, \"mouse\");\n    };\n    const updateFocusedOption = option => {\n      updateCurrentOption(option ?? null, \"keyboard\");\n    };\n    const selectHoveredOption = () => {\n      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === \"object\" ? {\n        ...previousOptionComputed.value\n      } : previousOptionComputed.value;\n      emit(\"select-option\");\n      if (props.selectedTopShown) {\n        updateHoveredOption(previousOption);\n      }\n    };\n    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());\n    const currentOptions = computed(() => filteredOptions.value.some(el => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);\n    const currentOptionIndex = computed(() => currentOptions.value.findIndex(option => {\n      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);\n    }));\n    const selectOptionProps = computed(() => ({\n      ...pick(props, [\"getSelectedState\", \"color\", \"search\", \"highlightMatchedText\", \"minSearchChars\"]),\n      getText,\n      getTrackBy\n    }));\n    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {\n      const searchBase = [...(currentOptions.value || [])];\n      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;\n      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;\n      return searchBaseOrdered.slice(startIndex).find(option => !getDisabled(option));\n    };\n    const previousOptionComputed = computed(() => {\n      const previousOptionIndex = currentOptionIndex.value - 1;\n      const previousOption = currentOptions.value[previousOptionIndex];\n      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));\n      if (previousOptionCheck) {\n        return findNextActiveOption(currentOptionIndex.value - 1, true);\n      }\n      return void 0;\n    });\n    const selectOption = option => {\n      updateHoveredOption(option);\n      emit(\"select-option\");\n    };\n    const handleMouseMove = option => {\n      if (!props.selectedTopShown) {\n        updateHoveredOption(option);\n      }\n    };\n    const handleMouseEnter = option => {\n      if (props.selectedTopShown) {\n        updateHoveredOption(option);\n      }\n    };\n    const focusPreviousOption = () => {\n      if (!isValueExists(currentOptionComputed.value)) {\n        updateFocusedOption(findNextActiveOption(0, true));\n        return;\n      }\n      if (isValueExists(previousOptionComputed.value)) {\n        updateFocusedOption(previousOptionComputed.value);\n      } else {\n        emit(\"no-previous-option-to-hover\");\n      }\n    };\n    const focusNextOption = () => {\n      if (!isValueExists(currentOptionComputed.value)) {\n        focusFirstOption();\n        return;\n      }\n      const nextOptionIndex = currentOptionIndex.value + 1;\n      const nextOption = currentOptions.value[nextOptionIndex];\n      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));\n      if (nextOptionCheck) {\n        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));\n      }\n    };\n    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));\n    const {\n      itemRefs,\n      setItemRef\n    } = useObjectRefs();\n    const virtualScrollerRef = shallowRef();\n    const scrollToOption = option => {\n      var _a;\n      if (!isValueExists(option)) {\n        return;\n      }\n      const element = itemRefs.value[getTrackBy(option)];\n      if (element) {\n        scrollToElement(extractHTMLElement(element));\n      }\n      if (props.virtualScroller) {\n        (_a = virtualScrollerRef.value) == null ? void 0 : _a[0].virtualScrollTo(currentOptionIndex.value);\n      }\n    };\n    const publicMethods = {\n      focusPreviousOption,\n      focusNextOption,\n      focusFirstOption,\n      scrollToOption,\n      focus\n    };\n    watch(() => props.hoveredOption, newOption => {\n      (!lastInteractionSource.value || lastInteractionSource.value === \"keyboard\") && isValueExists(newOption) && scrollToOption(newOption);\n    });\n    watch(filteredOptions, () => {\n      if (!props.autoSelectFirstOption) {\n        return;\n      }\n      focusFirstOption();\n    }, {\n      immediate: true\n    });\n    return {\n      root,\n      virtualScrollerRef,\n      rootHeight,\n      optionGroups: optionGroupsThrottled,\n      filteredOptions,\n      selectOptionProps,\n      currentOptionComputed,\n      onScroll,\n      getTrackBy,\n      setItemRef,\n      getDisabled,\n      selectHoveredOption,\n      handleMouseMove,\n      handleMouseEnter,\n      updateHoveredOption,\n      handleScrollToBottom,\n      selectOption,\n      ...publicMethods\n    };\n  }\n});\nexport { _sfc_main as _ };\nimport '../../../../../VaSelectOptionList.css';","map":{"version":3,"names":["_sfc_main","defineComponent","name","components","VaVirtualScroller","VaSelectOption","emits","props","useColorProps","useComponentPresetProp","useSelectableListProps","useThrottleProps","noOptionsText","type","String","default","getSelectedState","Function","required","multiple","Boolean","search","tabindex","Number","hoveredOption","Object","virtualScroller","highlightMatchedText","minSearchChars","autoSelectFirstOption","selectedTopShown","setup","emit","root","shallowRef","focus","_a","value","preventScroll","rootHeight","computed","clientHeight","handleScrollToBottom","onScroll","event","target","scrollTop","scrollHeight","lastInteractionSource","ref","currentOptionComputed","updateCurrentOption","option","source","getText","getGroupBy","getTrackBy","getDisabled","useSelectableList","currentSelectedOptionText","selected","options","find","isSearchedOptionSelected","toLowerCase","filteredOptions","length","filter","optionText","toUpperCase","includes","optionGroups","reduce","groups","groupBy","_noGroup","push","optionGroupsThrottled","useThrottleValue","isValueExists","isNilValue","updateHoveredOption","updateFocusedOption","selectHoveredOption","previousOption","previousOptionComputed","groupedOptions","values","flat","currentOptions","some","el","currentOptionIndex","findIndex","selectOptionProps","pick","findNextActiveOption","startSearchIndex","reversedSearch","searchBase","searchBaseOrdered","reverse","startIndex","slice","previousOptionIndex","previousOptionCheck","selectOption","handleMouseMove","handleMouseEnter","focusPreviousOption","focusNextOption","focusFirstOption","nextOptionIndex","nextOption","nextOptionCheck","itemRefs","setItemRef","useObjectRefs","virtualScrollerRef","scrollToOption","element","scrollToElement","extractHTMLElement","virtualScrollTo","publicMethods","watch","newOption","immediate"],"sources":["../../../../../../../src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"root\"\n    class=\"va-select-option-list\"\n    :tabindex=\"tabindex\"\n    @keydown.up.stop.prevent=\"focusPreviousOption\"\n    @keydown.left.stop.prevent=\"focusPreviousOption\"\n    @keydown.down.stop.prevent=\"focusNextOption\"\n    @keydown.right.stop.prevent=\"focusNextOption\"\n    @keydown.enter.stop.prevent=\"selectHoveredOption\"\n    @keydown.space.stop.prevent=\"selectHoveredOption\"\n    @scroll.passive=\"onScroll\"\n  >\n    <template\n      v-for=\"(options, groupName) in optionGroups\"\n      :key=\"groupName\"\n    >\n      <span\n        v-if=\"groupName !== '_noGroup'\"\n        class=\"va-select-option-list__group-name\"\n      >\n        {{ groupName }}\n      </span>\n      <va-virtual-scroller\n        v-if=\"$props.virtualScroller\"\n        ref=\"virtualScrollerRef\"\n        :items=\"options\"\n        :track-by=\"getTrackBy\"\n        :wrapper-size=\"rootHeight\"\n        @scroll:bottom=\"handleScrollToBottom\"\n        v-slot=\"{ item: option, index }\"\n      >\n        <slot v-bind=\"{ option, index, selectOption }\">\n          <va-select-option\n            :option=\"option\"\n            :current-option=\"currentOptionComputed\"\n            :disabled=\"getDisabled(option)\"\n            v-bind=\"selectOptionProps\"\n            @click.stop=\"selectHoveredOption\"\n            @mouseenter=\"handleMouseEnter(option)\"\n            @mousemove=\"handleMouseMove(option)\"\n          />\n        </slot>\n      </va-virtual-scroller>\n\n      <template v-else>\n        <template v-for=\"(option, index) in options\" :key=\"getTrackBy(option)\">\n          <slot v-bind=\"{ option, index, selectOption }\">\n            <va-select-option\n              :ref=\"setItemRef(getTrackBy(option))\"\n              :current-option=\"currentOptionComputed\"\n              :option=\"option\"\n              :disabled=\"getDisabled(option)\"\n              v-bind=\"selectOptionProps\"\n              @click.stop=\"selectHoveredOption\"\n              @mouseenter=\"handleMouseEnter(option)\"\n              @mousemove=\"handleMouseMove(option)\"\n            />\n          </slot>\n        </template>\n      </template>\n    </template>\n    <div\n      v-if=\"!filteredOptions.length\"\n      class=\"va-select-option-list--empty\"\n    >\n      {{ noOptionsText }}\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, ref, shallowRef, watch, computed } from 'vue'\nimport pick from 'lodash/pick.js'\n\nimport {\n  useComponentPresetProp,\n  useColorProps,\n  extractHTMLElement,\n  useObjectRefs,\n  useSelectableList, useSelectableListProps,\n  useThrottleValue, useThrottleProps,\n} from '../../../../composables'\n\nimport { scrollToElement } from '../../../../utils/scroll-to-element'\n\nimport { VaVirtualScroller } from '../../../va-virtual-scroller'\nimport { VaSelectOption } from '../VaSelectOption'\n\nimport { isNilValue } from '../../../../utils/isNilValue'\n\nimport type { SelectOption, EventSource } from '../../types'\n\nexport default defineComponent({\n  name: 'VaSelectOptionList',\n  components: { VaVirtualScroller, VaSelectOption },\n  emits: [\n    'select-option',\n    'update:hoveredOption',\n    'no-previous-option-to-hover',\n    'scroll-bottom',\n  ],\n  props: {\n    ...useColorProps,\n    ...useComponentPresetProp,\n    ...useSelectableListProps,\n    ...useThrottleProps,\n    noOptionsText: { type: String, default: 'Items not found' },\n    getSelectedState: { type: Function as PropType<(option: SelectOption) => boolean>, required: true },\n    multiple: { type: Boolean, default: false },\n    search: { type: String, default: '' },\n    tabindex: { type: [String, Number], default: 0 },\n    hoveredOption: { type: [String, Number, Boolean, Object] as PropType<SelectOption | null>, default: null },\n    virtualScroller: { type: Boolean, default: true },\n    highlightMatchedText: { type: Boolean, default: true },\n    minSearchChars: { type: Number, default: 0 },\n    autoSelectFirstOption: { type: Boolean, default: false },\n    selectedTopShown: { type: Boolean, default: false },\n  },\n\n  setup (props, { emit }) {\n    const root = shallowRef<HTMLElement>()\n    const focus = () => {\n      // Prevent scroll since element in dropdown and it causes scrolling to page end.\n      root.value?.focus({ preventScroll: true })\n    }\n    const rootHeight = computed(() => root.value?.clientHeight ?? 200)\n\n    const handleScrollToBottom = () => emit('scroll-bottom')\n    const onScroll = (event: UIEvent) => {\n      const target = event.target as Element\n      if (!target) { return }\n\n      if (target.scrollTop + target.clientHeight === target.scrollHeight) {\n        handleScrollToBottom()\n      }\n    }\n\n    const lastInteractionSource = ref<EventSource>('')\n    const currentOptionComputed = computed(() => props.hoveredOption ?? null)\n    const updateCurrentOption = (option: SelectOption | null, source: EventSource) => {\n      emit('update:hoveredOption', option)\n      lastInteractionSource.value = source\n    }\n\n    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props)\n\n    const currentSelectedOptionText = computed(() => {\n      const selected = props.options?.find((option) => props.getSelectedState(option))\n\n      return selected ? getText(selected) : ''\n    })\n\n    const isSearchedOptionSelected = computed(() => {\n      return currentSelectedOptionText.value.toLowerCase() === props.search?.toLowerCase()\n    })\n\n    const filteredOptions = computed((): SelectOption[] => {\n      if (!props.search || props.search.length < props.minSearchChars || isSearchedOptionSelected.value) {\n        return props.options\n      }\n\n      return props.options.filter((option: SelectOption) => {\n        const optionText = getText(option).toUpperCase()\n        const search = props.search.toUpperCase()\n        return optionText.includes(search)\n      })\n    })\n\n    const optionGroups = computed(() => filteredOptions.value\n      .reduce((groups: Record<string, SelectOption[]>, option) => {\n        const groupBy = getGroupBy(option)\n\n        if (!groupBy) {\n          groups._noGroup.push(option)\n        } else {\n          if (!groups[groupBy]) { groups[groupBy] = [] }\n\n          groups[groupBy].push(option)\n        }\n\n        return groups\n      }, { _noGroup: [] }))\n    const optionGroupsThrottled = useThrottleValue(optionGroups, props)\n\n    const isValueExists = (value: SelectOption | null | undefined): value is SelectOption => !isNilValue(value)\n\n    const updateHoveredOption = (option?: SelectOption) => {\n      if (option === currentOptionComputed.value || (isValueExists(option) && getDisabled(option))) { return }\n\n      updateCurrentOption(option ?? null, 'mouse')\n    }\n    const updateFocusedOption = (option?: SelectOption) => { updateCurrentOption(option ?? null, 'keyboard') }\n\n    const selectHoveredOption = () => {\n      const previousOption =\n        previousOptionComputed.value && typeof previousOptionComputed.value === 'object'\n          ? { ...previousOptionComputed.value }\n          : previousOptionComputed.value\n\n      emit('select-option')\n\n      if (props.selectedTopShown) {\n        updateHoveredOption(previousOption)\n      }\n    }\n\n    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat())\n    const currentOptions = computed(() =>\n      filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value)\n\n    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {\n      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value)\n    }))\n\n    const selectOptionProps = computed(() => ({\n      ...pick(props, ['getSelectedState', 'color', 'search', 'highlightMatchedText', 'minSearchChars']),\n      getText,\n      getTrackBy,\n    }))\n\n    const findNextActiveOption = (startSearchIndex: number, reversedSearch = false) => {\n      const searchBase = [...(currentOptions.value || [])]\n      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase\n      const startIndex = reversedSearch ? (startSearchIndex * -1) - 1 : startSearchIndex\n\n      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option))\n    }\n\n    const previousOptionComputed = computed((): SelectOption | undefined => {\n      const previousOptionIndex = currentOptionIndex.value - 1\n      const previousOption = currentOptions.value[previousOptionIndex]\n      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption))\n\n      if (previousOptionCheck) {\n        return findNextActiveOption(currentOptionIndex.value - 1, true)\n      }\n\n      return undefined\n    })\n\n    const selectOption = (option: SelectOption) => {\n      updateHoveredOption(option)\n      emit('select-option')\n    }\n\n    const handleMouseMove = (option: SelectOption) => {\n      if (!props.selectedTopShown) { updateHoveredOption(option) }\n    }\n\n    const handleMouseEnter = (option: SelectOption) => {\n      if (props.selectedTopShown) { updateHoveredOption(option) }\n    }\n\n    // public\n    const focusPreviousOption = () => {\n      if (!isValueExists(currentOptionComputed.value)) {\n        updateFocusedOption(findNextActiveOption(0, true))\n        return\n      }\n\n      if (isValueExists(previousOptionComputed.value)) {\n        updateFocusedOption(previousOptionComputed.value)\n      } else {\n        emit('no-previous-option-to-hover')\n      }\n    }\n\n    const focusNextOption = () => {\n      if (!isValueExists(currentOptionComputed.value)) {\n        focusFirstOption()\n        return\n      }\n\n      const nextOptionIndex = currentOptionIndex.value + 1\n      const nextOption = currentOptions.value[nextOptionIndex]\n      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption))\n      if (nextOptionCheck) {\n        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1))\n      }\n    }\n\n    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0))\n\n    const { itemRefs, setItemRef } = useObjectRefs()\n    const virtualScrollerRef = shallowRef<Array<InstanceType<typeof VaVirtualScroller>>>()\n    const scrollToOption = (option: SelectOption) => {\n      if (!isValueExists(option)) { return }\n\n      const element = itemRefs.value[getTrackBy(option)]\n      if (element) { scrollToElement(extractHTMLElement(element)) }\n\n      if (props.virtualScroller) { virtualScrollerRef.value?.[0].virtualScrollTo(currentOptionIndex.value) }\n    }\n\n    const publicMethods = {\n      focusPreviousOption,\n      focusNextOption,\n      focusFirstOption,\n      scrollToOption,\n      focus,\n    }\n\n    watch(() => props.hoveredOption, (newOption: SelectOption | null) => {\n      (!lastInteractionSource.value || lastInteractionSource.value === 'keyboard') &&\n      (isValueExists(newOption)) && scrollToOption(newOption)\n    })\n\n    watch(filteredOptions, () => {\n      if (!props.autoSelectFirstOption) { return }\n\n      focusFirstOption()\n    }, { immediate: true })\n\n    return {\n      root,\n      virtualScrollerRef,\n\n      rootHeight,\n      optionGroups: optionGroupsThrottled,\n      filteredOptions,\n      selectOptionProps,\n      currentOptionComputed,\n\n      onScroll,\n      getTrackBy,\n      setItemRef,\n      getDisabled,\n      selectHoveredOption,\n      handleMouseMove,\n      handleMouseEnter,\n      updateHoveredOption,\n      handleScrollToBottom,\n      selectOption,\n\n      ...publicMethods,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../../../styles/resources\";\n@import \"variables\";\n\n.va-select-option-list {\n  overflow: auto;\n  width: var(--va-select-option-list-width);\n  max-height: var(--va-select-option-list-max-height);\n  display: flex;\n  flex-direction: column;\n  font-family: var(--va-font-family);\n\n  &--empty {\n    padding: var(--va-select-option-list-empty-block-padding);\n  }\n\n  @include va-scroll(var(--va-primary));\n\n  &__group-name {\n    padding: var(--va-select-option-list-group-name-padding);\n    font-size: var(--va-select-option-list-group-name-font-size);\n    color: var(--va-select-option-list-group-name-color);\n    font-weight: var(--va-select-option-list-group-name-font-weight);\n    text-transform: var(--va-select-option-list-group-name-text-transform);\n  }\n}\n</style>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}