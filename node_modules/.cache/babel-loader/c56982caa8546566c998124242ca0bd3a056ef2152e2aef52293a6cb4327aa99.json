{"ast":null,"code":"import { computed, unref, watchPostEffect } from \"vue\";\nimport { u as useDomRect } from \"./useDomRect-32e0f717.mjs\";\nimport { u as useDocument } from \"./useDocument-5c9446c6.mjs\";\nimport { u as usePlacementAliases } from \"./usePlacementAliases-c092b4d3.mjs\";\nimport { u as unwrapEl } from \"../utils/unwrapEl-55936fea.mjs\";\nimport { m as mapObject } from \"../utils/map-object-d5031296.mjs\";\nconst coordsToCss = ({\n  x,\n  y\n}) => ({\n  left: `${x}px`,\n  top: `${y}px`\n});\nconst parseOffset = offset => {\n  return Array.isArray(offset) ? {\n    main: offset[0],\n    cross: offset[1]\n  } : {\n    main: offset,\n    cross: 0\n  };\n};\nconst calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {\n  if (align === \"start\") {\n    return anchorStart;\n  }\n  if (align === \"end\") {\n    return anchorStart + anchorSize - contentSize;\n  }\n  return anchorStart + (anchorSize - contentSize) / 2;\n};\nconst calculateContentCoords = (position, align, anchor, content) => {\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);\n  switch (position) {\n    case \"top\":\n      return {\n        x: alignmentX,\n        y: anchor.top - content.height\n      };\n    case \"left\":\n      return {\n        y: alignmentY,\n        x: anchor.left - content.width\n      };\n    case \"right\":\n      return {\n        y: alignmentY,\n        x: anchor.right\n      };\n    case \"bottom\":\n    default:\n      return {\n        x: alignmentX,\n        y: anchor.bottom\n      };\n  }\n};\nconst calculateOffsetCoords = (position, offset) => {\n  const {\n    main,\n    cross\n  } = parseOffset(offset);\n  switch (position) {\n    case \"left\":\n      return {\n        y: cross,\n        x: -main\n      };\n    case \"right\":\n      return {\n        y: cross,\n        x: main\n      };\n    case \"top\":\n      return {\n        y: -main,\n        x: cross\n      };\n    case \"bottom\":\n    default:\n      return {\n        y: main,\n        x: cross\n      };\n  }\n};\nconst calculateContentOverflow = (coords, content, viewport) => {\n  const xMax = viewport.right;\n  const yMax = viewport.bottom;\n  const xMin = viewport.left;\n  const yMin = viewport.top;\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max(coords.y + content.height - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max(coords.x + content.width - xMax, 0)\n  };\n};\nconst clamp = (min, v, max) => Math.max(Math.min(v, max), min);\nconst calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = calculateContentOverflow(coords, content, viewport);\n  const x = coords.x - right + left;\n  const y = coords.y - bottom + top;\n  const {\n    x: offsetX,\n    y: offsetY\n  } = offsetCoords;\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY)\n  };\n};\nconst getAutoPlacement = (position, align, coords, content, viewport) => {\n  const overflow = calculateContentOverflow(coords, content, viewport);\n  const convertPlacement = (position2, align2) => ({\n    position: position2,\n    align: align2\n  });\n  const newPlacements = {\n    top: \"bottom\",\n    bottom: \"top\",\n    right: \"left\",\n    left: \"right\"\n  };\n  if (!overflow[position]) {\n    return convertPlacement(position, align);\n  }\n  const newPlacement = newPlacements[position];\n  if (newPlacement === \"bottom\" || newPlacement === \"top\") {\n    if (overflow.left) {\n      return convertPlacement(newPlacement, \"start\");\n    }\n    if (overflow.right) {\n      return convertPlacement(newPlacement, \"end\");\n    }\n  }\n  if (newPlacement === \"left\" || newPlacement === \"right\") {\n    if (overflow.top) {\n      return convertPlacement(newPlacement, \"start\");\n    }\n    if (overflow.bottom) {\n      return convertPlacement(newPlacement, \"end\");\n    }\n  }\n  return convertPlacement(newPlacement, \"center\");\n};\nconst findFirstRelativeParent = el => {\n  while (el) {\n    const positionValue = window.getComputedStyle(el).getPropertyValue(\"position\") || el.style.position;\n    if (positionValue === \"relative\") {\n      return el;\n    }\n    el = el.parentElement;\n  }\n  return document.body;\n};\nconst useDropdown = (anchorRef, contentRef, options, props) => {\n  const documentRef = useDocument();\n  const rootRef = computed(() => {\n    if (!documentRef.value) {\n      return void 0;\n    }\n    const {\n      root\n    } = unref(options);\n    if (root) {\n      let el;\n      if (typeof root === \"string\") {\n        el = documentRef.value.querySelector(root);\n      } else {\n        el = root;\n      }\n      if (!el) {\n        return documentRef.value.body;\n      }\n      return findFirstRelativeParent(el);\n    }\n    return documentRef.value.body;\n  });\n  const {\n    domRect: anchorDomRect\n  } = useDomRect(anchorRef);\n  const {\n    domRect: contentDomRect\n  } = useDomRect(contentRef);\n  const css = {\n    position: \"absolute\"\n  };\n  const {\n    position,\n    align\n  } = usePlacementAliases(props);\n  watchPostEffect(() => {\n    var _a;\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {\n      return;\n    }\n    const {\n      offset,\n      keepAnchorWidth,\n      autoPlacement,\n      stickToEdges\n    } = unref(options);\n    let coords = calculateContentCoords(position.value, align.value, anchorDomRect.value, contentDomRect.value);\n    let offsetCoords = {\n      x: 0,\n      y: 0\n    };\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(position.value, offset);\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key]);\n    }\n    const rootRect = rootRef.value.getBoundingClientRect();\n    const viewportRect = ((_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) ?? rootRect;\n    if (autoPlacement) {\n      const {\n        position: newPosition,\n        align: newAlign\n      } = getAutoPlacement(position.value, align.value, coords, contentDomRect.value, viewportRect);\n      if (newPosition !== position.value || newAlign !== align.value) {\n        coords = calculateContentCoords(newPosition, newAlign, anchorDomRect.value, contentDomRect.value);\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPosition, offset);\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key]);\n        }\n      }\n    }\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);\n    }\n    coords.x -= rootRect.x + rootRef.value.clientLeft;\n    coords.y -= rootRect.y + rootRef.value.clientTop;\n    if (unwrapEl(contentRef.value)) {\n      let widthCss = {};\n      if (keepAnchorWidth) {\n        const {\n          width\n        } = anchorDomRect.value;\n        widthCss = {\n          width: `${width}px`,\n          maxWidth: `${width}px`\n        };\n      }\n      Object.assign(unwrapEl(contentRef.value).style, {\n        ...css,\n        ...coordsToCss(coords),\n        ...widthCss\n      });\n    }\n  });\n  return {\n    anchorDomRect,\n    contentDomRect\n  };\n};\nexport { useDropdown as u };","map":{"version":3,"names":["coordsToCss","x","y","left","top","parseOffset","offset","Array","isArray","main","cross","calculateContentAlignment","align","anchorStart","anchorSize","contentSize","calculateContentCoords","position","anchor","content","alignmentX","width","alignmentY","height","right","bottom","calculateOffsetCoords","calculateContentOverflow","coords","viewport","xMax","yMax","xMin","yMin","Math","max","clamp","min","v","calculateClipToEdge","offsetCoords","offsetX","offsetY","getAutoPlacement","overflow","convertPlacement","position2","align2","newPlacements","newPlacement","findFirstRelativeParent","el","positionValue","window","getComputedStyle","getPropertyValue","style","parentElement","document","body","useDropdown","anchorRef","contentRef","options","props","documentRef","useDocument","rootRef","computed","value","root","unref","querySelector","domRect","anchorDomRect","useDomRect","contentDomRect","css","usePlacementAliases","watchPostEffect","keepAnchorWidth","autoPlacement","stickToEdges","mapObject","c","key","rootRect","getBoundingClientRect","viewportRect","_a","newPosition","newAlign","clientLeft","clientTop","unwrapEl","widthCss","maxWidth","Object","assign"],"sources":["../../../../src/composables/useDropdown.ts"],"sourcesContent":["import { computed, unref, watchPostEffect, type Ref } from 'vue'\n\nimport { useDomRect } from './useDomRect'\nimport { useDocument } from './useDocument'\nimport { usePlacementAliases } from './usePlacementAliases'\n\nimport { unwrapEl } from '../utils/unwrapEl'\nimport { mapObject } from '../utils/map-object'\n\nimport type {\n  PlacementAlignment,\n  PlacementPosition,\n  UsePlacementAliasesProps,\n  ParsedPlacement,\n} from './usePlacementAliases'\n\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (\n  position: PlacementPosition,\n  align: PlacementAlignment,\n  anchor: DOMRect,\n  content: DOMRect,\n) => {\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (position: PlacementPosition, offset: Offset): Coords => {\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, viewport: DOMRect) => {\n  const xMax = viewport.right\n  const yMax = viewport.bottom\n  const xMin = viewport.left\n  const yMin = viewport.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, viewport: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (\n  position: PlacementPosition,\n  align: PlacementAlignment,\n  coords: Coords,\n  content: DOMRect,\n  viewport: DOMRect,\n): ParsedPlacement => {\n  const overflow = calculateContentOverflow(coords, content, viewport)\n  const convertPlacement = (position: PlacementPosition, align: PlacementAlignment) => ({ position, align })\n\n  const newPlacements: Record<PlacementPosition, PlacementPosition> = {\n    top: 'bottom',\n    bottom: 'top',\n    right: 'left',\n    left: 'right',\n  }\n\n  if (!overflow[position]) { return convertPlacement(position, align) }\n\n  // TODO: This is not recursive, if there is overflow in left and right - still will be a problem\n  // Might need to use some different algorithm here\n  const newPlacement = newPlacements[position]\n\n  if (newPlacement === 'bottom' || newPlacement === 'top') {\n    // cross: →\n    if (overflow.left) { return convertPlacement(newPlacement, 'start') }\n    if (overflow.right) { return convertPlacement(newPlacement, 'end') }\n  }\n\n  if (newPlacement === 'left' || newPlacement === 'right') {\n    // cross: ↓\n    if (overflow.top) { return convertPlacement(newPlacement, 'start') }\n    if (overflow.bottom) { return convertPlacement(newPlacement, 'end') }\n  }\n\n  return convertPlacement(newPlacement, 'center')\n}\n\nconst findFirstRelativeParent = (el: Element | null) => {\n  while (el) {\n    // TODO: Remove the el.style.position after fix of this issue: https://github.com/nuxt/framework/issues/3587\n    // TODO: Remove from the va-dropdown.vue the inline style (position: relative)\n    const positionValue = window.getComputedStyle(el).getPropertyValue('position') ||\n      (el as HTMLElement).style.position\n\n    if (positionValue === 'relative') { return el }\n\n    el = el.parentElement\n  }\n\n  return document.body\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string | HTMLElement,\n  viewport?: HTMLElement,\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param anchorRef\n * @param contentRef\n * @param options make options reactive if you want popover to react on options change.\n * @param props\n */\nexport const useDropdown = (\n  anchorRef: Ref<HTMLElement | undefined>,\n  contentRef: Ref<HTMLElement | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n  props: UsePlacementAliasesProps,\n) => {\n  const documentRef = useDocument()\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) {\n      let el\n      if (typeof root === 'string') {\n        el = documentRef.value.querySelector(root)\n      } else {\n        el = root\n      }\n      if (!el) { return documentRef.value.body }\n      return findFirstRelativeParent(el)\n    }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const css = {\n    position: 'absolute',\n  }\n\n  const { position, align } = usePlacementAliases(props)\n  watchPostEffect(() => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    const { offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(position.value, align.value, anchorDomRect.value, contentDomRect.value)\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(position.value, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n    const viewportRect = unref(options).viewport?.getBoundingClientRect() ?? rootRect\n\n    if (autoPlacement) {\n      const { position: newPosition, align: newAlign } = getAutoPlacement(position.value, align.value, coords, contentDomRect.value, viewportRect)\n\n      if (newPosition !== position.value || newAlign !== align.value) {\n        coords = calculateContentCoords(newPosition, newAlign, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPosition, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect)\n    }\n\n    coords.x -= rootRect.x + rootRef.value.clientLeft\n    coords.y -= rootRect.y + rootRef.value.clientTop\n\n    if (unwrapEl(contentRef.value)) {\n      let widthCss = {}\n      if (keepAnchorWidth) {\n        const { width } = anchorDomRect.value\n        widthCss = { width: `${width}px`, maxWidth: `${width}px` }\n      }\n\n      Object.assign(unwrapEl(contentRef.value)!.style, {\n        ...css,\n        ...coordsToCss(coords),\n        ...widthCss,\n      })\n    }\n  })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n"],"mappings":";;;;;;AAqBA,MAAMA,WAAA,GAAcA,CAAC;EAAEC,CAAA;EAAGC;AAAE,OAAe;EAAEC,IAAA,EAAM,GAAGF,CAAA;EAAOG,GAAA,EAAK,GAAGF,CAAA;AAAM;AAE3E,MAAMG,WAAA,GAAeC,MAAA,IAAgC;EACnD,OAAOC,KAAA,CAAMC,OAAA,CAAQF,MAAM,IAAI;IAAEG,IAAA,EAAMH,MAAA,CAAO,CAAC;IAAGI,KAAA,EAAOJ,MAAA,CAAO,CAAC;EAAA,IAAM;IAAEG,IAAA,EAAMH,MAAA;IAAQI,KAAA,EAAO;EAAA;AAChG;AAEA,MAAMC,yBAAA,GAA4BA,CAACC,KAAA,EAA2BC,WAAA,EAAqBC,UAAA,EAAoBC,WAAA,KAAwB;EAC7H,IAAIH,KAAA,KAAU,SAAS;IAAS,OAAAC,WAAA;EAAY;EAC5C,IAAID,KAAA,KAAU,OAAO;IAAE,OAAOC,WAAA,GAAcC,UAAA,GAAaC,WAAA;EAAY;EAE9D,OAAAF,WAAA,IAAeC,UAAA,GAAaC,WAAA,IAAe;AACpD;AAEA,MAAMC,sBAAA,GAAyBA,CAC7BC,QAAA,EACAL,KAAA,EACAM,MAAA,EACAC,OAAA,KACG;EACG,MAAAC,UAAA,GAAaT,yBAAA,CAA0BC,KAAA,EAAOM,MAAA,CAAOf,IAAA,EAAMe,MAAA,CAAOG,KAAA,EAAOF,OAAA,CAAQE,KAAK;EACtF,MAAAC,UAAA,GAAaX,yBAAA,CAA0BC,KAAA,EAAOM,MAAA,CAAOd,GAAA,EAAKc,MAAA,CAAOK,MAAA,EAAQJ,OAAA,CAAQI,MAAM;EAE7F,QAAQN,QAAA;IACN,KAAK;MAAO,OAAO;QAAEhB,CAAA,EAAGmB,UAAA;QAAYlB,CAAA,EAAGgB,MAAA,CAAOd,GAAA,GAAMe,OAAA,CAAQI;MAAA;IAC5D,KAAK;MAAQ,OAAO;QAAErB,CAAA,EAAGoB,UAAA;QAAYrB,CAAA,EAAGiB,MAAA,CAAOf,IAAA,GAAOgB,OAAA,CAAQE;MAAA;IAC9D,KAAK;MAAS,OAAO;QAAEnB,CAAA,EAAGoB,UAAA;QAAYrB,CAAA,EAAGiB,MAAA,CAAOM;MAAM;IACtD,KAAK;IACL;MAAS,OAAO;QAAEvB,CAAA,EAAGmB,UAAA;QAAYlB,CAAA,EAAGgB,MAAA,CAAOO;MAAO;EACpD;AACF;AAEA,MAAMC,qBAAA,GAAwBA,CAACT,QAAA,EAA6BX,MAAA,KAA2B;EACrF,MAAM;IAAEG,IAAA;IAAMC;EAAM,IAAIL,WAAA,CAAYC,MAAM;EAE1C,QAAQW,QAAA;IACN,KAAK;MAAQ,OAAO;QAAEf,CAAA,EAAGQ,KAAA;QAAOT,CAAA,EAAG,CAACQ;MAAK;IACzC,KAAK;MAAS,OAAO;QAAEP,CAAA,EAAGQ,KAAA;QAAOT,CAAA,EAAGQ;MAAK;IACzC,KAAK;MAAO,OAAO;QAAEP,CAAA,EAAG,CAACO,IAAA;QAAMR,CAAA,EAAGS;MAAM;IACxC,KAAK;IACL;MAAS,OAAO;QAAER,CAAA,EAAGO,IAAA;QAAMR,CAAA,EAAGS;MAAM;EACtC;AACF;AAGA,MAAMiB,wBAAA,GAA2BA,CAACC,MAAA,EAAgBT,OAAA,EAAkBU,QAAA,KAAsB;EACxF,MAAMC,IAAA,GAAOD,QAAA,CAASL,KAAA;EACtB,MAAMO,IAAA,GAAOF,QAAA,CAASJ,MAAA;EACtB,MAAMO,IAAA,GAAOH,QAAA,CAAS1B,IAAA;EACtB,MAAM8B,IAAA,GAAOJ,QAAA,CAASzB,GAAA;EAEf;IACLA,GAAA,EAAK8B,IAAA,CAAKC,GAAA,CAAIF,IAAA,GAAOL,MAAA,CAAO1B,CAAA,EAAG,CAAC;IAChCuB,MAAA,EAAQS,IAAA,CAAKC,GAAA,CAAKP,MAAA,CAAO1B,CAAA,GAAIiB,OAAA,CAAQI,MAAA,GAAUQ,IAAA,EAAM,CAAC;IACtD5B,IAAA,EAAM+B,IAAA,CAAKC,GAAA,CAAIH,IAAA,GAAOJ,MAAA,CAAO3B,CAAA,EAAG,CAAC;IACjCuB,KAAA,EAAOU,IAAA,CAAKC,GAAA,CAAKP,MAAA,CAAO3B,CAAA,GAAIkB,OAAA,CAAQE,KAAA,GAASS,IAAA,EAAM,CAAC;EAAA;AAExD;AAEA,MAAMM,KAAA,GAAQA,CAACC,GAAA,EAAaC,CAAA,EAAWH,GAAA,KAAgBD,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAKG,GAAA,CAAIC,CAAA,EAAGH,GAAG,GAAGE,GAAG;AAErF,MAAME,mBAAA,GAAsBA,CAACX,MAAA,EAAgBY,YAAA,EAAsBrB,OAAA,EAAkBD,MAAA,EAAiBW,QAAA,KAAsB;EACpH;IAAEzB,GAAA;IAAKqB,MAAA;IAAQtB,IAAA;IAAMqB;EAAA,IAAUG,wBAAA,CAAyBC,MAAA,EAAQT,OAAA,EAASU,QAAQ;EAGjF,MAAA5B,CAAA,GAAI2B,MAAA,CAAO3B,CAAA,GAAIuB,KAAA,GAAQrB,IAAA;EACvB,MAAAD,CAAA,GAAI0B,MAAA,CAAO1B,CAAA,GAAIuB,MAAA,GAASrB,GAAA;EAE9B,MAAM;IAAEH,CAAA,EAAGwC,OAAA;IAASvC,CAAA,EAAGwC;EAAA,IAAYF,YAAA;EAE5B;IAAA;IAELvC,CAAA,EAAGmC,KAAA,CAAMlB,MAAA,CAAOf,IAAA,GAAOsC,OAAA,GAAUtB,OAAA,CAAQE,KAAA,EAAOpB,CAAA,EAAGiB,MAAA,CAAOM,KAAA,GAAQiB,OAAO;IACzEvC,CAAA,EAAGkC,KAAA,CAAMlB,MAAA,CAAOd,GAAA,GAAMsC,OAAA,GAAUvB,OAAA,CAAQI,MAAA,EAAQrB,CAAA,EAAGgB,MAAA,CAAOO,MAAA,GAASiB,OAAO;EAAA;AAE9E;AAEA,MAAMC,gBAAA,GAAmBA,CACvB1B,QAAA,EACAL,KAAA,EACAgB,MAAA,EACAT,OAAA,EACAU,QAAA,KACoB;EACpB,MAAMe,QAAA,GAAWjB,wBAAA,CAAyBC,MAAA,EAAQT,OAAA,EAASU,QAAQ;EAC7D,MAAAgB,gBAAA,GAAmBA,CAACC,SAAA,EAA6BC,MAAA,MAA+B;IAAE9B,QAAA,EAAA6B,SAAA;IAAUlC,KAAA,EAAAmC;EAAM;EAExG,MAAMC,aAAA,GAA8D;IAClE5C,GAAA,EAAK;IACLqB,MAAA,EAAQ;IACRD,KAAA,EAAO;IACPrB,IAAA,EAAM;EAAA;EAGJ,KAACyC,QAAA,CAAS3B,QAAQ,GAAG;IAAS,OAAA4B,gBAAA,CAAiB5B,QAAA,EAAUL,KAAK;EAAE;EAI9D,MAAAqC,YAAA,GAAeD,aAAA,CAAc/B,QAAQ;EAEvC,IAAAgC,YAAA,KAAiB,YAAYA,YAAA,KAAiB,OAAO;IAEvD,IAAIL,QAAA,CAASzC,IAAA,EAAM;MAAS,OAAA0C,gBAAA,CAAiBI,YAAA,EAAc,OAAO;IAAE;IACpE,IAAIL,QAAA,CAASpB,KAAA,EAAO;MAAS,OAAAqB,gBAAA,CAAiBI,YAAA,EAAc,KAAK;IAAE;EACrE;EAEI,IAAAA,YAAA,KAAiB,UAAUA,YAAA,KAAiB,SAAS;IAEvD,IAAIL,QAAA,CAASxC,GAAA,EAAK;MAAS,OAAAyC,gBAAA,CAAiBI,YAAA,EAAc,OAAO;IAAE;IACnE,IAAIL,QAAA,CAASnB,MAAA,EAAQ;MAAS,OAAAoB,gBAAA,CAAiBI,YAAA,EAAc,KAAK;IAAE;EACtE;EAEO,OAAAJ,gBAAA,CAAiBI,YAAA,EAAc,QAAQ;AAChD;AAEA,MAAMC,uBAAA,GAA2BC,EAAA,IAAuB;EACtD,OAAOA,EAAA,EAAI;IAGH,MAAAC,aAAA,GAAgBC,MAAA,CAAOC,gBAAA,CAAiBH,EAAE,EAAEI,gBAAA,CAAiB,UAAU,KAC1EJ,EAAA,CAAmBK,KAAA,CAAMvC,QAAA;IAE5B,IAAImC,aAAA,KAAkB,YAAY;MAAS,OAAAD,EAAA;IAAG;IAE9CA,EAAA,GAAKA,EAAA,CAAGM,aAAA;EACV;EAEA,OAAOC,QAAA,CAASC,IAAA;AAClB;AAmBO,MAAMC,WAAA,GAAcA,CACzBC,SAAA,EACAC,UAAA,EACAC,OAAA,EACAC,KAAA,KACG;EACH,MAAMC,WAAA,GAAcC,WAAA;EACd,MAAAC,OAAA,GAAUC,QAAA,CAAS,MAAM;IACzB,KAACH,WAAA,CAAYI,KAAA,EAAO;MAAS;IAAU;IAE3C,MAAM;MAAEC;IAAA,IAASC,KAAA,CAAMR,OAAO;IAE9B,IAAIO,IAAA,EAAM;MACJ,IAAAnB,EAAA;MACA,WAAOmB,IAAA,KAAS,UAAU;QACvBnB,EAAA,GAAAc,WAAA,CAAYI,KAAA,CAAMG,aAAA,CAAcF,IAAI;MAAA,OACpC;QACAnB,EAAA,GAAAmB,IAAA;MACP;MACA,IAAI,CAACnB,EAAA,EAAI;QAAE,OAAOc,WAAA,CAAYI,KAAA,CAAMV,IAAA;MAAK;MACzC,OAAOT,uBAAA,CAAwBC,EAAE;IACnC;IAEA,OAAOc,WAAA,CAAYI,KAAA,CAAMV,IAAA;EAAA,CAC1B;EACD,MAAM;IAAEc,OAAA,EAASC;EAAc,IAAIC,UAAA,CAAWd,SAAS;EACvD,MAAM;IAAEY,OAAA,EAASG;EAAe,IAAID,UAAA,CAAWb,UAAU;EAEzD,MAAMe,GAAA,GAAM;IACV5D,QAAA,EAAU;EAAA;EAGZ,MAAM;IAAEA,QAAA;IAAUL;EAAM,IAAIkE,mBAAA,CAAoBd,KAAK;EACrDe,eAAA,CAAgB,MAAM;;IAChB,KAACZ,OAAA,CAAQE,KAAA,IAAS,CAACK,aAAA,CAAcL,KAAA,IAAS,CAACO,cAAA,CAAeP,KAAA,EAAO;MAAE;IAAO;IAE9E,MAAM;MAAE/D,MAAA;MAAQ0E,eAAA;MAAiBC,aAAA;MAAeC;IAAA,IAAiBX,KAAA,CAAMR,OAAO;IAG1E,IAAAnC,MAAA,GAASZ,sBAAA,CAAuBC,QAAA,CAASoD,KAAA,EAAOzD,KAAA,CAAMyD,KAAA,EAAOK,aAAA,CAAcL,KAAA,EAAOO,cAAA,CAAeP,KAAK;IAE1G,IAAI7B,YAAA,GAAuB;MAAEvC,CAAA,EAAG;MAAGC,CAAA,EAAG;IAAE;IACxC,IAAII,MAAA,EAAQ;MACKkC,YAAA,GAAAd,qBAAA,CAAsBT,QAAA,CAASoD,KAAA,EAAO/D,MAAM;MAClDsB,MAAA,GAAAuD,SAAA,CAAUvD,MAAA,EAAQ,CAACwD,CAAA,EAAGC,GAAA,KAAQD,CAAA,GAAI5C,YAAA,CAAa6C,GAAG,CAAC;IAC9D;IAEM,MAAAC,QAAA,GAAWnB,OAAA,CAAQE,KAAA,CAAMkB,qBAAA,CAAsB;IACrD,MAAMC,YAAA,KAAeC,EAAA,GAAAlB,KAAA,CAAMR,OAAO,EAAElC,QAAA,KAAf,gBAAA4D,EAAA,CAAyBF,qBAAA,OAA2BD,QAAA;IAEzE,IAAIL,aAAA,EAAe;MACjB,MAAM;QAAEhE,QAAA,EAAUyE,WAAA;QAAa9E,KAAA,EAAO+E;MAAA,IAAahD,gBAAA,CAAiB1B,QAAA,CAASoD,KAAA,EAAOzD,KAAA,CAAMyD,KAAA,EAAOzC,MAAA,EAAQgD,cAAA,CAAeP,KAAA,EAAOmB,YAAY;MAE3I,IAAIE,WAAA,KAAgBzE,QAAA,CAASoD,KAAA,IAASsB,QAAA,KAAa/E,KAAA,CAAMyD,KAAA,EAAO;QAC9DzC,MAAA,GAASZ,sBAAA,CAAuB0E,WAAA,EAAaC,QAAA,EAAUjB,aAAA,CAAcL,KAAA,EAAOO,cAAA,CAAeP,KAAK;QAEhG,IAAI/D,MAAA,EAAQ;UACKkC,YAAA,GAAAd,qBAAA,CAAsBgE,WAAA,EAAapF,MAAM;UAC/CsB,MAAA,GAAAuD,SAAA,CAAUvD,MAAA,EAAQ,CAACwD,CAAA,EAAGC,GAAA,KAAQD,CAAA,GAAI5C,YAAA,CAAa6C,GAAG,CAAC;QAC9D;MACF;IACF;IAEA,IAAIH,YAAA,EAAc;MAChBtD,MAAA,GAASW,mBAAA,CAAoBX,MAAA,EAAQY,YAAA,EAAcoC,cAAA,CAAeP,KAAA,EAAOK,aAAA,CAAcL,KAAA,EAAOmB,YAAY;IAC5G;IAEA5D,MAAA,CAAO3B,CAAA,IAAKqF,QAAA,CAASrF,CAAA,GAAIkE,OAAA,CAAQE,KAAA,CAAMuB,UAAA;IACvChE,MAAA,CAAO1B,CAAA,IAAKoF,QAAA,CAASpF,CAAA,GAAIiE,OAAA,CAAQE,KAAA,CAAMwB,SAAA;IAEnC,IAAAC,QAAA,CAAShC,UAAA,CAAWO,KAAK,GAAG;MAC9B,IAAI0B,QAAA,GAAW;MACf,IAAIf,eAAA,EAAiB;QACb;UAAE3D;QAAM,IAAIqD,aAAA,CAAcL,KAAA;QAChC0B,QAAA,GAAW;UAAE1E,KAAA,EAAO,GAAGA,KAAA;UAAW2E,QAAA,EAAU,GAAG3E,KAAA;QAAU;MAC3D;MAEA4E,MAAA,CAAOC,MAAA,CAAOJ,QAAA,CAAShC,UAAA,CAAWO,KAAK,EAAGb,KAAA,EAAO;QAC/C,GAAGqB,GAAA;QACH,GAAG7E,WAAA,CAAY4B,MAAM;QACrB,GAAGmE;MAAA,CACJ;IACH;EAAA,CACD;EAEM;IACLrB,aAAA;IACAE;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}