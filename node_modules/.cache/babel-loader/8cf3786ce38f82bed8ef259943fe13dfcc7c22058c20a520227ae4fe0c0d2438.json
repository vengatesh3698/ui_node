{"ast":null,"code":"import { shallowRef, computed, unref } from \"vue\";\nconst unrefElement = el => {\n  const e = unref(el);\n  return (e == null ? void 0 : e.$el) ?? e;\n};\nconst useElementRef = () => {\n  const el = shallowRef();\n  return computed({\n    get() {\n      return unrefElement(el);\n    },\n    set(node) {\n      el.value = node;\n    }\n  });\n};\nexport { useElementRef as u };","map":{"version":3,"names":["unrefElement","el","e","unref","$el","useElementRef","shallowRef","computed","get","set","node","value"],"sources":["../../../../src/composables/useElementRef.ts"],"sourcesContent":["import { ComponentPublicInstance, computed, shallowRef, unref, Ref } from 'vue'\n\ntype Maybe<T> = T | undefined\nexport type MaybeElement<T extends Maybe<HTMLElement>> = T | ComponentPublicInstance\n\nconst unrefElement = <T extends Maybe<HTMLElement>>(el: Ref<MaybeElement<T>>): T => {\n  const e = unref(el)\n  return (e as ComponentPublicInstance)?.$el ?? e\n}\n\nexport const useElementRef = <T extends Maybe<HTMLElement>>() => {\n  const el = shallowRef<MaybeElement<T>>()\n\n  return computed({\n    get () {\n      return unrefElement(el) as T\n    },\n    set (node: MaybeElement<T>) {\n      el.value = node\n    },\n  }) as Ref<T>\n}\n"],"mappings":";AAKA,MAAMA,YAAA,GAA8CC,EAAA,IAAgC;EAC5E,MAAAC,CAAA,GAAIC,KAAA,CAAMF,EAAE;EAClB,QAAQC,CAAA,oBAAAA,CAAA,CAA+BE,GAAA,KAAOF,CAAA;AAChD;AAEO,MAAMG,aAAA,GAAgBA,CAAA,KAAoC;EAC/D,MAAMJ,EAAA,GAAKK,UAAA;EAEX,OAAOC,QAAA,CAAS;IACdC,IAAA,EAAO;MACL,OAAOR,YAAA,CAAaC,EAAE;IACxB;IACAQ,IAAKC,IAAA,EAAuB;MAC1BT,EAAA,CAAGU,KAAA,GAAQD,IAAA;IACb;EAAA,CACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}