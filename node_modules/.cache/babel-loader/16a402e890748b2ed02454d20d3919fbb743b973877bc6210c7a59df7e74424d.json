{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getCurrentInstance, computed } from \"vue\";\nimport { u as useElementRef } from \"../../../composables/useElementRef-6a3a78f2.mjs\";\nimport { u as useIntersectionObserver } from \"../../../composables/useIntersectionObserver-4f12fe5b.mjs\";\nconst useTableScrollProps = {\n  scrollTopMargin: {\n    type: Number,\n    default: 0\n  },\n  scrollBottomMargin: {\n    type: Number,\n    default: 0\n  }\n};\nconst useTableScrollEmits = [\"scroll:top\", \"scroll:bottom\"];\nconst useTableScroll = (props, emit) => {\n  var _a;\n  const vNodeProps = (_a = getCurrentInstance()) == null ? void 0 : _a.vnode.props;\n  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps[\"onScroll:top\"]) !== void 0;\n  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps[\"onScroll:bottom\"]) !== void 0;\n  const scrollContainer = useElementRef();\n  const topTrigger = useElementRef();\n  const bottomTrigger = useElementRef();\n  const isObservable = computed(() => !!scrollContainer.value);\n  const intersectionHandler = entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        entry.target === topTrigger.value ? emit(\"scroll:top\") : emit(\"scroll:bottom\");\n      }\n    });\n  };\n  const targets = computed(() => {\n    const list = [];\n    if (isObservable.value) {\n      topTrigger.value && list.push(topTrigger.value);\n      bottomTrigger.value && list.push(bottomTrigger.value);\n    }\n    return list;\n  });\n  const options = computed(() => ({\n    root: scrollContainer.value,\n    rootMargin: `${props.scrollTopMargin ?? 0}px 0px ${props.scrollBottomMargin ?? 0}px 0px`\n  }));\n  useIntersectionObserver(intersectionHandler, options, targets);\n  return {\n    scrollContainer,\n    topTrigger,\n    bottomTrigger,\n    doRenderTopTrigger,\n    doRenderBottomTrigger\n  };\n};\nexport { useTableScrollEmits as a, useTableScroll as b, useTableScrollProps as u };","map":{"version":3,"names":["useTableScrollProps","scrollTopMargin","type","Number","default","scrollBottomMargin","useTableScrollEmits","useTableScroll","props","emit","vNodeProps","_a","getCurrentInstance","vnode","doRenderTopTrigger","doRenderBottomTrigger","scrollContainer","useElementRef","topTrigger","bottomTrigger","isObservable","computed","value","intersectionHandler","entries","forEach","entry","isIntersecting","target","targets","list","push","options","root","rootMargin","useIntersectionObserver"],"sources":["../../../../../../src/components/va-data-table/hooks/useTableScroll.ts"],"sourcesContent":["import { getCurrentInstance, computed, ExtractPropTypes } from 'vue'\n\nimport { useIntersectionObserver, useElementRef } from '../../../composables'\n\nexport const useTableScrollProps = {\n  scrollTopMargin: { type: Number, default: 0 },\n  scrollBottomMargin: { type: Number, default: 0 },\n}\n\nexport const useTableScrollEmits = ['scroll:top', 'scroll:bottom']\n\nexport const useTableScroll = (\n  props: ExtractPropTypes<typeof useTableScrollProps>,\n  emit: (event: 'scroll:bottom' | 'scroll:top', ...args: any[]) => void,\n) => {\n  // NOTE: unfortunately, this is not reactive\n  // TODO: replace 'vNodeProps' with '$listeners' when it's available in vue 3\n  const vNodeProps = getCurrentInstance()?.vnode.props\n  const doRenderTopTrigger = vNodeProps?.['onScroll:top'] !== undefined\n  const doRenderBottomTrigger = vNodeProps?.['onScroll:bottom'] !== undefined\n\n  const scrollContainer = useElementRef()\n  const topTrigger = useElementRef()\n  const bottomTrigger = useElementRef()\n\n  const isObservable = computed(() => !!scrollContainer.value)\n\n  const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        entry.target === topTrigger.value\n          ? emit('scroll:top')\n          : emit('scroll:bottom')\n      }\n    })\n  }\n\n  const targets = computed<HTMLElement[]>(() => {\n    const list: HTMLElement[] = []\n\n    if (isObservable.value) {\n      topTrigger.value && list.push(topTrigger.value)\n      bottomTrigger.value && list.push(bottomTrigger.value)\n    }\n\n    return list\n  })\n\n  const options = computed<IntersectionObserverInit>(() => ({\n    root: scrollContainer.value,\n    rootMargin: `${props.scrollTopMargin ?? 0}px 0px ${props.scrollBottomMargin ?? 0}px 0px`,\n  }))\n\n  useIntersectionObserver(intersectionHandler, options, targets)\n\n  return {\n    scrollContainer,\n    topTrigger,\n    bottomTrigger,\n    doRenderTopTrigger,\n    doRenderBottomTrigger,\n  }\n}\n"],"mappings":";;;;AAIO,MAAMA,mBAAA,GAAsB;EACjCC,eAAA,EAAiB;IAAEC,IAAA,EAAMC,MAAA;IAAQC,OAAA,EAAS;EAAE;EAC5CC,kBAAA,EAAoB;IAAEH,IAAA,EAAMC,MAAA;IAAQC,OAAA,EAAS;EAAE;AACjD;AAEa,MAAAE,mBAAA,GAAsB,CAAC,cAAc,eAAe;AAEpD,MAAAC,cAAA,GAAiBA,CAC5BC,KAAA,EACAC,IAAA,KACG;;EAGG,MAAAC,UAAA,IAAaC,EAAA,GAAAC,kBAAA,uBAAAD,EAAA,CAAsBE,KAAA,CAAML,KAAA;EACzC,MAAAM,kBAAA,IAAqBJ,UAAA,oBAAAA,UAAA,CAAa,qBAAoB;EACtD,MAAAK,qBAAA,IAAwBL,UAAA,oBAAAA,UAAA,CAAa,wBAAuB;EAElE,MAAMM,eAAA,GAAkBC,aAAA;EACxB,MAAMC,UAAA,GAAaD,aAAA;EACnB,MAAME,aAAA,GAAgBF,aAAA;EAEtB,MAAMG,YAAA,GAAeC,QAAA,CAAS,MAAM,CAAC,CAACL,eAAA,CAAgBM,KAAK;EAErD,MAAAC,mBAAA,GAAuBC,OAAA,IAAyC;IAC5DA,OAAA,CAAAC,OAAA,CAASC,KAAA,IAAU;MACzB,IAAIA,KAAA,CAAMC,cAAA,EAAgB;QACxBD,KAAA,CAAME,MAAA,KAAWV,UAAA,CAAWI,KAAA,GACxBb,IAAA,CAAK,YAAY,IACjBA,IAAA,CAAK,eAAe;MAC1B;IAAA,CACD;EAAA;EAGG,MAAAoB,OAAA,GAAUR,QAAA,CAAwB,MAAM;IAC5C,MAAMS,IAAA,GAAsB;IAE5B,IAAIV,YAAA,CAAaE,KAAA,EAAO;MACtBJ,UAAA,CAAWI,KAAA,IAASQ,IAAA,CAAKC,IAAA,CAAKb,UAAA,CAAWI,KAAK;MAC9CH,aAAA,CAAcG,KAAA,IAASQ,IAAA,CAAKC,IAAA,CAAKZ,aAAA,CAAcG,KAAK;IACtD;IAEO,OAAAQ,IAAA;EAAA,CACR;EAEK,MAAAE,OAAA,GAAUX,QAAA,CAAmC,OAAO;IACxDY,IAAA,EAAMjB,eAAA,CAAgBM,KAAA;IACtBY,UAAA,EAAY,GAAG1B,KAAA,CAAMP,eAAA,IAAmB,WAAWO,KAAA,CAAMH,kBAAA,IAAsB;EAC/E;EAEsB8B,uBAAA,CAAAZ,mBAAA,EAAqBS,OAAA,EAASH,OAAO;EAEtD;IACLb,eAAA;IACAE,UAAA;IACAC,aAAA;IACAL,kBAAA;IACAC;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}