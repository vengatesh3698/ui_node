{"ast":null,"code":"import { computed, unref, isRef, reactive } from \"vue\";\nconst useReactiveComputed = obj => {\n  const objectRef = typeof obj === \"function\" ? computed(obj) : computed(obj);\n  const proxy = new Proxy(objectRef, {\n    get(target, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(target, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value)) {\n        objectRef.value[p].value = value;\n      } else {\n        objectRef.value[p] = value;\n      }\n      return true;\n    },\n    deleteProperty(target, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(target, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n};\nexport { useReactiveComputed as u };","map":{"version":3,"names":["useReactiveComputed","obj","objectRef","computed","proxy","Proxy","get","target","p","receiver","unref","Reflect","value","set","isRef","deleteProperty","has","ownKeys","Object","keys","getOwnPropertyDescriptor","enumerable","configurable","reactive"],"sources":["../../../../src/composables/useReactiveComputed.ts"],"sourcesContent":["import { computed, unref, WritableComputedOptions, ComputedGetter, isRef, reactive } from 'vue'\n\nexport const useReactiveComputed = <T extends object>(obj: WritableComputedOptions<T> | ComputedGetter<T>) => {\n  const objectRef = typeof obj === 'function' ? computed(obj as ComputedGetter<T>) : computed(obj as WritableComputedOptions<T>)\n\n  const proxy = new Proxy(objectRef, {\n    get (target, p: string, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver))\n    },\n    set (target, p, value) {\n      if (isRef((objectRef.value as any)[p]) && !isRef(value)) {\n        (objectRef.value as any)[p].value = value\n      } else {\n        (objectRef.value as any)[p] = value\n      }\n      return true\n    },\n    deleteProperty (target, p) {\n      return Reflect.deleteProperty(objectRef.value, p)\n    },\n    has (target, p) {\n      return Reflect.has(objectRef.value, p)\n    },\n    ownKeys () {\n      return Object.keys(objectRef.value)\n    },\n    getOwnPropertyDescriptor () {\n      return {\n        enumerable: true,\n        configurable: true,\n      }\n    },\n  })\n\n  return reactive(proxy) as T\n}\n"],"mappings":";AAEa,MAAAA,mBAAA,GAAyCC,GAAA,IAAwD;EACtG,MAAAC,SAAA,GAAY,OAAOD,GAAA,KAAQ,aAAaE,QAAA,CAASF,GAAwB,IAAIE,QAAA,CAASF,GAAiC;EAEvH,MAAAG,KAAA,GAAQ,IAAIC,KAAA,CAAMH,SAAA,EAAW;IACjCI,IAAKC,MAAA,EAAQC,CAAA,EAAWC,QAAA,EAAU;MAChC,OAAOC,KAAA,CAAMC,OAAA,CAAQL,GAAA,CAAIJ,SAAA,CAAUU,KAAA,EAAOJ,CAAA,EAAGC,QAAQ,CAAC;IACxD;IACAI,IAAKN,MAAA,EAAQC,CAAA,EAAGI,KAAA,EAAO;MACjB,IAAAE,KAAA,CAAOZ,SAAA,CAAUU,KAAA,CAAcJ,CAAC,CAAC,KAAK,CAACM,KAAA,CAAMF,KAAK,GAAG;QACtDV,SAAA,CAAUU,KAAA,CAAcJ,CAAC,EAAEI,KAAA,GAAQA,KAAA;MAAA,OAC/B;QACJV,SAAA,CAAUU,KAAA,CAAcJ,CAAC,IAAII,KAAA;MAChC;MACO;IACT;IACAG,eAAgBR,MAAA,EAAQC,CAAA,EAAG;MACzB,OAAOG,OAAA,CAAQI,cAAA,CAAeb,SAAA,CAAUU,KAAA,EAAOJ,CAAC;IAClD;IACAQ,IAAKT,MAAA,EAAQC,CAAA,EAAG;MACd,OAAOG,OAAA,CAAQK,GAAA,CAAId,SAAA,CAAUU,KAAA,EAAOJ,CAAC;IACvC;IACAS,QAAA,EAAW;MACF,OAAAC,MAAA,CAAOC,IAAA,CAAKjB,SAAA,CAAUU,KAAK;IACpC;IACAQ,yBAAA,EAA4B;MACnB;QACLC,UAAA,EAAY;QACZC,YAAA,EAAc;MAAA;IAElB;EAAA,CACD;EAED,OAAOC,QAAA,CAASnB,KAAK;AACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}