{"ast":null,"code":"import { Comment, Text, h, Suspense, Teleport, Fragment } from \"vue\";\nconst toNode = (v, attrs) => {\n  if (!v) {\n    return null;\n  }\n  if (!(\"type\" in v) || v.type === Text || typeof v === \"string\") {\n    return h(\"div\", attrs, v);\n  }\n  if (v.type === Comment) {\n    return v;\n  }\n  if (\"$el\" in v) {\n    return toNode(v.$el, attrs);\n  }\n  if (v.type === Suspense) {\n    return h(v.ssContent, attrs);\n  }\n  if (v.type === Teleport) {\n    if (v.children === null) {\n      return v;\n    }\n    const anchor = toNode(v.children[0], attrs);\n    if (anchor) {\n      v.children[0] = h(anchor, attrs);\n    }\n    return v;\n  }\n  if (v.type === Fragment) {\n    if (v.children === null) {\n      return v;\n    }\n    return h(Fragment, v.props, v.children.map(v2 => toNode(v2, attrs)));\n  }\n  return h(v, attrs);\n};\nconst renderSlotNode = (slot, slotBind = {}, nodeAttributes = {}) => {\n  const children = slot == null ? void 0 : slot(slotBind);\n  if (!children) {\n    return null;\n  }\n  return toNode(children.find(v => v.type !== Comment) || children[0], nodeAttributes);\n};\nconst renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {\n  const children = slot == null ? void 0 : slot(slotBind);\n  if (!children) {\n    return null;\n  }\n  return children.map(v => toNode(v, nodeAttributes));\n};\nexport { renderSlotNode as a, renderSlotNodes as r };","map":{"version":3,"names":["toNode","v","attrs","type","Text","h","Comment","$el","Suspense","ssContent","Teleport","children","anchor","Fragment","props","map","v2","renderSlotNode","slot","slotBind","nodeAttributes","find","renderSlotNodes"],"sources":["../../../../src/utils/headless.ts"],"sourcesContent":["import { VNode, h, Teleport, Suspense, Comment, Fragment, Text, Slot } from 'vue'\n\ntype NodeAttributes = Record<string, any>\n\nconst toNode = (v: any, attrs: NodeAttributes): VNode | null => {\n  if (!v) { return null }\n\n  if (!('type' in v) || v.type === Text || typeof v === 'string') {\n    return h('div', attrs, v)\n  }\n\n  if (v.type === Comment) {\n    return v\n  }\n\n  if ('$el' in v) {\n    return toNode(v.$el, attrs)\n  }\n\n  if ((v.type as any) === Suspense) {\n    // Suspense is not supported, we just return default content. I'm not sure\n    // how to check if Suspense is ready to show default content instead of fallback.\n    // Since Suspense is still experimental let's just ignore it for now.\n    return h(v.ssContent, attrs) // TODO: Render decide when render fallback\n  }\n\n  if ((v.type as any) === Teleport) {\n    if (v.children === null) { return v }\n\n    const anchor = toNode(v.children[0], attrs)\n\n    if (anchor) {\n      v.children[0] = h(anchor, attrs)\n    }\n    return v\n  }\n\n  if (v.type === Fragment) {\n    if (v.children === null) { return v }\n    return h(Fragment, v.props, v.children.map((v: any) => toNode(v, attrs)))\n  }\n\n  return h(v, attrs)\n}\n\n/** Renders node, apply slot bind and attributes to actual HTML Node, not vue pseudo elements */\nexport const renderSlotNode = (slot: Slot | undefined, slotBind: any = {}, nodeAttributes: NodeAttributes = {}) => {\n  const children = slot?.(slotBind)\n\n  if (!children) { return null }\n\n  // Convert to Node first non-comment child or first child\n  return toNode(children.find((v) => v.type !== Comment) || children[0], nodeAttributes)\n}\n\nexport const renderSlotNodes = (slot: Slot | undefined, slotBind: any = {}, nodeAttributes: NodeAttributes = {}) => {\n  const children = slot?.(slotBind)\n\n  if (!children) { return null }\n\n  // Convert to Node first non-comment child or first child\n  return children.map((v) => toNode(v, nodeAttributes))\n}\n"],"mappings":";AAIA,MAAMA,MAAA,GAASA,CAACC,CAAA,EAAQC,KAAA,KAAwC;EAC9D,IAAI,CAACD,CAAA,EAAG;IAAS;EAAK;EAElB,MAAE,UAAUA,CAAA,KAAMA,CAAA,CAAEE,IAAA,KAASC,IAAA,IAAQ,OAAOH,CAAA,KAAM,UAAU;IACvD,OAAAI,CAAA,CAAE,OAAOH,KAAA,EAAOD,CAAC;EAC1B;EAEI,IAAAA,CAAA,CAAEE,IAAA,KAASG,OAAA,EAAS;IACf,OAAAL,CAAA;EACT;EAEA,IAAI,SAASA,CAAA,EAAG;IACP,OAAAD,MAAA,CAAOC,CAAA,CAAEM,GAAA,EAAKL,KAAK;EAC5B;EAEK,IAAAD,CAAA,CAAEE,IAAA,KAAiBK,QAAA,EAAU;IAIzB,OAAAH,CAAA,CAAEJ,CAAA,CAAEQ,SAAA,EAAWP,KAAK;EAC7B;EAEK,IAAAD,CAAA,CAAEE,IAAA,KAAiBO,QAAA,EAAU;IAC5B,IAAAT,CAAA,CAAEU,QAAA,KAAa,MAAM;MAAS,OAAAV,CAAA;IAAE;IAEpC,MAAMW,MAAA,GAASZ,MAAA,CAAOC,CAAA,CAAEU,QAAA,CAAS,CAAC,GAAGT,KAAK;IAE1C,IAAIU,MAAA,EAAQ;MACVX,CAAA,CAAEU,QAAA,CAAS,CAAC,IAAIN,CAAA,CAAEO,MAAA,EAAQV,KAAK;IACjC;IACO,OAAAD,CAAA;EACT;EAEI,IAAAA,CAAA,CAAEE,IAAA,KAASU,QAAA,EAAU;IACnB,IAAAZ,CAAA,CAAEU,QAAA,KAAa,MAAM;MAAS,OAAAV,CAAA;IAAE;IACpC,OAAOI,CAAA,CAAEQ,QAAA,EAAUZ,CAAA,CAAEa,KAAA,EAAOb,CAAA,CAAEU,QAAA,CAASI,GAAA,CAAKC,EAAA,IAAWhB,MAAA,CAAOgB,EAAA,EAAGd,KAAK,CAAC,CAAC;EAC1E;EAEO,OAAAG,CAAA,CAAEJ,CAAA,EAAGC,KAAK;AACnB;AAGa,MAAAe,cAAA,GAAiBA,CAACC,IAAA,EAAwBC,QAAA,GAAgB,IAAIC,cAAA,GAAiC,OAAO;EAC3G,MAAAT,QAAA,GAAWO,IAAA,oBAAAA,IAAA,CAAOC,QAAA;EAExB,IAAI,CAACR,QAAA,EAAU;IAAS;EAAK;EAG7B,OAAOX,MAAA,CAAOW,QAAA,CAASU,IAAA,CAAMpB,CAAA,IAAMA,CAAA,CAAEE,IAAA,KAASG,OAAO,KAAKK,QAAA,CAAS,CAAC,GAAGS,cAAc;AACvF;AAEa,MAAAE,eAAA,GAAkBA,CAACJ,IAAA,EAAwBC,QAAA,GAAgB,IAAIC,cAAA,GAAiC,OAAO;EAC5G,MAAAT,QAAA,GAAWO,IAAA,oBAAAA,IAAA,CAAOC,QAAA;EAExB,IAAI,CAACR,QAAA,EAAU;IAAS;EAAK;EAG7B,OAAOA,QAAA,CAASI,GAAA,CAAKd,CAAA,IAAMD,MAAA,CAAOC,CAAA,EAAGmB,cAAc,CAAC;AACtD"},"metadata":{},"sourceType":"module","externalDependencies":[]}