{"ast":null,"code":"import { ref, computed, watch, toRef, nextTick } from \"vue\";\nimport { h as flatten, f as isString, g as isFunction } from \"../../vendor-fff696df.mjs\";\nimport { u as useSyncProp } from \"./useSyncProp-326abeda.mjs\";\nimport { u as useFocus } from \"./useFocus-4393f76a.mjs\";\nimport { u as useFormChild } from \"./useForm/useFormChild-62e9064d.mjs\";\nconst normalizeValidationRules = (rules = [], callArguments = null) => {\n  if (isString(rules)) {\n    rules = [rules];\n  }\n  return rules.map(rule => isFunction(rule) ? rule(callArguments) : rule);\n};\nconst useValidationProps = {\n  name: {\n    type: String,\n    default: void 0\n  },\n  modelValue: {\n    required: false\n  },\n  error: {\n    type: Boolean,\n    default: void 0\n  },\n  errorMessages: {\n    type: [Array, String],\n    default: void 0\n  },\n  errorCount: {\n    type: [String, Number],\n    default: 1\n  },\n  rules: {\n    type: Array,\n    default: () => []\n  },\n  success: {\n    type: Boolean,\n    default: false\n  },\n  messages: {\n    type: [Array, String],\n    default: () => []\n  },\n  immediateValidation: {\n    type: Boolean,\n    default: false\n  }\n};\nconst useValidationEmits = [\"update:error\", \"update:errorMessages\"];\nconst isPromise = value => {\n  return typeof value === \"object\" && typeof value.then === \"function\";\n};\nconst useValidation = (props, emit, options) => {\n  const {\n    reset,\n    focus\n  } = options;\n  const {\n    isFocused,\n    onFocus,\n    onBlur\n  } = useFocus();\n  const [computedError] = useSyncProp(\"error\", props, emit, false);\n  const [computedErrorMessages] = useSyncProp(\"errorMessages\", props, emit, []);\n  const isLoading = ref(false);\n  const validationAriaAttributes = computed(() => ({\n    \"aria-invalid\": !!computedErrorMessages.value.length,\n    \"aria-errormessage\": typeof computedErrorMessages.value === \"string\" ? computedErrorMessages.value : computedErrorMessages.value.join(\", \")\n  }));\n  const resetValidation = () => {\n    computedError.value = false;\n    computedErrorMessages.value = [];\n  };\n  const processResults = results => {\n    let error = false;\n    let errorMessages = [];\n    results.forEach(result => {\n      if (isString(result)) {\n        errorMessages = [...errorMessages, result];\n        error = true;\n      } else if (result === false) {\n        error = true;\n      }\n    });\n    computedErrorMessages.value = errorMessages;\n    computedError.value = error;\n    return !error;\n  };\n  const validateAsync = async () => {\n    if (!props.rules || !props.rules.length) {\n      return true;\n    }\n    const results = normalizeValidationRules(flatten(props.rules), options.value.value);\n    const asyncPromiseResults = results.filter(result => isPromise(result));\n    const syncRules = results.filter(result => !isPromise(result));\n    if (!asyncPromiseResults.length) {\n      return processResults(syncRules);\n    }\n    isLoading.value = true;\n    return Promise.all(asyncPromiseResults).then(asyncResults => {\n      isLoading.value = false;\n      return processResults([...syncRules, ...asyncResults]);\n    });\n  };\n  const validate = () => {\n    if (!props.rules || !props.rules.length) {\n      return true;\n    }\n    const rules = flatten(props.rules);\n    const results = normalizeValidationRules(rules, options.value.value);\n    const asyncPromiseResults = results.filter(result => isPromise(result));\n    const syncRules = results.filter(result => !isPromise(result));\n    const isSyncedError = syncRules.some(result => isString(result) ? result : result === false);\n    if (asyncPromiseResults.length && !isSyncedError) {\n      isLoading.value = true;\n      Promise.all(asyncPromiseResults).then(asyncResults => {\n        processResults([...syncRules, ...asyncResults]);\n        isLoading.value = false;\n      });\n      return isSyncedError;\n    }\n    return processResults(syncRules);\n  };\n  watch(isFocused, newVal => !newVal && validate());\n  let canValidate = true;\n  const withoutValidation = cb => {\n    canValidate = false;\n    cb();\n    nextTick(() => {\n      canValidate = true;\n    });\n  };\n  watch(() => props.modelValue, () => {\n    if (!canValidate) {\n      return;\n    }\n    return validate();\n  }, {\n    immediate: props.immediateValidation\n  });\n  const {\n    doShowErrorMessages,\n    doShowError,\n    doShowLoading\n  } = useFormChild({\n    isValid: computed(() => !computedError.value),\n    isLoading,\n    errorMessages: computedErrorMessages,\n    validate,\n    validateAsync,\n    resetValidation,\n    focus,\n    reset,\n    value: computed(() => options.value || props.modelValue),\n    name: toRef(props, \"name\")\n  });\n  return {\n    computedError: computed(() => doShowError.value ? computedError.value : false),\n    computedErrorMessages: computed(() => doShowErrorMessages.value ? computedErrorMessages.value : []),\n    isLoading: computed(() => doShowLoading.value ? isLoading.value : false),\n    listeners: {\n      onFocus,\n      onBlur\n    },\n    validate,\n    resetValidation,\n    withoutValidation,\n    validationAriaAttributes\n  };\n};\nexport { useValidationEmits as a, useValidation as b, useValidationProps as u };","map":{"version":3,"names":["normalizeValidationRules","rules","callArguments","isString","map","rule","isFunction","useValidationProps","name","type","String","default","modelValue","required","error","Boolean","errorMessages","Array","errorCount","Number","success","messages","immediateValidation","useValidationEmits","isPromise","value","then","useValidation","props","emit","options","reset","focus","isFocused","onFocus","onBlur","useFocus","computedError","useSyncProp","computedErrorMessages","isLoading","ref","validationAriaAttributes","computed","length","join","resetValidation","processResults","results","forEach","result","validateAsync","flatten","asyncPromiseResults","filter","syncRules","Promise","all","asyncResults","validate","isSyncedError","some","watch","newVal","canValidate","withoutValidation","cb","nextTick","immediate","doShowErrorMessages","doShowError","doShowLoading","useFormChild","isValid","toRef","listeners"],"sources":["../../../../src/composables/useValidation.ts"],"sourcesContent":["import {\n  watch,\n  computed,\n  PropType,\n  ExtractPropTypes,\n  nextTick,\n  type WritableComputedRef,\n  ref,\n  toRef,\n} from 'vue'\nimport flatten from 'lodash/flatten.js'\nimport isFunction from 'lodash/isFunction.js'\nimport isString from 'lodash/isString.js'\n\nimport { useSyncProp } from './useSyncProp'\nimport { useFocus } from './useFocus'\nimport { useFormChild } from './useForm'\n\nexport type ValidationRule<V extends any = any> = ((v: V) => any | string) | Promise<((v: V) => any | string)>\n\ntype UseValidationOptions = {\n  reset: () => void\n  focus: () => void\n  value: WritableComputedRef<any>\n}\n\nconst normalizeValidationRules = (rules: string | ValidationRule[] = [], callArguments: unknown = null) => {\n  if (isString(rules)) { rules = [rules] as any }\n\n  return (rules as ValidationRule[])\n    .map((rule) => isFunction(rule) ? rule(callArguments) : rule)\n}\n\nexport const useValidationProps = {\n  name: { type: String, default: undefined },\n  modelValue: { required: false },\n  error: { type: Boolean, default: undefined },\n  errorMessages: { type: [Array, String] as PropType<string[] | string>, default: undefined },\n  errorCount: { type: [String, Number], default: 1 },\n  rules: { type: Array as PropType<ValidationRule<any>[]>, default: () => [] as any },\n  success: { type: Boolean, default: false },\n  messages: { type: [Array, String] as PropType<string[] | string>, default: () => [] },\n  immediateValidation: { type: Boolean, default: false },\n}\n\nexport type ValidationProps<V extends any> = typeof useValidationProps & {\n  modelValue: { type: PropType<V> }\n  rules: { type: PropType<ValidationRule<V>[]> }\n}\n\nexport const useValidationEmits = ['update:error', 'update:errorMessages'] as const\n\nconst isPromise = (value: any): value is Promise<any> => {\n  return typeof value === 'object' && typeof value.then === 'function'\n}\n\nexport const useValidation = <V, P extends ExtractPropTypes<typeof useValidationProps>>(\n  props: P,\n  emit: (event: any, ...args: any[]) => void,\n  options: UseValidationOptions,\n) => {\n  const { reset, focus } = options\n  const { isFocused, onFocus, onBlur } = useFocus()\n\n  const [computedError] = useSyncProp('error', props, emit, false as boolean)\n  const [computedErrorMessages] = useSyncProp('errorMessages', props, emit, [] as string[])\n  const isLoading = ref(false)\n\n  const validationAriaAttributes = computed(() => ({\n    'aria-invalid': !!computedErrorMessages.value.length,\n    'aria-errormessage': typeof computedErrorMessages.value === 'string'\n      ? computedErrorMessages.value\n      : computedErrorMessages.value.join(', '),\n  }))\n\n  const resetValidation = () => {\n    computedError.value = false\n    computedErrorMessages.value = []\n  }\n\n  const processResults = (results: any[]) => {\n    let error = false\n    let errorMessages: string[] = []\n\n    results.forEach((result: any) => {\n      if (isString(result)) {\n        errorMessages = [...errorMessages, result]\n        error = true\n      } else if (result === false) {\n        error = true\n      } // Ignore if result is Promise\n    })\n\n    computedErrorMessages.value = errorMessages\n    computedError.value = error\n\n    return !error\n  }\n\n  const validateAsync = async (): Promise<boolean> => {\n    if (!props.rules || !props.rules.length) {\n      return true\n    }\n\n    const results = normalizeValidationRules(flatten(props.rules), options.value.value)\n    const asyncPromiseResults = results.filter((result) => isPromise(result))\n    const syncRules = results.filter((result) => !isPromise(result))\n\n    if (!asyncPromiseResults.length) { return processResults(syncRules) }\n\n    isLoading.value = true\n    return Promise.all(asyncPromiseResults).then((asyncResults) => {\n      isLoading.value = false\n      return processResults([...syncRules, ...asyncResults])\n    })\n  }\n\n  const validate = (): boolean => {\n    if (!props.rules || !props.rules.length) {\n      return true\n    }\n\n    const rules = flatten(props.rules)\n\n    const results = normalizeValidationRules(rules, options.value.value)\n    const asyncPromiseResults = results.filter((result) => isPromise(result))\n    const syncRules = results.filter((result) => !isPromise(result))\n    const isSyncedError = syncRules.some((result: string | boolean) => isString(result) ? result : result === false)\n\n    // Prevent async rules from being executed if sync rules are invalid\n    if (asyncPromiseResults.length && !isSyncedError) {\n      isLoading.value = true\n      Promise.all(asyncPromiseResults).then((asyncResults) => {\n        processResults([...syncRules, ...asyncResults]) // Process sync rules and async rules at the same time\n        isLoading.value = false\n      })\n      return isSyncedError\n    }\n\n    return processResults(syncRules)\n  }\n\n  watch(isFocused, (newVal) => !newVal && validate())\n\n  let canValidate = true\n  const withoutValidation = (cb: () => any): void => {\n    canValidate = false\n    cb()\n    // NextTick because we update props in the same tick, but they are updated in the next one\n    nextTick(() => { canValidate = true })\n  }\n  watch(\n    () => props.modelValue,\n    () => {\n      if (!canValidate) { return }\n\n      return validate()\n    },\n    { immediate: props.immediateValidation },\n  )\n\n  const {\n    doShowErrorMessages,\n    doShowError,\n    doShowLoading,\n  } = useFormChild({\n    isValid: computed(() => !computedError.value),\n    isLoading: isLoading,\n    errorMessages: computedErrorMessages,\n    validate,\n    validateAsync,\n    resetValidation,\n    focus,\n    reset,\n    value: computed(() => options.value || props.modelValue),\n    name: toRef(props, 'name'),\n  })\n\n  return {\n    computedError: computed(() => doShowError.value ? computedError.value : false),\n    computedErrorMessages: computed(() => doShowErrorMessages.value ? computedErrorMessages.value : []),\n    isLoading: computed(() => doShowLoading.value ? isLoading.value : false),\n    listeners: { onFocus, onBlur },\n    validate,\n    resetValidation,\n    withoutValidation,\n    validationAriaAttributes,\n  }\n}\n"],"mappings":";;;;;AA0BA,MAAMA,wBAAA,GAA2BA,CAACC,KAAA,GAAmC,IAAIC,aAAA,GAAyB,SAAS;EACrG,IAAAC,QAAA,CAASF,KAAK,GAAG;IAAEA,KAAA,GAAQ,CAACA,KAAK;EAAS;EAEtC,OAAAA,KAAA,CACLG,GAAA,CAAKC,IAAA,IAASC,UAAA,CAAWD,IAAI,IAAIA,IAAA,CAAKH,aAAa,IAAIG,IAAI;AAChE;AAEO,MAAME,kBAAA,GAAqB;EAChCC,IAAA,EAAM;IAAEC,IAAA,EAAMC,MAAA;IAAQC,OAAA,EAAS;EAAU;EACzCC,UAAA,EAAY;IAAEC,QAAA,EAAU;EAAM;EAC9BC,KAAA,EAAO;IAAEL,IAAA,EAAMM,OAAA;IAASJ,OAAA,EAAS;EAAU;EAC3CK,aAAA,EAAe;IAAEP,IAAA,EAAM,CAACQ,KAAA,EAAOP,MAAM;IAAkCC,OAAA,EAAS;EAAU;EAC1FO,UAAA,EAAY;IAAET,IAAA,EAAM,CAACC,MAAA,EAAQS,MAAM;IAAGR,OAAA,EAAS;EAAE;EACjDV,KAAA,EAAO;IAAEQ,IAAA,EAAMQ,KAAA;IAA0CN,OAAA,EAASA,CAAA,KAAM;EAAU;EAClFS,OAAA,EAAS;IAAEX,IAAA,EAAMM,OAAA;IAASJ,OAAA,EAAS;EAAM;EACzCU,QAAA,EAAU;IAAEZ,IAAA,EAAM,CAACQ,KAAA,EAAOP,MAAM;IAAkCC,OAAA,EAASA,CAAA,KAAM;EAAG;EACpFW,mBAAA,EAAqB;IAAEb,IAAA,EAAMM,OAAA;IAASJ,OAAA,EAAS;EAAM;AACvD;AAOa,MAAAY,kBAAA,GAAqB,CAAC,gBAAgB,sBAAsB;AAEzE,MAAMC,SAAA,GAAaC,KAAA,IAAsC;EACvD,OAAO,OAAOA,KAAA,KAAU,YAAY,OAAOA,KAAA,CAAMC,IAAA,KAAS;AAC5D;AAEO,MAAMC,aAAA,GAAgBA,CAC3BC,KAAA,EACAC,IAAA,EACAC,OAAA,KACG;EACG;IAAEC,KAAA;IAAOC;EAAU,IAAAF,OAAA;EACzB,MAAM;IAAEG,SAAA;IAAWC,OAAA;IAASC;EAAA,IAAWC,QAAA,CAAS;EAEhD,MAAM,CAACC,aAAa,IAAIC,WAAA,CAAY,SAASV,KAAA,EAAOC,IAAA,EAAM,KAAgB;EACpE,OAACU,qBAAqB,IAAID,WAAA,CAAY,iBAAiBV,KAAA,EAAOC,IAAA,EAAM,EAAc;EAClF,MAAAW,SAAA,GAAYC,GAAA,CAAI,KAAK;EAErB,MAAAC,wBAAA,GAA2BC,QAAA,CAAS,OAAO;IAC/C,gBAAgB,CAAC,CAACJ,qBAAA,CAAsBd,KAAA,CAAMmB,MAAA;IAC9C,qBAAqB,OAAOL,qBAAA,CAAsBd,KAAA,KAAU,WACxDc,qBAAA,CAAsBd,KAAA,GACtBc,qBAAA,CAAsBd,KAAA,CAAMoB,IAAA,CAAK,IAAI;EACzC;EAEF,MAAMC,eAAA,GAAkBA,CAAA,KAAM;IAC5BT,aAAA,CAAcZ,KAAA,GAAQ;IACtBc,qBAAA,CAAsBd,KAAA,GAAQ;EAAC;EAG3B,MAAAsB,cAAA,GAAkBC,OAAA,IAAmB;IACzC,IAAIlC,KAAA,GAAQ;IACZ,IAAIE,aAAA,GAA0B;IAEtBgC,OAAA,CAAAC,OAAA,CAASC,MAAA,IAAgB;MAC3B,IAAA/C,QAAA,CAAS+C,MAAM,GAAG;QACJlC,aAAA,IAAC,GAAGA,aAAA,EAAekC,MAAM;QACjCpC,KAAA;MAAA,WACCoC,MAAA,KAAW,OAAO;QACnBpC,KAAA;MACV;IAAA,CACD;IAEDyB,qBAAA,CAAsBd,KAAA,GAAQT,aAAA;IAC9BqB,aAAA,CAAcZ,KAAA,GAAQX,KAAA;IAEtB,OAAO,CAACA,KAAA;EAAA;EAGV,MAAMqC,aAAA,GAAgB,MAAAA,CAAA,KAA8B;IAClD,IAAI,CAACvB,KAAA,CAAM3B,KAAA,IAAS,CAAC2B,KAAA,CAAM3B,KAAA,CAAM2C,MAAA,EAAQ;MAChC;IACT;IAEM,MAAAI,OAAA,GAAUhD,wBAAA,CAAyBoD,OAAA,CAAQxB,KAAA,CAAM3B,KAAK,GAAG6B,OAAA,CAAQL,KAAA,CAAMA,KAAK;IAClF,MAAM4B,mBAAA,GAAsBL,OAAA,CAAQM,MAAA,CAAQJ,MAAA,IAAW1B,SAAA,CAAU0B,MAAM,CAAC;IAClE,MAAAK,SAAA,GAAYP,OAAA,CAAQM,MAAA,CAAQJ,MAAA,IAAW,CAAC1B,SAAA,CAAU0B,MAAM,CAAC;IAE3D,KAACG,mBAAA,CAAoBT,MAAA,EAAQ;MAAE,OAAOG,cAAA,CAAeQ,SAAS;IAAE;IAEpEf,SAAA,CAAUf,KAAA,GAAQ;IAClB,OAAO+B,OAAA,CAAQC,GAAA,CAAIJ,mBAAmB,EAAE3B,IAAA,CAAMgC,YAAA,IAAiB;MAC7DlB,SAAA,CAAUf,KAAA,GAAQ;MAClB,OAAOsB,cAAA,CAAe,CAAC,GAAGQ,SAAA,EAAW,GAAGG,YAAY,CAAC;IAAA,CACtD;EAAA;EAGH,MAAMC,QAAA,GAAWA,CAAA,KAAe;IAC9B,IAAI,CAAC/B,KAAA,CAAM3B,KAAA,IAAS,CAAC2B,KAAA,CAAM3B,KAAA,CAAM2C,MAAA,EAAQ;MAChC;IACT;IAEM,MAAA3C,KAAA,GAAQmD,OAAA,CAAQxB,KAAA,CAAM3B,KAAK;IAEjC,MAAM+C,OAAA,GAAUhD,wBAAA,CAAyBC,KAAA,EAAO6B,OAAA,CAAQL,KAAA,CAAMA,KAAK;IACnE,MAAM4B,mBAAA,GAAsBL,OAAA,CAAQM,MAAA,CAAQJ,MAAA,IAAW1B,SAAA,CAAU0B,MAAM,CAAC;IAClE,MAAAK,SAAA,GAAYP,OAAA,CAAQM,MAAA,CAAQJ,MAAA,IAAW,CAAC1B,SAAA,CAAU0B,MAAM,CAAC;IACzD,MAAAU,aAAA,GAAgBL,SAAA,CAAUM,IAAA,CAAMX,MAAA,IAA6B/C,QAAA,CAAS+C,MAAM,IAAIA,MAAA,GAASA,MAAA,KAAW,KAAK;IAG3G,IAAAG,mBAAA,CAAoBT,MAAA,IAAU,CAACgB,aAAA,EAAe;MAChDpB,SAAA,CAAUf,KAAA,GAAQ;MAClB+B,OAAA,CAAQC,GAAA,CAAIJ,mBAAmB,EAAE3B,IAAA,CAAMgC,YAAA,IAAiB;QACtDX,cAAA,CAAe,CAAC,GAAGQ,SAAA,EAAW,GAAGG,YAAY,CAAC;QAC9ClB,SAAA,CAAUf,KAAA,GAAQ;MAAA,CACnB;MACM,OAAAmC,aAAA;IACT;IAEA,OAAOb,cAAA,CAAeQ,SAAS;EAAA;EAGjCO,KAAA,CAAM7B,SAAA,EAAY8B,MAAA,IAAW,CAACA,MAAA,IAAUJ,QAAA,EAAU;EAElD,IAAIK,WAAA,GAAc;EACZ,MAAAC,iBAAA,GAAqBC,EAAA,IAAwB;IACnCF,WAAA;IACXE,EAAA;IAEHC,QAAA,CAAS,MAAM;MAAgBH,WAAA;IAAA,CAAM;EAAA;EAEvCF,KAAA,CACE,MAAMlC,KAAA,CAAMhB,UAAA,EACZ,MAAM;IACJ,IAAI,CAACoD,WAAA,EAAa;MAAE;IAAO;IAE3B,OAAOL,QAAA,CAAS;EAClB,GACA;IAAES,SAAA,EAAWxC,KAAA,CAAMN;EAAoB;EAGnC;IACJ+C,mBAAA;IACAC,WAAA;IACAC;EAAA,IACEC,YAAA,CAAa;IACfC,OAAA,EAAS9B,QAAA,CAAS,MAAM,CAACN,aAAA,CAAcZ,KAAK;IAC5Ce,SAAA;IACAxB,aAAA,EAAeuB,qBAAA;IACfoB,QAAA;IACAR,aAAA;IACAL,eAAA;IACAd,KAAA;IACAD,KAAA;IACAN,KAAA,EAAOkB,QAAA,CAAS,MAAMb,OAAA,CAAQL,KAAA,IAASG,KAAA,CAAMhB,UAAU;IACvDJ,IAAA,EAAMkE,KAAA,CAAM9C,KAAA,EAAO,MAAM;EAAA,CAC1B;EAEM;IACLS,aAAA,EAAeM,QAAA,CAAS,MAAM2B,WAAA,CAAY7C,KAAA,GAAQY,aAAA,CAAcZ,KAAA,GAAQ,KAAK;IAC7Ec,qBAAA,EAAuBI,QAAA,CAAS,MAAM0B,mBAAA,CAAoB5C,KAAA,GAAQc,qBAAA,CAAsBd,KAAA,GAAQ,EAAE;IAClGe,SAAA,EAAWG,QAAA,CAAS,MAAM4B,aAAA,CAAc9C,KAAA,GAAQe,SAAA,CAAUf,KAAA,GAAQ,KAAK;IACvEkD,SAAA,EAAW;MAAEzC,OAAA;MAASC;IAAO;IAC7BwB,QAAA;IACAb,eAAA;IACAmB,iBAAA;IACAvB;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}