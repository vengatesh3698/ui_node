{"ast":null,"code":"import { toRef, unref, ref, watch } from \"vue\";\nconst useThrottleProps = {\n  delay: {\n    type: Number,\n    default: 0,\n    validator: value => value >= 0\n  }\n};\nfunction useThrottleFunction(fn, props) {\n  const delay = toRef(props, \"delay\") ?? 0;\n  const isThrottled = ref(true);\n  let lastCallResult = void 0;\n  return function (...args) {\n    const invoke = () => fn.apply(this, args);\n    if (!unref(delay)) {\n      return invoke();\n    }\n    if (isThrottled.value) {\n      isThrottled.value = false;\n      setTimeout(() => isThrottled.value = true, unref(delay));\n      lastCallResult = invoke();\n    }\n    return lastCallResult;\n  };\n}\nfunction useThrottleValue(value, props) {\n  const delay = toRef(props, \"delay\") ?? 0;\n  if (!unref(delay)) {\n    return value;\n  }\n  const isThrottled = ref(true);\n  const previousCallValue = ref();\n  const previousReturnedValue = ref();\n  const currentCallValue = ref();\n  watch(value, () => {\n    previousCallValue.value = value.value;\n    const lastCallValue = setTimeout(() => {\n      currentCallValue.value = previousCallValue.value;\n    }, unref(delay));\n    if (isThrottled.value) {\n      isThrottled.value = false;\n      currentCallValue.value = value.value;\n      previousReturnedValue.value = value.value;\n      clearTimeout(lastCallValue);\n      setTimeout(() => isThrottled.value = true, unref(delay));\n    } else {\n      currentCallValue.value = previousReturnedValue.value;\n    }\n  }, {\n    immediate: true\n  });\n  return currentCallValue;\n}\nexport { useThrottleValue as a, useThrottleFunction as b, useThrottleProps as u };","map":{"version":3,"names":["useThrottleProps","delay","type","Number","default","validator","value","useThrottleFunction","fn","props","toRef","isThrottled","ref","lastCallResult","args","invoke","apply","unref","setTimeout","useThrottleValue","previousCallValue","previousReturnedValue","currentCallValue","watch","lastCallValue","clearTimeout","immediate"],"sources":["../../../../src/composables/useThrottle.ts"],"sourcesContent":["/**\n * @description returns throttled function or value\n * the last one always returns last-call value in the end if no more new calls were provided\n * @example\n *    import { useThrottleFunction, useThrottleValue } from '../../composables'\n *    ...\n *    const localThrottledFunction = useThrottleFunction(functionToThrottle, props)\n *    const localThrottledValue = useThrottleValue(reactiveValueToThrottle, props)\n */\n\nimport {\n  ref, toRef, unref,\n  watch,\n  Ref, ExtractPropTypes, ComponentInternalInstance,\n} from 'vue'\n\ntype ThrottledFunctionArgs = any[]\ntype ThrottledFunction<Output> = (...args: ThrottledFunctionArgs) => Output\n\nexport const useThrottleProps = {\n  delay: {\n    type: Number,\n    default: 0,\n    validator: (value: number) => value >= 0,\n  },\n}\n\ntype UseThrottleProps = ExtractPropTypes<typeof useThrottleProps>\n\n/**\n * @param fn passed function to throttle\n * @param props { delay } call delay in ms\n */\nexport function useThrottleFunction<Output> (fn: ThrottledFunction<Output>, props: UseThrottleProps) {\n  const delay = toRef(props, 'delay') ?? 0\n\n  const isThrottled = ref(true)\n\n  /**\n   * No way this will be returned without reassignment, so we don't want typescript\n   * to always keep undefined as possible return type. If function returns undefined itself\n   * it will be still presented by typescript as undefined (expected behaviour).\n   */\n  let lastCallResult = undefined as any as Output\n\n  return function (this: any, ...args: ThrottledFunctionArgs) {\n    const invoke = () => fn.apply(this, args)\n\n    if (!unref(delay)) { return invoke() }\n\n    if (isThrottled.value) {\n      isThrottled.value = false\n\n      setTimeout(() => (isThrottled.value = true), unref(delay))\n\n      lastCallResult = invoke()\n    }\n\n    return lastCallResult\n  }\n}\n\n/**\n * @param value passed reactive value to throttle\n * @param props { delay } call delay in ms\n */\nexport function useThrottleValue<T> (value: Ref<T>, props: UseThrottleProps): Ref<T> {\n  const delay = toRef(props, 'delay') ?? 0\n\n  if (!unref(delay)) { return value }\n\n  const isThrottled = ref(true)\n\n  const previousCallValue = ref<T>() as Ref<T>\n  const previousReturnedValue = ref<T>() as Ref<T>\n  const currentCallValue = ref<T>() as Ref<T>\n\n  watch(value, () => {\n    // we save and return last call value at the end if no more calls were provided\n    previousCallValue.value = value.value\n    const lastCallValue = setTimeout(() => {\n      currentCallValue.value = previousCallValue.value\n    }, unref(delay))\n\n    if (isThrottled.value) {\n      isThrottled.value = false\n\n      currentCallValue.value = value.value\n      previousReturnedValue.value = value.value\n\n      // no need to return previously saved value anymore\n      clearTimeout(lastCallValue)\n\n      setTimeout(() => (isThrottled.value = true), unref(delay))\n    } else {\n      currentCallValue.value = previousReturnedValue.value\n    }\n  }, { immediate: true })\n\n  return currentCallValue\n}\n"],"mappings":";AAmBO,MAAMA,gBAAA,GAAmB;EAC9BC,KAAA,EAAO;IACLC,IAAA,EAAMC,MAAA;IACNC,OAAA,EAAS;IACTC,SAAA,EAAYC,KAAA,IAAkBA,KAAA,IAAS;EACzC;AACF;AAQgB,SAAAC,oBAA6BC,EAAA,EAA+BC,KAAA,EAAyB;EACnG,MAAMR,KAAA,GAAQS,KAAA,CAAMD,KAAA,EAAO,OAAO,KAAK;EAEjC,MAAAE,WAAA,GAAcC,GAAA,CAAI,IAAI;EAO5B,IAAIC,cAAA,GAAiB;EAErB,OAAO,aAAwBC,IAAA,EAA6B;IAC1D,MAAMC,MAAA,GAASA,CAAA,KAAMP,EAAA,CAAGQ,KAAA,CAAM,MAAMF,IAAI;IAEpC,KAACG,KAAA,CAAMhB,KAAK,GAAG;MAAE,OAAOc,MAAA,CAAO;IAAE;IAErC,IAAIJ,WAAA,CAAYL,KAAA,EAAO;MACrBK,WAAA,CAAYL,KAAA,GAAQ;MAEpBY,UAAA,CAAW,MAAOP,WAAA,CAAYL,KAAA,GAAQ,MAAOW,KAAA,CAAMhB,KAAK,CAAC;MAEzDY,cAAA,GAAiBE,MAAA,CAAO;IAC1B;IAEO,OAAAF,cAAA;EAAA;AAEX;AAMgB,SAAAM,iBAAqBb,KAAA,EAAeG,KAAA,EAAiC;EACnF,MAAMR,KAAA,GAAQS,KAAA,CAAMD,KAAA,EAAO,OAAO,KAAK;EAEnC,KAACQ,KAAA,CAAMhB,KAAK,GAAG;IAAS,OAAAK,KAAA;EAAM;EAE5B,MAAAK,WAAA,GAAcC,GAAA,CAAI,IAAI;EAE5B,MAAMQ,iBAAA,GAAoBR,GAAA;EAC1B,MAAMS,qBAAA,GAAwBT,GAAA;EAC9B,MAAMU,gBAAA,GAAmBV,GAAA;EAEzBW,KAAA,CAAMjB,KAAA,EAAO,MAAM;IAEjBc,iBAAA,CAAkBd,KAAA,GAAQA,KAAA,CAAMA,KAAA;IAC1B,MAAAkB,aAAA,GAAgBN,UAAA,CAAW,MAAM;MACrCI,gBAAA,CAAiBhB,KAAA,GAAQc,iBAAA,CAAkBd,KAAA;IAAA,GAC1CW,KAAA,CAAMhB,KAAK,CAAC;IAEf,IAAIU,WAAA,CAAYL,KAAA,EAAO;MACrBK,WAAA,CAAYL,KAAA,GAAQ;MAEpBgB,gBAAA,CAAiBhB,KAAA,GAAQA,KAAA,CAAMA,KAAA;MAC/Be,qBAAA,CAAsBf,KAAA,GAAQA,KAAA,CAAMA,KAAA;MAGpCmB,YAAA,CAAaD,aAAa;MAE1BN,UAAA,CAAW,MAAOP,WAAA,CAAYL,KAAA,GAAQ,MAAOW,KAAA,CAAMhB,KAAK,CAAC;IAAA,OACpD;MACLqB,gBAAA,CAAiBhB,KAAA,GAAQe,qBAAA,CAAsBf,KAAA;IACjD;EAAA,GACC;IAAEoB,SAAA,EAAW;EAAA,CAAM;EAEf,OAAAJ,gBAAA;AACT"},"metadata":{},"sourceType":"module","externalDependencies":[]}