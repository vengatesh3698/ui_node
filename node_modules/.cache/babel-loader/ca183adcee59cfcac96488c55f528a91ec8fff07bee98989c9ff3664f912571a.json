{"ast":null,"code":"import { m as merge } from \"../../../../vendor-fff696df.mjs\";\nimport { i as isMatchDynamicSegments, d as dynamicSegments } from \"./dynamic-segment-66784bea.mjs\";\nimport { i as isMatchRegex, r as regexGroupsValues } from \"./regex-c1fc6a08.mjs\";\nimport { i as isIconConfigurationString, a as isIconConfigurationRegex } from \"../types-d7a93c95.mjs\";\nconst isMatchConfiguration = (iconName, iconConfiguration) => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return isMatchDynamicSegments(iconName, iconConfiguration.name);\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return isMatchRegex(iconName, iconConfiguration.name);\n  }\n  return false;\n};\nconst resolveIconConfigurationString = (iconName, iconConfiguration) => {\n  const args = dynamicSegments(iconName, iconConfiguration.name);\n  return iconConfiguration.resolve && iconConfiguration.resolve(args);\n};\nconst resolveIconConfigurationRegex = (iconName, iconConfig) => {\n  if (iconConfig.name.global) {\n    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);\n  }\n  const args = regexGroupsValues(iconName, iconConfig.name);\n  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);\n};\nconst resolveIconConfiguration = (iconName, iconConfiguration) => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return resolveIconConfigurationString(iconName, iconConfiguration);\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return resolveIconConfigurationRegex(iconName, iconConfiguration);\n  }\n  throw Error(\"Unknown icon config\");\n};\nconst findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {\n  const matchedConfig = globalIconConfig.find(config => {\n    if (namesToIgnore.includes(config.name.toString())) {\n      return false;\n    }\n    return isMatchConfiguration(iconName, config);\n  });\n  if (!matchedConfig) {\n    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);\n  }\n  return matchedConfig;\n};\nconst findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {\n  if (!iconName) {\n    return;\n  }\n  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);\n  const resolvedIconConfiguration = merge(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);\n  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];\n  return merge(findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore), resolvedIconConfiguration);\n};\nconst iconPropsFromIconConfiguration = iconConfiguration => {\n  const junkKeys = [\"name\", \"to\", \"resolve\", \"resolveFromRegex\"];\n  const configuration = iconConfiguration;\n  junkKeys.forEach(key => {\n    delete configuration[key];\n  });\n  return configuration;\n};\nconst getIconConfiguration = (name, iconConfig) => {\n  const configuration = findIconConfiguration(name, iconConfig);\n  if (configuration === void 0) {\n    return {};\n  }\n  return iconPropsFromIconConfiguration(configuration);\n};\nexport { getIconConfiguration as g };","map":{"version":3,"names":["isMatchConfiguration","iconName","iconConfiguration","isIconConfigurationString","isMatchDynamicSegments","name","isIconConfigurationRegex","isMatchRegex","resolveIconConfigurationString","args","dynamicSegments","resolve","resolveIconConfigurationRegex","iconConfig","global","Error","regexGroupsValues","resolveFromRegex","resolveIconConfiguration","findMatchedIconConfiguration","globalIconConfig","namesToIgnore","matchedConfig","find","config","includes","toString","findIconConfiguration","matchedIconConfiguration","resolvedIconConfiguration","merge","to","iconPropsFromIconConfiguration","junkKeys","configuration","forEach","key","getIconConfiguration"],"sources":["../../../../../../src/services/icon/utils/get-icon-configuration.ts"],"sourcesContent":["import merge from 'lodash/merge.js'\nimport { isMatchDynamicSegments, dynamicSegments } from './dynamic-segment'\nimport { isMatchRegex, regexGroupsValues } from './regex'\nimport {\n  IconConfig,\n  IconConfiguration,\n  IconConfigurationString,\n  IconConfigurationRegex,\n  isIconConfigurationString,\n  isIconConfigurationRegex,\n  IconProps,\n} from '../types'\n\nconst isMatchConfiguration = (iconName: string, iconConfiguration: IconConfiguration) => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return isMatchDynamicSegments(iconName, iconConfiguration.name)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return isMatchRegex(iconName, iconConfiguration.name)\n  }\n\n  return false\n}\n\nconst resolveIconConfigurationString = (iconName: string, iconConfiguration: IconConfigurationString) => {\n  const args = dynamicSegments(iconName, iconConfiguration.name)\n  return iconConfiguration.resolve && iconConfiguration.resolve(args)\n}\n\nconst resolveIconConfigurationRegex = (iconName: string, iconConfig: IconConfigurationRegex) => {\n  if (iconConfig.name.global) {\n    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`)\n  }\n  const args = regexGroupsValues(iconName, iconConfig.name) as string[]\n  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args)\n}\n\nconst resolveIconConfiguration = (iconName: string, iconConfiguration: IconConfiguration): IconProps | undefined => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return resolveIconConfigurationString(iconName, iconConfiguration)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return resolveIconConfigurationRegex(iconName, iconConfiguration)\n  }\n\n  throw Error('Unknown icon config')\n}\n\nconst findMatchedIconConfiguration = (iconName: string, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration => {\n  const matchedConfig = globalIconConfig.find((config) => {\n    if (namesToIgnore.includes(config.name.toString())) { return false }\n\n    return isMatchConfiguration(iconName, config)\n  })\n\n  if (!matchedConfig) { throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`) }\n\n  return matchedConfig\n}\n\nconst findIconConfiguration = (iconName: string | undefined, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration | undefined => {\n  if (!iconName) { return }\n\n  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore)\n  const resolvedIconConfiguration = merge(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration)\n\n  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()]\n\n  return merge(\n    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),\n    resolvedIconConfiguration,\n  )\n}\n\n/** Removes name, to, resolveFromRegex and resolve from IconConfiguration */\nconst iconPropsFromIconConfiguration = (iconConfiguration: IconConfiguration): IconProps => {\n  const junkKeys = ['name', 'to', 'resolve', 'resolveFromRegex']\n\n  const configuration: Record<string, string> = iconConfiguration as any\n  junkKeys.forEach((key) => { delete configuration[key] })\n  return configuration\n}\n\nexport const getIconConfiguration = (name: string, iconConfig: IconConfig): IconProps => {\n  const configuration = findIconConfiguration(name, iconConfig)\n\n  if (configuration === undefined) { return {} }\n\n  return iconPropsFromIconConfiguration(configuration)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}