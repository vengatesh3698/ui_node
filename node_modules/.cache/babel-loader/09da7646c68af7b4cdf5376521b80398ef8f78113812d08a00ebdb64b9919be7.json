{"ast":null,"code":"import { ref, reactive, watchEffect, watch } from \"vue\";\nimport { u as useEvent } from \"./useEvent-d1ae925d.mjs\";\nconst mouseEvents = [\"mousedown\", \"mousemove\"];\nconst touchEvents = [\"touchstart\", \"touchmove\"];\nconst commonAllowedDirections = {\n  vertical: [\"\", \"all\", \"vertical\"],\n  horizontal: [\"\", \"all\", \"horizontal\"]\n};\nconst verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, \"up\", \"down\"];\nconst horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, \"left\", \"right\"];\nconst useSwipeProps = {\n  swipable: {\n    type: Boolean,\n    default: false\n  },\n  swipeDistance: {\n    type: Number,\n    default: 75\n  },\n  swipeDirection: {\n    type: String,\n    default: \"all\"\n  }\n};\nconst useSwipe = (props, container, cb) => {\n  const swipeStarted = ref(false);\n  const swipePath = reactive({\n    start: {\n      x: 0,\n      y: 0\n    },\n    end: {\n      x: 0,\n      y: 0\n    }\n  });\n  const swipeDuration = reactive({\n    start: 0,\n    end: 0\n  });\n  const setState = (e, type) => {\n    let event;\n    if (mouseEvents.includes(e.type)) {\n      event = e;\n    }\n    if (touchEvents.includes(e.type)) {\n      const touchEvent = e;\n      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];\n    }\n    if (!event) {\n      return;\n    }\n    swipePath[type].x = event.pageX;\n    swipePath[type].y = event.pageY;\n    swipeDuration[type] = ( /* @__PURE__ */new Date()).getTime();\n  };\n  const onSwipeStart = e => {\n    if (!props.swipable || swipeStarted.value) {\n      return;\n    }\n    swipeStarted.value = true;\n    setState(e, \"start\");\n  };\n  const onSwipeMove = e => {\n    if (!swipeStarted.value) {\n      return;\n    }\n    setState(e, \"end\");\n  };\n  const resetSwipe = () => {\n    [\"start\", \"end\"].forEach(type => {\n      swipePath[type].x = 0;\n      swipePath[type].y = 0;\n      swipeDuration[type] = 0;\n    });\n    swipeStarted.value = false;\n  };\n  const isSwipeAllowed = reactive({\n    vertical: false,\n    horizontal: false\n  });\n  watchEffect(() => {\n    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);\n    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);\n  });\n  const calcDistance = axis => {\n    return isSwipeAllowed[axis === \"x\" ? \"horizontal\" : \"vertical\"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;\n  };\n  const getAcceptableValue = (direction, result) => {\n    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : \"\";\n  };\n  const swipeState = reactive({\n    direction: \"\",\n    duration: 0\n  });\n  watch(swipePath, () => {\n    const xDistance = calcDistance(\"x\");\n    const yDistance = calcDistance(\"y\");\n    if ((xDistance || yDistance) && [xDistance, yDistance].some(el => Math.abs(el) >= props.swipeDistance)) {\n      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {\n        const result = xDistance > 0 ? \"left\" : \"right\";\n        swipeState.direction = getAcceptableValue(\"horizontal\", result);\n      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {\n        const result = yDistance > 0 ? \"down\" : \"up\";\n        swipeState.direction = getAcceptableValue(\"vertical\", result);\n      }\n      swipeState.duration = swipeDuration.end - swipeDuration.start;\n      resetSwipe();\n    }\n  }, {\n    deep: true\n  });\n  watch(swipeState, () => cb(swipeState), {\n    deep: true\n  });\n  if (props.swipable) {\n    useEvent([\"touchstart\", \"mousedown\"], onSwipeStart, container);\n    useEvent([\"touchmove\", \"mousemove\"], onSwipeMove, container);\n    useEvent([\"touchcancel\", \"mouseup\", \"touchend\", \"mouseleave\"], resetSwipe, container);\n  }\n  return {\n    swipeState\n  };\n};\nexport { useSwipe as a, useSwipeProps as u };","map":{"version":3,"names":["mouseEvents","touchEvents","commonAllowedDirections","vertical","horizontal","verticalSpecificAllowedDirections","horizontalSpecificAllowedDirections","useSwipeProps","swipable","type","Boolean","default","swipeDistance","Number","swipeDirection","String","useSwipe","props","container","cb","swipeStarted","ref","swipePath","reactive","start","x","y","end","swipeDuration","setState","e","event","includes","touchEvent","changedTouches","length","pageX","pageY","Date","getTime","onSwipeStart","value","onSwipeMove","resetSwipe","forEach","isSwipeAllowed","watchEffect","calcDistance","axis","Math","trunc","getAcceptableValue","direction","result","swipeState","duration","watch","xDistance","yDistance","some","el","abs","deep","useEvent"],"sources":["../../../../src/composables/useSwipe.ts"],"sourcesContent":["import { ref, reactive, watch, PropType, ShallowRef, ExtractPropTypes, watchEffect } from 'vue'\n\nimport { useEvent } from './'\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right' | ''\ntype SwipePosition = 'start' | 'end'\ntype SwipeCoordinates = Record<'x' | 'y', number>\ntype SwipePath = Record<SwipePosition, SwipeCoordinates>\nexport type SwipeState = { direction: SwipeDirection, duration: number }\n\ntype AllowedSwipeDirection = 'all' | 'horizontal' | 'vertical' | SwipeDirection\n\nconst mouseEvents = ['mousedown', 'mousemove']\nconst touchEvents = ['touchstart', 'touchmove']\n\nconst commonAllowedDirections = {\n  vertical: ['', 'all', 'vertical'],\n  horizontal: ['', 'all', 'horizontal'],\n}\nconst verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, 'up', 'down']\nconst horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, 'left', 'right']\n\n/**\n * swipable - enables swiping.\n * swipeDistance - distance in px considered sufficient for the swipe event.\n * swipeDirection - allowed and handled swipe directions.\n */\nexport const useSwipeProps = {\n  swipable: { type: Boolean, default: false },\n  swipeDistance: { type: Number, default: 75 },\n  swipeDirection: { type: String as PropType<AllowedSwipeDirection>, default: 'all' },\n}\n\n/**\n * @description composable for handling swipes direction via mouse or touchpad.\n * @param props - use swipe props.\n * @param container - swipable container shallow ref.\n * @param cb - callback for every swipe event.\n * @example\n *  props: { ...useSwipeProps }\n *  const container = shallowRef<HTMLElement>()\n *  const onSwipe = () => { if(swipeState === 'left') { local component's logic } }\n *  const { swipeState } = useSwipe(props, container, onSwipe)\n */\nexport const useSwipe = (\n  props: ExtractPropTypes<typeof useSwipeProps>,\n  container: ShallowRef<HTMLElement | undefined>,\n  cb: (state: SwipeState) => void,\n) => {\n  const swipeStarted = ref(false)\n  const swipePath = reactive({\n    start: { x: 0, y: 0 },\n    end: { x: 0, y: 0 },\n  }) as SwipePath\n  const swipeDuration = reactive({\n    start: 0,\n    end: 0,\n  })\n\n  const setState = (e: TouchEvent | MouseEvent, type: SwipePosition) => {\n    let event: MouseEvent | Touch | undefined\n    if (mouseEvents.includes(e.type)) { event = e as MouseEvent }\n    if (touchEvents.includes(e.type)) {\n      const touchEvent = e as TouchEvent\n      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1]\n    }\n    if (!event) { return }\n\n    swipePath[type].x = event.pageX\n    swipePath[type].y = event.pageY\n    swipeDuration[type] = new Date().getTime()\n  }\n\n  const onSwipeStart = (e: TouchEvent | MouseEvent) => {\n    if (!props.swipable || swipeStarted.value) { return }\n    swipeStarted.value = true\n    setState(e, 'start')\n  }\n\n  const onSwipeMove = (e: TouchEvent | MouseEvent) => {\n    if (!swipeStarted.value) { return }\n    setState(e, 'end')\n  }\n\n  const resetSwipe = () => {\n    (['start', 'end'] as SwipePosition[]).forEach((type) => {\n      swipePath[type].x = 0\n      swipePath[type].y = 0\n      swipeDuration[type] = 0\n    })\n    swipeStarted.value = false\n  }\n\n  const isSwipeAllowed = reactive({\n    vertical: false,\n    horizontal: false,\n  })\n  watchEffect(() => {\n    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection)\n    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection)\n  })\n\n  const calcDistance = (axis: 'x' | 'y') => {\n    return isSwipeAllowed[axis === 'x' ? 'horizontal' : 'vertical'] &&\n    swipePath.start[axis] && swipePath.end[axis]\n      ? Math.trunc(swipePath.start[axis] - swipePath.end[axis])\n      : 0\n  }\n\n  const getAcceptableValue = (direction: 'horizontal' | 'vertical', result: SwipeDirection) => {\n    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : ''\n  }\n\n  const swipeState = reactive({ direction: '', duration: 0 }) as SwipeState\n  watch(swipePath, () => {\n    const xDistance = calcDistance('x')\n    const yDistance = calcDistance('y')\n\n    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {\n      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {\n        const result = xDistance > 0 ? 'left' : 'right'\n        swipeState.direction = getAcceptableValue('horizontal', result)\n      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {\n        const result = yDistance > 0 ? 'down' : 'up'\n        swipeState.direction = getAcceptableValue('vertical', result)\n      }\n\n      swipeState.duration = swipeDuration.end - swipeDuration.start\n\n      resetSwipe()\n    }\n  }, { deep: true })\n\n  watch(swipeState, () => cb(swipeState), { deep: true })\n\n  if (props.swipable) {\n    useEvent(['touchstart', 'mousedown'], onSwipeStart, container)\n    useEvent(['touchmove', 'mousemove'], onSwipeMove, container)\n    useEvent(['touchcancel', 'mouseup', 'touchend', 'mouseleave'], resetSwipe, container)\n  }\n\n  return { swipeState }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}