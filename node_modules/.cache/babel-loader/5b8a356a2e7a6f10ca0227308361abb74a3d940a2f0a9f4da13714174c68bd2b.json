{"ast":null,"code":"import { t as throttle } from \"../../../vendor-fff696df.mjs\";\nfunction getWindowHeight() {\n  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;\n}\nfunction computeAffixedState({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target\n}) {\n  let isTopAffixed = false;\n  let isBottomAffixed = false;\n  const windowHeight = getWindowHeight();\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop;\n    } else {\n      const {\n        top\n      } = target.getBoundingClientRect();\n      isTopAffixed = coordinates.top - top <= offsetTop;\n    }\n  }\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;\n    } else {\n      const {\n        bottom\n      } = target.getBoundingClientRect();\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;\n    }\n  }\n  return {\n    isTopAffixed,\n    isBottomAffixed\n  };\n}\nfunction checkAffixedStateChange(currentState, nextState) {\n  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;\n}\nfunction handleThrottledEvent(eventName, context) {\n  const {\n    target,\n    element,\n    offsetTop,\n    offsetBottom,\n    setState,\n    getState,\n    initialPosition\n  } = context;\n  if (!element) {\n    return;\n  }\n  const isInitialCall = !eventName;\n  const coordinates = element.getBoundingClientRect();\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target\n  };\n  const nextState = isInitialCall && initialPosition ? computeAffixedState({\n    coordinates: initialPosition,\n    ...options\n  }) : computeAffixedState({\n    coordinates,\n    ...options\n  });\n  const prevState = getState();\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({\n      ...nextState,\n      width: coordinates.width\n    });\n  } else if (prevState.width !== coordinates.width) {\n    setState({\n      ...prevState,\n      width: coordinates.width\n    });\n  }\n}\nfunction useCaptureDefault(eventName) {\n  return eventName === \"scroll\";\n}\nfunction useEventsHandlerWithThrottle(events, {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50\n}) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle(event => handler(eventName, event), wait);\n    window.addEventListener(eventName, _handler, useCapture(eventName));\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));\n  });\n  return () => clearHandlersArray.forEach(clear => clear());\n}\nexport { getWindowHeight as g, handleThrottledEvent as h, useEventsHandlerWithThrottle as u };","map":{"version":3,"names":["getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","checkAffixedStateChange","currentState","nextState","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","isInitialCall","options","prevState","width","useCaptureDefault","useEventsHandlerWithThrottle","events","handler","useCapture","wait","clearHandlersArray","map","_handler","throttle","event","addEventListener","removeEventListener","forEach","clear"],"sources":["../../../../../src/components/va-affix/VaAffix-utils.ts"],"sourcesContent":["import throttle from 'lodash/throttle.js'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: HTMLElement | undefined;\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: DOMRect | undefined;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  if (!element) { return }\n\n  const isInitialCall = !eventName\n  const coordinates = element.getBoundingClientRect()\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  const nextState = isInitialCall && initialPosition\n    ? computeAffixedState({ coordinates: initialPosition, ...options })\n    : computeAffixedState({ coordinates, ...options })\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}