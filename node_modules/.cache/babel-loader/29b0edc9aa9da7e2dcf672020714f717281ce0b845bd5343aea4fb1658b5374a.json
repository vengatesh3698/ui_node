{"ast":null,"code":"import { g as getComponentProps } from \"./resolve-component-props-6be1f787.mjs\";\nfunction extractComponentProps(component, ignoreProps) {\n  const props = getComponentProps(component);\n  if (ignoreProps) {\n    return Object.keys(props).reduce((acc, propName) => {\n      if (ignoreProps.includes(propName)) {\n        return acc;\n      }\n      if (props[propName] === void 0) {\n        return acc;\n      }\n      acc[propName] = typeof props[propName] === \"string\" ? {} : props[propName];\n      return acc;\n    }, {});\n  }\n  return props;\n}\nfunction extractComponentEmits(component) {\n  return [...new Set(component.emits)];\n}\nexport { extractComponentEmits as a, extractComponentProps as e };","map":{"version":3,"names":["extractComponentProps","component","ignoreProps","props","getComponentProps","Object","keys","reduce","acc","propName","includes","extractComponentEmits","Set","emits"],"sources":["../../../../../src/utils/component-options/extract-component-options.ts"],"sourcesContent":["import type { ExtractComponentEmits, ExtractComponentProps, DefineComponentOptions } from './types'\nimport { getComponentProps } from './resolve-component-props'\n\n/**\n * Returns component props options.\n *\n *\n * @param ignoreProps - deprecated - prefer using lodash omit instead\n *\n * @returns object that looks like this:\n * ```ts\n * {\n *   modelValue: { type: String, required: true },\n *   options: { type: Array, default: [] },\n *   size: { type: String as PropType<'small' | 'medium' | 'large'>, default: 'medium' }\n * }\n * ```\n */\nexport function extractComponentProps<T extends DefineComponentOptions> (component: T, ignoreProps?: string[]): ExtractComponentProps<T> {\n  const props: any = getComponentProps(component as any)\n\n  // TODO: Not sure if it is a good idea to handle ignore props here\n  // Looks like it is not type safe. Need a separated filter object function\n  if (ignoreProps) {\n    return Object\n      .keys(props)\n      .reduce<any>((acc, propName) => {\n        if (ignoreProps.includes(propName)) { return acc }\n\n        if (props[propName] === undefined) { return acc }\n\n        acc[propName] = typeof props[propName] === 'string' ? {} : props[propName]\n\n        return acc\n      }, {})\n  }\n\n  return props\n}\n\n/** Returns component emits option */\nexport function extractComponentEmits<T> (component: T): ExtractComponentEmits<T> {\n  return [...new Set((component as any).emits)] as any\n}\n"],"mappings":";AAkBgB,SAAAA,sBAAyDC,SAAA,EAAcC,WAAA,EAAkD;EACjI,MAAAC,KAAA,GAAaC,iBAAA,CAAkBH,SAAgB;EAIrD,IAAIC,WAAA,EAAa;IACf,OAAOG,MAAA,CACJC,IAAA,CAAKH,KAAK,EACVI,MAAA,CAAY,CAACC,GAAA,EAAKC,QAAA,KAAa;MAC1B,IAAAP,WAAA,CAAYQ,QAAA,CAASD,QAAQ,GAAG;QAAS,OAAAD,GAAA;MAAI;MAE7C,IAAAL,KAAA,CAAMM,QAAQ,MAAM,QAAW;QAAS,OAAAD,GAAA;MAAI;MAE5CA,GAAA,CAAAC,QAAQ,IAAI,OAAON,KAAA,CAAMM,QAAQ,MAAM,WAAW,CAAK,IAAAN,KAAA,CAAMM,QAAQ;MAElE,OAAAD,GAAA;IACT,GAAG,CAAE;EACT;EAEO,OAAAL,KAAA;AACT;AAGO,SAASQ,sBAA0BV,SAAA,EAAwC;EAChF,OAAO,CAAC,GAAG,IAAIW,GAAA,CAAKX,SAAA,CAAkBY,KAAK,CAAC;AAC9C"},"metadata":{},"sourceType":"module","externalDependencies":[]}