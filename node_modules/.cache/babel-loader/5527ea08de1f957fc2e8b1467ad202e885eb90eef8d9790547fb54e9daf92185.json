{"ast":null,"code":"import { ref, computed, watch } from \"vue\";\nimport { g as getItemKey } from \"./useRows-4dd6ceac.mjs\";\nimport { c as useSelectableProp, b as useItemsTrackByProp } from \"./useCommonProps-59d5fc97.mjs\";\nconst useSelectableProps = {\n  ...useSelectableProp,\n  ...useItemsTrackByProp,\n  modelValue: {\n    type: Array\n  },\n  selectMode: {\n    type: String,\n    default: \"multiple\"\n  }\n};\nconst useSelectableRow = (paginatedRows, props, emit) => {\n  const selectedItemsFallback = ref([]);\n  const selectedItemsSync = computed({\n    get() {\n      if (props.modelValue === void 0) {\n        return selectedItemsFallback.value;\n      } else {\n        return props.modelValue;\n      }\n    },\n    set(modelValue) {\n      if (props.modelValue === void 0) {\n        selectedItemsFallback.value = modelValue;\n      }\n      emit(\"update:modelValue\", modelValue);\n    }\n  });\n  const prevSelectedRowIndex = ref(-1);\n  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {\n    if (newSelectMode === \"single\" && oldSelectMode === \"multiple\") {\n      selectedItemsSync.value = [];\n      setPrevSelectedRowIndex(-1);\n    }\n  });\n  watch(paginatedRows, () => {\n    setPrevSelectedRowIndex(-1);\n  });\n  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {\n    emit(\"selectionChange\", {\n      currentSelectedItems,\n      previousSelectedItems\n    });\n  }, {\n    immediate: true\n  });\n  const getKey = source => getItemKey(source, props.itemsTrackBy);\n  const noRowsSelected = computed(() => !paginatedRows.value.some(({\n    source\n  }) => selectedItemsSync.value.includes(getKey(source))));\n  const allRowsSelected = computed(() => {\n    if (paginatedRows.value.length === 0) {\n      return false;\n    }\n    return paginatedRows.value.every(({\n      source\n    }) => selectedItemsSync.value.includes(getKey(source)));\n  });\n  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);\n  function isRowSelected(row) {\n    return selectedItemsSync.value.includes(getKey(row.source));\n  }\n  function selectAllRows() {\n    selectedItemsSync.value = [... /* @__PURE__ */new Set([...selectedItemsSync.value, ...paginatedRows.value.map(row => getKey(row.source))])];\n  }\n  function unselectAllRows() {\n    const paginatedRowsKeys = paginatedRows.value.map(row => getKey(row.source));\n    selectedItemsSync.value = selectedItemsSync.value.filter(item => !paginatedRowsKeys.includes(item));\n  }\n  function selectRow(row) {\n    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];\n  }\n  function selectOnlyRow(row) {\n    selectedItemsSync.value = [getKey(row.source)];\n  }\n  function unselectRow(row) {\n    const index = selectedItemsSync.value.findIndex(item => item === getKey(row.source));\n    selectedItemsSync.value = [...selectedItemsSync.value.slice(0, index), ...selectedItemsSync.value.slice(index + 1)];\n  }\n  function setPrevSelectedRowIndex(rowInitialIndex) {\n    if (rowInitialIndex === -1) {\n      prevSelectedRowIndex.value = -1;\n    } else {\n      const prevSelectedRow = paginatedRows.value.find(row => row.initialIndex === rowInitialIndex);\n      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;\n    }\n  }\n  function getRowsToSelect(targetIndex) {\n    let start;\n    let end;\n    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {\n      start = Math.min(prevSelectedRowIndex.value, targetIndex);\n      end = Math.max(prevSelectedRowIndex.value, targetIndex);\n    } else {\n      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);\n      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);\n    }\n    return paginatedRows.value.slice(start, end + 1);\n  }\n  function mergeSelection(rowsToSelect) {\n    const rowsToSelectedItems = rowsToSelect.map(row => getKey(row.source));\n    if (noRowsSelected.value) {\n      selectedItemsSync.value = rowsToSelectedItems;\n      return;\n    }\n    const isInternalSelection = rowsToSelectedItems.every(item => selectedItemsSync.value.includes(item));\n    if (isInternalSelection) {\n      selectedItemsSync.value = selectedItemsSync.value.filter(item => !rowsToSelectedItems.includes(item));\n      return;\n    }\n    selectedItemsSync.value = [... /* @__PURE__ */new Set([...selectedItemsSync.value, ...rowsToSelectedItems])];\n  }\n  function toggleRowSelection(row) {\n    if (!props.selectable) {\n      return;\n    }\n    if (isRowSelected(row)) {\n      unselectRow(row);\n      props.selectMode === \"single\" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);\n    } else {\n      props.selectMode === \"single\" ? selectOnlyRow(row) : selectRow(row);\n      setPrevSelectedRowIndex(row.initialIndex);\n    }\n  }\n  function ctrlSelectRow(row) {\n    if (!props.selectable) {\n      return;\n    }\n    toggleRowSelection(row);\n  }\n  function shiftSelectRows(row) {\n    if (!props.selectable) {\n      return;\n    }\n    if (props.selectMode === \"single\" || prevSelectedRowIndex.value === -1) {\n      return toggleRowSelection(row);\n    }\n    const targetIndex = paginatedRows.value.indexOf(row);\n    mergeSelection(getRowsToSelect(targetIndex));\n    setPrevSelectedRowIndex(-1);\n  }\n  function toggleBulkSelection() {\n    if (allRowsSelected.value) {\n      unselectAllRows();\n    } else {\n      selectAllRows();\n    }\n    setPrevSelectedRowIndex(-1);\n  }\n  return {\n    ctrlSelectRow,\n    shiftSelectRows,\n    toggleRowSelection,\n    toggleBulkSelection,\n    isRowSelected,\n    noRowsSelected,\n    severalRowsSelected,\n    allRowsSelected\n  };\n};\nexport { useSelectableRow as a, useSelectableProps as u };","map":{"version":3,"names":["useSelectableProps","useSelectableProp","useItemsTrackByProp","modelValue","type","Array","selectMode","String","default","useSelectableRow","paginatedRows","props","emit","selectedItemsFallback","ref","selectedItemsSync","computed","get","value","set","prevSelectedRowIndex","watch","newSelectMode","oldSelectMode","setPrevSelectedRowIndex","currentSelectedItems","previousSelectedItems","immediate","getKey","source","getItemKey","itemsTrackBy","noRowsSelected","some","includes","allRowsSelected","length","every","severalRowsSelected","isRowSelected","row","selectAllRows","Set","map","unselectAllRows","paginatedRowsKeys","filter","item","selectRow","selectOnlyRow","unselectRow","index","findIndex","slice","rowInitialIndex","prevSelectedRow","find","initialIndex","indexOf","getRowsToSelect","targetIndex","start","end","Math","min","max","mergeSelection","rowsToSelect","rowsToSelectedItems","isInternalSelection","toggleRowSelection","selectable","ctrlSelectRow","shiftSelectRows","toggleBulkSelection"],"sources":["../../../../../../src/components/va-data-table/hooks/useSelectableRow.ts"],"sourcesContent":["import { Ref, computed, watch, ref, PropType, ExtractPropTypes } from 'vue'\n\nimport { getItemKey } from './useRows'\nimport { useSelectableProp, useItemsTrackByProp } from './useCommonProps'\n\nimport type { DataTableRow, DataTableItem, DataTableSelectMode, DataTableItemKey } from '../types'\n\nexport const useSelectableProps = {\n  ...useSelectableProp,\n  ...useItemsTrackByProp,\n  modelValue: { type: Array as PropType<(DataTableItem | DataTableItemKey)[]> },\n  selectMode: { type: String as PropType<DataTableSelectMode>, default: 'multiple' },\n}\n\nexport type TEmits = 'update:modelValue' | 'selectionChange'\nexport type TSelectionChange = {\n  currentSelectedItems: (DataTableItem | DataTableItemKey)[],\n  previousSelectedItems: (DataTableItem | DataTableItemKey)[],\n}\nexport type TSelectableEmits = (event: TEmits, arg: (DataTableItem | DataTableItemKey)[] | TSelectionChange) => void\n\nexport const useSelectableRow = (\n  paginatedRows: Ref<DataTableRow[]>,\n  props: ExtractPropTypes<typeof useSelectableProps>,\n  emit: TSelectableEmits,\n) => {\n  const selectedItemsFallback = ref<(DataTableItem | DataTableItemKey)[]>([])\n\n  const selectedItemsSync = computed<(DataTableItem | DataTableItemKey)[]>({\n    get () {\n      if (props.modelValue === undefined) {\n        return selectedItemsFallback.value\n      } else {\n        return props.modelValue\n      }\n    },\n\n    set (modelValue) {\n      if (props.modelValue === undefined) {\n        selectedItemsFallback.value = modelValue\n      }\n\n      emit('update:modelValue', modelValue)\n    },\n  })\n\n  const prevSelectedRowIndex = ref(-1)\n\n  // clear all the selected rows when the `select-mode`'s value changes from multiple to single\n  // (though it's safe enough to leave a selected item when changing from single to multiple\n  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {\n    if (newSelectMode === 'single' && oldSelectMode === 'multiple') {\n      selectedItemsSync.value = []\n      setPrevSelectedRowIndex(-1)\n    }\n  })\n\n  // watch for rows changes (happens when filtering is applied e.g.)\n  watch(paginatedRows, () => { setPrevSelectedRowIndex(-1) })\n\n  // emit the \"selection-change\" event each time the selection changes\n  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {\n    emit('selectionChange', {\n      currentSelectedItems,\n      previousSelectedItems,\n    })\n  }, { immediate: true })\n\n  // if user provide `props.itemsTrackBy !== ''` than `selectedItemsSync` and `props.modelValue`\n  // would be the array with keys (received from `props.itemsTrackBy`)\n  // else they would be the array with source (`DataTableItem` type)\n  const getKey = (source: DataTableItem) => getItemKey(source, props.itemsTrackBy)\n\n  const noRowsSelected = computed(() => (\n    !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source)))\n  ))\n\n  const allRowsSelected = computed(() => {\n    if (paginatedRows.value.length === 0) { return false }\n\n    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)))\n  })\n\n  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value)\n\n  function isRowSelected (row: DataTableRow) {\n    return selectedItemsSync.value.includes(getKey(row.source))\n  }\n\n  function selectAllRows () {\n    selectedItemsSync.value = [...new Set([\n      ...selectedItemsSync.value,\n      ...paginatedRows.value.map(row => getKey(row.source)),\n    ])]\n  }\n\n  function unselectAllRows () {\n    const paginatedRowsKeys = paginatedRows.value.map(row => getKey(row.source))\n\n    selectedItemsSync.value = selectedItemsSync.value\n      .filter((item) => !paginatedRowsKeys.includes(item))\n  }\n\n  // The one calling this function must guarantee that the row isn't already selected\n  function selectRow (row: DataTableRow) {\n    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)]\n  }\n\n  function selectOnlyRow (row: DataTableRow) {\n    selectedItemsSync.value = [getKey(row.source)]\n  }\n\n  // The one calling this function must guarantee that the row is selected\n  function unselectRow (row: DataTableRow) {\n    const index = selectedItemsSync.value.findIndex(item => item === getKey(row.source))\n\n    selectedItemsSync.value = [\n      ...selectedItemsSync.value.slice(0, index),\n      ...selectedItemsSync.value.slice(index + 1),\n    ]\n  }\n\n  function setPrevSelectedRowIndex (rowInitialIndex: number) {\n    if (rowInitialIndex === -1) {\n      prevSelectedRowIndex.value = -1\n    } else {\n      const prevSelectedRow = paginatedRows.value.find(row => row.initialIndex === rowInitialIndex)\n\n      prevSelectedRow\n        ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow)\n        : prevSelectedRowIndex.value = -1\n    }\n  }\n\n  function getRowsToSelect (targetIndex: number) {\n    let start\n    let end\n\n    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {\n      start = Math.min(prevSelectedRowIndex.value, targetIndex)\n      end = Math.max(prevSelectedRowIndex.value, targetIndex)\n    } else {\n      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex)\n      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex)\n    }\n\n    return paginatedRows.value.slice(start, end + 1)\n  }\n\n  function mergeSelection (rowsToSelect: DataTableRow[]) {\n    const rowsToSelectedItems = rowsToSelect.map(row => getKey(row.source))\n\n    if (noRowsSelected.value) {\n      selectedItemsSync.value = rowsToSelectedItems\n      return\n    }\n\n    const isInternalSelection = rowsToSelectedItems.every(item => selectedItemsSync.value.includes(item))\n\n    if (isInternalSelection) {\n      selectedItemsSync.value = selectedItemsSync.value.filter(item => !rowsToSelectedItems.includes(item))\n      return\n    }\n\n    selectedItemsSync.value = [...new Set([\n      ...selectedItemsSync.value,\n      ...rowsToSelectedItems,\n    ])]\n  }\n\n  function toggleRowSelection (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    if (isRowSelected(row)) {\n      unselectRow(row)\n      props.selectMode === 'single' ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex)\n    } else {\n      props.selectMode === 'single' ? selectOnlyRow(row) : selectRow(row)\n      setPrevSelectedRowIndex(row.initialIndex)\n    }\n  }\n\n  function ctrlSelectRow (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    toggleRowSelection(row)\n  }\n\n  function shiftSelectRows (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    if (props.selectMode === 'single' || prevSelectedRowIndex.value === -1) {\n      return toggleRowSelection(row)\n    }\n\n    const targetIndex = paginatedRows.value.indexOf(row)\n    mergeSelection(getRowsToSelect(targetIndex))\n    setPrevSelectedRowIndex(-1)\n  }\n\n  function toggleBulkSelection () {\n    if (allRowsSelected.value) {\n      unselectAllRows()\n    } else {\n      selectAllRows()\n    }\n\n    setPrevSelectedRowIndex(-1)\n  }\n\n  return {\n    ctrlSelectRow,\n    shiftSelectRows,\n    toggleRowSelection,\n    toggleBulkSelection,\n    isRowSelected,\n    noRowsSelected,\n    severalRowsSelected,\n    allRowsSelected,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}