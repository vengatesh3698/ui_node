{"ast":null,"code":"import { defineComponent, shallowRef, ref, computed, watch } from \"vue\";\nimport { d as debounce } from \"../../../vendor-fff696df.mjs\";\nimport { s as sleep } from \"../../utils/sleep-94ff03e6.mjs\";\nimport { u as useScroll } from \"./hooks/useScroll-4d9a2b3d.mjs\";\nimport { V as VaProgressCircle } from \"../va-progress-circle/index-655f5cb0.mjs\";\nimport { u as useComponentPresetProp } from \"../../composables/useComponentPreset-0dfbd395.mjs\";\nimport { u as useColors } from \"../../composables/useColors-f23d24ff.mjs\";\nconst _sfc_main = defineComponent({\n  name: \"VaInfiniteScroll\",\n  components: {\n    VaProgressCircle\n  },\n  props: {\n    ...useComponentPresetProp,\n    load: {\n      type: Function,\n      required: true\n    },\n    offset: {\n      type: Number,\n      default: 500\n    },\n    reverse: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    scrollTarget: {\n      type: [String, Object],\n      default: void 0\n    },\n    debounce: {\n      type: Number,\n      default: 100\n    },\n    tag: {\n      type: String,\n      default: \"div\"\n    }\n  },\n  emits: [\"onload\", \"onerror\"],\n  setup(props, {\n    emit\n  }) {\n    const element = shallowRef();\n    const spinnerSlotContainer = shallowRef();\n    const fetching = ref(false);\n    const error = ref(false);\n    const forcedScrolling = ref(false);\n    const debouncedLoad = ref();\n    const notScrolledContentBeforeLoad = ref(0);\n    const prevScrollTop = ref(0);\n    const scrollTargetElement = computed(() => {\n      var _a;\n      let target;\n      if (typeof props.scrollTarget === \"string\") {\n        target = document.querySelector(props.scrollTarget);\n      } else {\n        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);\n      }\n      return target || document.body;\n    });\n    const {\n      addScrollListener,\n      removeScrollListener\n    } = useScroll(props, scrollTargetElement, debouncedLoad);\n    const {\n      getColor\n    } = useColors();\n    const spinnerColor = computed(() => {\n      return error.value ? getColor(\"danger\") : getColor(\"primary\");\n    });\n    const spinnerHeight = computed(() => {\n      var _a;\n      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;\n    });\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value;\n    });\n    const stop = () => {\n      if (props.disabled) {\n        return;\n      }\n      fetching.value = false;\n      removeScrollListener();\n    };\n    const resume = () => {\n      if (props.disabled) {\n        return;\n      }\n      addScrollListener();\n    };\n    const onLoad = () => {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = scrollTargetElement.value;\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;\n      const scrollDelta = scrollTop - prevScrollTop.value;\n      prevScrollTop.value = scrollTop;\n      if (props.disabled || error.value || fetching.value) {\n        return;\n      }\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false;\n        return;\n      }\n      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;\n      if (isReverseScrollDirection) {\n        return;\n      }\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;\n      if (offset > computedOffset.value) {\n        return;\n      }\n      fetching.value = true;\n      props.load().then(finishLoading).catch(onError);\n    };\n    const forceSetScrollTopToTarget = value => {\n      forcedScrolling.value = true;\n      scrollTargetElement.value.scrollTop = value;\n    };\n    const updateTargetElementScrollTop = () => {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = scrollTargetElement.value;\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value;\n        if (isScrolledUp && isSpinnerHidden) {\n          return;\n        }\n        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);\n      }\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);\n      }\n    };\n    const finishLoading = () => {\n      updateTargetElementScrollTop();\n      fetching.value = false;\n      emit(\"onload\");\n    };\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop();\n      forcedScrolling.value = false;\n      error.value = false;\n      fetching.value = false;\n      emit(\"onerror\");\n    };\n    const onError = () => {\n      stop();\n      error.value = true;\n      sleep(1200).then(stopErrorDisplay).then(resume);\n    };\n    watch(() => props.debounce, value => {\n      debouncedLoad.value = debounce(onLoad, value);\n    }, {\n      immediate: true\n    });\n    watch(() => props.disabled, value => {\n      value ? stop() : resume();\n    });\n    return {\n      element,\n      spinnerSlotContainer,\n      spinnerColor,\n      fetching\n    };\n  }\n});\nexport { _sfc_main as _ };\nimport '../../../VaInfiniteScroll.css';","map":{"version":3,"names":["_sfc_main","defineComponent","name","components","VaProgressCircle","props","useComponentPresetProp","load","type","Function","required","offset","Number","default","reverse","Boolean","disabled","scrollTarget","String","Object","debounce","tag","emits","setup","emit","element","shallowRef","spinnerSlotContainer","fetching","ref","error","forcedScrolling","debouncedLoad","notScrolledContentBeforeLoad","prevScrollTop","scrollTargetElement","computed","target","document","querySelector","_a","value","parentElement","body","addScrollListener","removeScrollListener","useScroll","getColor","useColors","spinnerColor","spinnerHeight","offsetHeight","computedOffset","stop","resume","onLoad","scrollTop","scrollHeight","clientHeight","scrollDelta","isReverseScrollDirection","then","finishLoading","catch","onError","forceSetScrollTopToTarget","updateTargetElementScrollTop","isScrolledUp","isSpinnerHidden","stopErrorDisplay","sleep","watch","immediate"],"sources":["../../../../../src/components/va-infinite-scroll/VaInfiniteScroll.vue"],"sourcesContent":["<template>\n  <component\n    :is=\"$props.tag as 'div'\"\n    ref=\"element\"\n    role=\"feed\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    :aria-busy=\"fetching\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      ref=\"spinnerSlotContainer\"\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n    >\n      <slot\n        v-if=\"!$props.disabled\"\n        name=\"loading\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, shallowRef, watch } from 'vue'\nimport debounce from 'lodash/debounce.js'\n\nimport { sleep } from '../../utils/sleep'\nimport { useColors } from '../../composables'\nimport { useScroll } from './hooks/useScroll'\n\nimport { VaProgressCircle } from '../va-progress-circle'\nimport { useComponentPresetProp } from '../../composables/useComponentPreset'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    ...useComponentPresetProp,\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [String, Object] as PropType<string | HTMLElement>, default: undefined },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n    const spinnerSlotContainer = shallowRef<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { getColor } = useColors()\n\n    const spinnerColor = computed(() => {\n      return error.value ? getColor('danger') : getColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n"],"mappings":";;;;;;;AA4CA,MAAAA,SAAA,GAAeC,eAAA,CAAgB;EAC7BC,IAAA,EAAM;EAENC,UAAA,EAAY;IAAEC;EAAiB;EAE/BC,KAAA,EAAO;IACL,GAAGC,sBAAA;IACHC,IAAA,EAAM;MAAEC,IAAA,EAAMC,QAAA;MAAUC,QAAA,EAAU;IAAK;IACvCC,MAAA,EAAQ;MAAEH,IAAA,EAAMI,MAAA;MAAQC,OAAA,EAAS;IAAI;IACrCC,OAAA,EAAS;MAAEN,IAAA,EAAMO,OAAA;MAASF,OAAA,EAAS;IAAM;IACzCG,QAAA,EAAU;MAAER,IAAA,EAAMO,OAAA;MAASF,OAAA,EAAS;IAAM;IAC1CI,YAAA,EAAc;MAAET,IAAA,EAAM,CAACU,MAAA,EAAQC,MAAM;MAAqCN,OAAA,EAAS;IAAU;IAC7FO,QAAA,EAAU;MAAEZ,IAAA,EAAMI,MAAA;MAAQC,OAAA,EAAS;IAAI;IACvCQ,GAAA,EAAK;MAAEb,IAAA,EAAMU,MAAA;MAAQL,OAAA,EAAS;IAAM;EACtC;EAEAS,KAAA,EAAO,CAAC,UAAU,SAAS;EAE3BC,MAAOlB,KAAA,EAAO;IAAEmB;EAAA,GAAQ;IACtB,MAAMC,OAAA,GAAUC,UAAA;IAChB,MAAMC,oBAAA,GAAuBD,UAAA;IAEvB,MAAAE,QAAA,GAAWC,GAAA,CAAI,KAAK;IACpB,MAAAC,KAAA,GAAQD,GAAA,CAAI,KAAK;IACjB,MAAAE,eAAA,GAAkBF,GAAA,CAAI,KAAK;IACjC,MAAMG,aAAA,GAAgBH,GAAA;IAChB,MAAAI,4BAAA,GAA+BJ,GAAA,CAAI,CAAC;IACpC,MAAAK,aAAA,GAAgBL,GAAA,CAAI,CAAC;IAErB,MAAAM,mBAAA,GAAsBC,QAAA,CAAsB,MAAM;;MAClD,IAAAC,MAAA;MAEA,WAAOhC,KAAA,CAAMY,YAAA,KAAiB,UAAU;QACjCoB,MAAA,GAAAC,QAAA,CAASC,aAAA,CAAclC,KAAA,CAAMY,YAAY;MAAA,OAC7C;QACIoB,MAAA,GAAAhC,KAAA,CAAMY,YAAA,MAAgBuB,EAAA,GAAAf,OAAA,CAAQgB,KAAA,KAAR,gBAAAD,EAAA,CAAeE,aAAA;MAChD;MAEA,OAAQL,MAAA,IAAUC,QAAA,CAASK,IAAA;IAAA,CAC5B;IAEK;MACJC,iBAAA;MACAC;IACE,IAAAC,SAAA,CAAUzC,KAAA,EAAO8B,mBAAA,EAAqBH,aAAa;IAEjD;MAAEe;IAAA,IAAaC,SAAA;IAEf,MAAAC,YAAA,GAAeb,QAAA,CAAS,MAAM;MAClC,OAAON,KAAA,CAAMW,KAAA,GAAQM,QAAA,CAAS,QAAQ,IAAIA,QAAA,CAAS,SAAS;IAAA,CAC7D;IAEK,MAAAG,aAAA,GAAgBd,QAAA,CAAS,MAAM;;MAC5B,SAAAI,EAAA,GAAAb,oBAAA,CAAqBc,KAAA,KAArB,gBAAAD,EAAA,CAA4BW,YAAA,KAAgB;IAAA,CACpD;IAEK,MAAAC,cAAA,GAAiBhB,QAAA,CAAS,MAAM;MAC7B,OAAA/B,KAAA,CAAMM,MAAA,GAASuC,aAAA,CAAcT,KAAA;IAAA,CACrC;IAED,MAAMY,IAAA,GAAOA,CAAA,KAAM;MACjB,IAAIhD,KAAA,CAAMW,QAAA,EAAU;QAAE;MAAO;MAE7BY,QAAA,CAASa,KAAA,GAAQ;MACII,oBAAA;IAAA;IAGvB,MAAMS,MAAA,GAASA,CAAA,KAAM;MACnB,IAAIjD,KAAA,CAAMW,QAAA,EAAU;QAAE;MAAO;MAEX4B,iBAAA;IAAA;IAGpB,MAAMW,MAAA,GAASA,CAAA,KAAM;MACnB,MAAM;QAAEC,SAAA;QAAWC,YAAA;QAAcC;MAAA,IAAiBvB,mBAAA,CAAoBM,KAAA;MACtER,4BAAA,CAA6BQ,KAAA,GAAQgB,YAAA,GAAeD,SAAA;MAC9C,MAAAG,WAAA,GAAcH,SAAA,GAAYtB,aAAA,CAAcO,KAAA;MAC9CP,aAAA,CAAcO,KAAA,GAAQe,SAAA;MAEtB,IAAInD,KAAA,CAAMW,QAAA,IAAYc,KAAA,CAAMW,KAAA,IAASb,QAAA,CAASa,KAAA,EAAO;QAAE;MAAO;MAE9D,IAAIV,eAAA,CAAgBU,KAAA,EAAO;QACzBV,eAAA,CAAgBU,KAAA,GAAQ;QACxB;MACF;MAEM,MAAAmB,wBAAA,GAA4BvD,KAAA,CAAMS,OAAA,IAAW6C,WAAA,GAAc,KAAO,CAACtD,KAAA,CAAMS,OAAA,IAAW6C,WAAA,GAAc;MACxG,IAAIC,wBAAA,EAA0B;QAAE;MAAO;MAEvC,MAAMjD,MAAA,GAASN,KAAA,CAAMS,OAAA,GAAU0C,SAAA,GAAYC,YAAA,GAAeD,SAAA,GAAYE,YAAA;MAClE,IAAA/C,MAAA,GAASyC,cAAA,CAAeX,KAAA,EAAO;QAAE;MAAO;MAE5Cb,QAAA,CAASa,KAAA,GAAQ;MAEjBpC,KAAA,CAAME,IAAA,GACHsD,IAAA,CAAKC,aAAa,EAClBC,KAAA,CAAMC,OAAO;IAAA;IAGZ,MAAAC,yBAAA,GAA6BxB,KAAA,IAAkB;MACnDV,eAAA,CAAgBU,KAAA,GAAQ;MACxBN,mBAAA,CAAoBM,KAAA,CAAMe,SAAA,GAAYf,KAAA;IAAA;IAGxC,MAAMyB,4BAAA,GAA+BA,CAAA,KAAM;MACzC,MAAM;QAAEV,SAAA;QAAWC,YAAA;QAAcC;MAAA,IAAiBvB,mBAAA,CAAoBM,KAAA;MAEtE,IAAIpC,KAAA,CAAMS,OAAA,EAAS;QACX,MAAAqD,YAAA,GAAeV,YAAA,GAAeD,SAAA,GAAYvB,4BAAA,CAA6BQ,KAAA;QACvE,MAAA2B,eAAA,GAAkBZ,SAAA,IAAaN,aAAA,CAAcT,KAAA;QAEnD,IAAI0B,YAAA,IAAgBC,eAAA,EAAiB;UAAE;QAAO;QAE7CX,YAAA,GAAexB,4BAAA,CAA6BQ,KAAA,GAAQS,aAAA,CAAcT,KAAA,GAC/DwB,yBAAA,CAA0BR,YAAA,GAAexB,4BAAA,CAA6BQ,KAAK,IAC3EwB,yBAAA,CAA0Bf,aAAA,CAAcT,KAAK;MACnD;MAEI,KAACpC,KAAA,CAAMS,OAAA,EAAS;QAClB,MAAMsD,eAAA,GAAkBX,YAAA,GAAeD,SAAA,GAAYE,YAAA,IAAgBR,aAAA,CAAcT,KAAA;QACjF,CAAC2B,eAAA,IAAmBH,yBAAA,CAA0BR,YAAA,GAAeC,YAAA,GAAeR,aAAA,CAAcT,KAAK;MACjG;IAAA;IAGF,MAAMqB,aAAA,GAAgBA,CAAA,KAAM;MACGI,4BAAA;MAC7BtC,QAAA,CAASa,KAAA,GAAQ;MACjBjB,IAAA,CAAK,QAAQ;IAAA;IAGf,MAAM6C,gBAAA,GAAmBA,CAAA,KAAM;MACAH,4BAAA;MAC7BnC,eAAA,CAAgBU,KAAA,GAAQ;MACxBX,KAAA,CAAMW,KAAA,GAAQ;MACdb,QAAA,CAASa,KAAA,GAAQ;MACjBjB,IAAA,CAAK,SAAS;IAAA;IAGhB,MAAMwC,OAAA,GAAUA,CAAA,KAAM;MACfX,IAAA;MACLvB,KAAA,CAAMW,KAAA,GAAQ;MAEd6B,KAAA,CAAM,IAAI,EACPT,IAAA,CAAKQ,gBAAgB,EACrBR,IAAA,CAAKP,MAAM;IAAA;IAGhBiB,KAAA,CAAM,MAAMlE,KAAA,CAAMe,QAAA,EAAWqB,KAAA,IAAU;MACvBT,aAAA,CAAAS,KAAA,GAAQrB,QAAA,CAASmC,MAAA,EAAQd,KAAK;IAAA,GAC3C;MAAE+B,SAAA,EAAW;IAAA,CAAM;IAEtBD,KAAA,CAAM,MAAMlE,KAAA,CAAMW,QAAA,EAAWyB,KAAA,IAAU;MAC7BA,KAAA,GAAAY,IAAA,KAASC,MAAA;IAAO,CACzB;IAEM;MACL7B,OAAA;MACAE,oBAAA;MAEAsB,YAAA;MACArB;IAAA;EAEJ;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}