{"ast":null,"code":"import { l as isObject } from \"../../vendor-fff696df.mjs\";\nimport { i as isNilValue } from \"./isNilValue-745d19e7.mjs\";\nconst getNestedValue = (option, propsArray) => {\n  if (propsArray.length === 0) {\n    return option;\n  }\n  const nestedItem = option[propsArray[0]];\n  if (!isObject(nestedItem)) {\n    if (propsArray.length === 1) {\n      return nestedItem;\n    }\n    return void 0;\n  }\n  return getNestedValue(nestedItem, propsArray.slice(1));\n};\nconst getValueByPath = (option, prop) => {\n  if (prop in option) {\n    return option[prop];\n  }\n  prop = prop.replace(/^\\./, \"\");\n  return getNestedValue(option, prop.split(\".\"));\n};\nconst getValueByKey = (option, prop) => {\n  if (isNilValue(option) || typeof option !== \"object\" || Array.isArray(option)) {\n    return void 0;\n  }\n  if (!prop) {\n    return option;\n  }\n  if (typeof prop === \"string\") {\n    return getValueByPath(option, prop);\n  }\n  if (typeof prop === \"function\") {\n    return prop(option);\n  }\n  return option;\n};\nexport { getValueByKey as a, getValueByPath as g };","map":{"version":3,"names":["getNestedValue","option","propsArray","length","nestedItem","isObject","slice","getValueByPath","prop","replace","split","getValueByKey","isNilValue","Array","isArray"],"sources":["../../../../src/utils/value-by-key.ts"],"sourcesContent":["import isObject from 'lodash/isObject.js'\n\nimport { isNilValue } from './isNilValue'\n\ntype GetTypeByPath<T extends Record<string, any>, K extends string> =\nK extends keyof T\n    ? T[K]\n    : K extends `${infer TKey}.${infer Rest}`\n        ? GetTypeByPath<T[TKey], Rest>\n        : undefined\n\n/**\n * Resolve the path to the target property inside the provided object.\n *\n * @param option - Object to look properties inside.\n * @param propsArray - Ordered array of strings, where each string should correspond to one of the property names at the current level of the object.\n */\nexport const getNestedValue = (option: Record<string, any>, propsArray: string[]): any => {\n  if (propsArray.length === 0) { return option }\n\n  const nestedItem = option[propsArray[0]]\n  if (!isObject(nestedItem)) {\n    if (propsArray.length === 1) {\n      return nestedItem\n    }\n    return undefined\n  }\n  return getNestedValue(nestedItem, propsArray.slice(1))\n}\n\n/**\n * Finds value in the object using string with dots 'key.key.key'\n *\n * @param option - Object to look properties inside.\n * @param prop - String that contains a path to the property.\n */\nexport const getValueByPath = <\n  Key extends string, T extends Record<string | Key, unknown>\n>(option: T, prop: string | Key): GetTypeByPath<T, Key> => {\n  if (prop in option) {\n    return (option)[prop] as GetTypeByPath<T, Key>\n  }\n  prop = prop.replace(/^\\./, '') // remove first point symbol\n  return getNestedValue(option, prop.split('.'))\n}\n\n/**\n * Finds value of nested property inside an object.\n *\n * @param option - Object to look properties inside.\n * @param prop - String or function used to find nested property.\n */\nexport const getValueByKey = <\n  Option extends Record<string, unknown>, R\n>(\n    option: Option | string | boolean | number | ((...args: any[]) => any),\n    prop: string | ((option: Option) => R),\n  ) => {\n  if (isNilValue(option) || typeof option !== 'object' || Array.isArray(option)) { return undefined }\n\n  if (!prop) { return option }\n  if (typeof prop === 'string') { return getValueByPath(option, prop) }\n  if (typeof prop === 'function') { return prop(option) }\n\n  // if `prop` has different to string or function type and can't be processed\n  return option\n}\n"],"mappings":";;AAiBa,MAAAA,cAAA,GAAiBA,CAACC,MAAA,EAA6BC,UAAA,KAA8B;EACpF,IAAAA,UAAA,CAAWC,MAAA,KAAW,GAAG;IAAS,OAAAF,MAAA;EAAO;EAE7C,MAAMG,UAAA,GAAaH,MAAA,CAAOC,UAAA,CAAW,CAAC,CAAC;EACnC,KAACG,QAAA,CAASD,UAAU,GAAG;IACrB,IAAAF,UAAA,CAAWC,MAAA,KAAW,GAAG;MACpB,OAAAC,UAAA;IACT;IACO;EACT;EACA,OAAOJ,cAAA,CAAeI,UAAA,EAAYF,UAAA,CAAWI,KAAA,CAAM,CAAC,CAAC;AACvD;AAQa,MAAAC,cAAA,GAAiBA,CAE5BN,MAAA,EAAWO,IAAA,KAA8C;EACzD,IAAIA,IAAA,IAAQP,MAAA,EAAQ;IAClB,OAAQA,MAAA,CAAQO,IAAI;EACtB;EACOA,IAAA,GAAAA,IAAA,CAAKC,OAAA,CAAQ,OAAO,EAAE;EAC7B,OAAOT,cAAA,CAAeC,MAAA,EAAQO,IAAA,CAAKE,KAAA,CAAM,GAAG,CAAC;AAC/C;AAQa,MAAAC,aAAA,GAAgBA,CAGzBV,MAAA,EACAO,IAAA,KACG;EACD,IAAAI,UAAA,CAAWX,MAAM,KAAK,OAAOA,MAAA,KAAW,YAAYY,KAAA,CAAMC,OAAA,CAAQb,MAAM,GAAG;IAAS;EAAU;EAElG,IAAI,CAACO,IAAA,EAAM;IAAS,OAAAP,MAAA;EAAO;EACvB,WAAOO,IAAA,KAAS,UAAU;IAAS,OAAAD,cAAA,CAAeN,MAAA,EAAQO,IAAI;EAAE;EAChE,WAAOA,IAAA,KAAS,YAAY;IAAE,OAAOA,IAAA,CAAKP,MAAM;EAAE;EAG/C,OAAAA,MAAA;AACT"},"metadata":{},"sourceType":"module","externalDependencies":[]}