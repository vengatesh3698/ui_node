{"ast":null,"code":"import { computed, unref } from \"vue\";\nimport { g as isFunction, k as kebabCase } from \"../../vendor-fff696df.mjs\";\nimport { i as isDev } from \"../utils/env-da4fbb25.mjs\";\nconst useBem = (prefix, modifiers) => {\n  if (isDev && !prefix) {\n    console.warn('You must pass the @param \"prefix\" to the useBem hook!');\n  }\n  const modifiersList = computed(() => isFunction(modifiers) ? modifiers() : unref(modifiers));\n  const computedBemClassesObject = computed(() => {\n    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {\n      if (value) {\n        classesObj[`${prefix}--${kebabCase(modifierName)}`] = true;\n      }\n      return classesObj;\n    }, {});\n  });\n  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));\n  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(\" \"));\n  return new Proxy({}, {\n    ownKeys() {\n      return Reflect.ownKeys(computedBemClassesObject.value);\n    },\n    getOwnPropertyDescriptor(_, key) {\n      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);\n    },\n    get(_, key, receiver) {\n      switch (key) {\n        case \"asArray\":\n          return computedBemClassesArray;\n        case \"asString\":\n          return computedBemClassesString;\n        case \"asObject\":\n          return computedBemClassesObject;\n        default:\n          return Reflect.get(computedBemClassesObject.value, key, receiver);\n      }\n    }\n  });\n};\nexport { useBem as u };","map":{"version":3,"names":["useBem","prefix","modifiers","isDev","console","warn","modifiersList","computed","isFunction","unref","computedBemClassesObject","Object","entries","reduce","classesObj","modifierName","value","kebabCase","computedBemClassesArray","keys","computedBemClassesString","join","Proxy","ownKeys","Reflect","getOwnPropertyDescriptor","_","key","get","receiver"],"sources":["../../../../src/composables/useBem.ts"],"sourcesContent":["import { computed, Ref, unref, ComputedRef } from 'vue'\n\nimport isFunction from 'lodash/isFunction.js'\nimport kebab from 'lodash/kebabCase.js'\n\nimport { isDev } from '../utils/env'\n\ntype Key<Prefix extends string, ModifierKey extends string> = `${Prefix}--${ModifierKey | string}`\n\ntype ClassesObject<Key extends string> = Record<Key, boolean>\n\ntype ComputedClasses<Key extends string> = ClassesObject<Key> & {\n  // TODO: How to remove it from spread?\n  readonly asObject: ComputedRef<ClassesObject<Key>>\n  readonly asArray: ComputedRef<Key[]>\n  readonly asString: ComputedRef<string>\n}\n\n/**\n * @description creates BEM modifiers based on transferred prefix (base BEM class) & modifiers list.\n * camelCase modifiers names will be transformed to the kebab-case.\n * @param prefix string that classes start with (base BEM class).\n * @param modifiers list of options that will serve as state BEM modifiers.\n * @returns computed classes starting with \"prefix\" and ending with form state BEM modifier.\n * @example\n *  const result = useBem('va-component', computed(() => pick(props, ['success, noError'])))\n *  // if success & noError are `true`\n *  { ...result }: { 'va-component--success': true, va-component--no-error: true }\n *  result.asObject.value: { 'va-component--success': true, va-component--no-error: true }\n *  result.asArray.value: ['va-component--success', 'va-component--no-error']\n *  result.asString.value: 'va-component--success va-component--no-error'\n */\nexport const useBem = <ModifierKey extends string, Prefix extends string>(\n  prefix: Prefix,\n  modifiers: Record<ModifierKey, boolean> | Ref<Record<ModifierKey, boolean>> | (() => Record<ModifierKey, boolean>),\n) => {\n  if (isDev && !prefix) {\n    console.warn('You must pass the @param \"prefix\" to the useBem hook!')\n  }\n\n  const modifiersList = computed(() => isFunction(modifiers) ? modifiers() : unref(modifiers))\n\n  const computedBemClassesObject = computed(() => {\n    return Object\n      .entries(unref(modifiersList))\n      .reduce((classesObj: Record<string, boolean>, [modifierName, value]) => {\n        if (value) { classesObj[`${prefix}--${kebab(modifierName)}`] = true }\n        return classesObj\n      }, {})\n  })\n\n  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value))\n\n  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(' '))\n\n  return new Proxy({}, {\n    ownKeys () {\n      return Reflect.ownKeys(computedBemClassesObject.value)\n    },\n    getOwnPropertyDescriptor (_, key) {\n      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key)\n    },\n    get (_, key: string, receiver: any) {\n      switch (key) {\n        case 'asArray':\n          return computedBemClassesArray\n        case 'asString':\n          return computedBemClassesString\n        case 'asObject':\n          return computedBemClassesObject\n        default:\n          return Reflect.get(computedBemClassesObject.value, key, receiver)\n      }\n    },\n  }) as ComputedClasses<Key<Prefix, ModifierKey>>\n}\n"],"mappings":";;;AAgCa,MAAAA,MAAA,GAASA,CACpBC,MAAA,EACAC,SAAA,KACG;EACC,IAAAC,KAAA,IAAS,CAACF,MAAA,EAAQ;IACpBG,OAAA,CAAQC,IAAA,CAAK,uDAAuD;EACtE;EAEM,MAAAC,aAAA,GAAgBC,QAAA,CAAS,MAAMC,UAAA,CAAWN,SAAS,IAAIA,SAAA,KAAcO,KAAA,CAAMP,SAAS,CAAC;EAErF,MAAAQ,wBAAA,GAA2BH,QAAA,CAAS,MAAM;IAC9C,OAAOI,MAAA,CACJC,OAAA,CAAQH,KAAA,CAAMH,aAAa,CAAC,EAC5BO,MAAA,CAAO,CAACC,UAAA,EAAqC,CAACC,YAAA,EAAcC,KAAK,MAAM;MACtE,IAAIA,KAAA,EAAO;QAAEF,UAAA,CAAW,GAAGb,MAAA,KAAWgB,SAAA,CAAMF,YAAY,GAAG,IAAI;MAAK;MAC7D,OAAAD,UAAA;IACT,GAAG,CAAE;EAAA,CACR;EAED,MAAMI,uBAAA,GAA0BX,QAAA,CAAS,MAAMI,MAAA,CAAOQ,IAAA,CAAKT,wBAAA,CAAyBM,KAAK,CAAC;EAE1F,MAAMI,wBAAA,GAA2Bb,QAAA,CAAS,MAAMW,uBAAA,CAAwBF,KAAA,CAAMK,IAAA,CAAK,GAAG,CAAC;EAEhF,WAAIC,KAAA,CAAM,IAAI;IACnBC,QAAA,EAAW;MACF,OAAAC,OAAA,CAAQD,OAAA,CAAQb,wBAAA,CAAyBM,KAAK;IACvD;IACAS,yBAA0BC,CAAA,EAAGC,GAAA,EAAK;MAChC,OAAOH,OAAA,CAAQC,wBAAA,CAAyBf,wBAAA,CAAyBM,KAAA,EAAOW,GAAG;IAC7E;IACAC,IAAKF,CAAA,EAAGC,GAAA,EAAaE,QAAA,EAAe;MAClC,QAAQF,GAAA;QACN,KAAK;UACI,OAAAT,uBAAA;QACT,KAAK;UACI,OAAAE,wBAAA;QACT,KAAK;UACI,OAAAV,wBAAA;QACT;UACE,OAAOc,OAAA,CAAQI,GAAA,CAAIlB,wBAAA,CAAyBM,KAAA,EAAOW,GAAA,EAAKE,QAAQ;MACpE;IACF;EAAA,CACD;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}