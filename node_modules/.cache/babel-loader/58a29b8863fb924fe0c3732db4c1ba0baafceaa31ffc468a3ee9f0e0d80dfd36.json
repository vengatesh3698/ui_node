{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { onMounted, onBeforeUnmount, ref, computed, watch } from \"vue\";\nconst useCarouselAnimation = (props, currentSlide) => {\n  let animationInterval = -1;\n  let direction = 1;\n  const start = () => {\n    if (!props.autoscroll) {\n      return;\n    }\n    clearInterval(animationInterval);\n    animationInterval = setInterval(() => {\n      if (props.infinite) {\n        currentSlide.value += 1;\n        if (currentSlide.value >= props.items.length) {\n          currentSlide.value = 0;\n        }\n      } else {\n        if (currentSlide.value <= 0) {\n          direction = 1;\n        }\n        if (currentSlide.value >= props.items.length - 1) {\n          direction = -1;\n        }\n        currentSlide.value += direction;\n      }\n    }, props.autoscrollInterval);\n  };\n  let pauseTimeout;\n  const pause = () => {\n    if (!props.autoscroll) {\n      return;\n    }\n    clearInterval(animationInterval);\n    pauseTimeout = setTimeout(() => {\n      start();\n      clearTimeout(pauseTimeout);\n    }, props.autoscrollPauseDuration);\n  };\n  const stop = () => {\n    clearInterval(animationInterval);\n    clearTimeout(pauseTimeout);\n  };\n  onMounted(() => start());\n  onBeforeUnmount(() => stop());\n  const withPause = fn => {\n    return (...args) => {\n      pause();\n      fn(...args);\n    };\n  };\n  const slidesContainerStyle = ref({\n    transition: void 0\n  });\n  const sliderToBeShown = ref(0);\n  const computedSlidesStyle = computed(() => {\n    if (props.effect === \"fade\") {\n      return {\n        ...slidesContainerStyle.value,\n        transition: \"none\"\n      };\n    }\n    if (props.vertical) {\n      return {\n        ...slidesContainerStyle.value,\n        transform: `translateY(${sliderToBeShown.value * -100}%)`\n      };\n    }\n    return {\n      ...slidesContainerStyle.value,\n      transform: `translateX(${sliderToBeShown.value * -100}%)`\n    };\n  });\n  const animator = {\n    isAnimating: false,\n    speed: 0.3,\n    order: [],\n    move(from, to) {\n      const last = props.items.length - 1;\n      const firstAfterLast = props.items.length;\n      if (to === 0 && from === last) {\n        this.order.push({\n          to: firstAfterLast\n        });\n        this.order.push({\n          to: 0,\n          animate: false\n        });\n      } else if (to === last && from === 0) {\n        this.order.push({\n          to: firstAfterLast,\n          animate: false\n        });\n        this.order.push({\n          to\n        });\n      } else {\n        this.order.push({\n          to\n        });\n      }\n      if (!this.isAnimating) {\n        this.runAnimation();\n      }\n    },\n    runAnimation() {\n      this.isAnimating = true;\n      const animation = this.order.shift();\n      if (!animation) {\n        this.isAnimating = false;\n        return;\n      }\n      sliderToBeShown.value = animation == null ? void 0 : animation.to;\n      if (animation.animate || animation.animate === void 0) {\n        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;\n        setTimeout(() => {\n          this.runAnimation();\n        }, this.speed * 1e3);\n      } else {\n        slidesContainerStyle.value.transition = \"none\";\n        setTimeout(() => {\n          this.runAnimation();\n        }, 16);\n      }\n    }\n  };\n  watch(currentSlide, (newValue, oldValue) => {\n    animator.move(oldValue, newValue);\n  });\n  const slides = computed(() => {\n    if (props.effect === \"fade\") {\n      return [props.items[currentSlide.value]];\n    }\n    if (props.infinite) {\n      return [...props.items, props.items[0]];\n    }\n    return props.items;\n  });\n  return {\n    start,\n    pause,\n    stop,\n    withPause,\n    computedSlidesStyle,\n    slides\n  };\n};\nexport { useCarouselAnimation as u };","map":{"version":3,"names":["useCarouselAnimation","props","currentSlide","animationInterval","direction","start","autoscroll","clearInterval","setInterval","infinite","value","items","length","autoscrollInterval","pauseTimeout","pause","setTimeout","clearTimeout","autoscrollPauseDuration","stop","onMounted","onBeforeUnmount","withPause","fn","args","slidesContainerStyle","ref","transition","sliderToBeShown","computedSlidesStyle","computed","effect","vertical","transform","animator","isAnimating","speed","order","move","from","to","last","firstAfterLast","push","animate","runAnimation","animation","shift","watch","newValue","oldValue","slides"],"sources":["../../../../../../src/components/va-carousel/hooks/useCarouselAnimation.ts"],"sourcesContent":["import { computed, onBeforeUnmount, onMounted, ref, Ref, watch } from 'vue'\n\nexport const useCarouselAnimation = (props: {\n  items: any[],\n  autoscrollInterval: number,\n  autoscrollPauseDuration: number,\n  autoscroll: boolean,\n  infinite: boolean,\n  effect: 'fade' | 'transition',\n  vertical: boolean,\n  fadeKeyframe: string,\n}, currentSlide: Ref<number>) => {\n  let animationInterval = -1\n  let direction = 1\n\n  const start = () => {\n    if (!props.autoscroll) { return }\n\n    clearInterval(animationInterval)\n    animationInterval = setInterval(() => {\n      if (props.infinite) {\n        currentSlide.value += 1\n        if (currentSlide.value >= props.items.length) { currentSlide.value = 0 }\n      } else {\n        if (currentSlide.value <= 0) { direction = 1 }\n        if (currentSlide.value >= props.items.length - 1) { direction = -1 }\n        currentSlide.value += direction\n      }\n    }, props.autoscrollInterval) as any\n  }\n\n  let pauseTimeout: number\n  const pause = () => {\n    if (!props.autoscroll) { return }\n\n    clearInterval(animationInterval)\n\n    pauseTimeout = setTimeout(() => {\n      start()\n      clearTimeout(pauseTimeout)\n    }, props.autoscrollPauseDuration) as any\n  }\n\n  const stop = () => {\n    clearInterval(animationInterval)\n    clearTimeout(pauseTimeout)\n  }\n\n  onMounted(() => start())\n  onBeforeUnmount(() => stop())\n\n  const withPause = <T extends (...args: any[]) => any>(fn: T) => {\n    return (...args: Parameters<T>) => { pause(); fn(...args) }\n  }\n\n  const slidesContainerStyle = ref<Record<string, any>>({\n    transition: undefined as string | undefined,\n  })\n\n  /**\n   * Used for infinite loop. In infinite loop additional first item is placed after all items.\n   * Use own currentSlider, which will not update model value if we need to show slide that placed after all items\n   */\n  const sliderToBeShown = ref(0)\n\n  const computedSlidesStyle = computed(() => {\n    if (props.effect === 'fade') {\n      return {\n        ...slidesContainerStyle.value,\n        transition: 'none',\n      }\n    }\n\n    if (props.vertical) {\n      return {\n        ...slidesContainerStyle.value,\n        transform: `translateY(${sliderToBeShown.value * -100}%)`,\n      }\n    }\n\n    return {\n      ...slidesContainerStyle.value,\n      transform: `translateX(${sliderToBeShown.value * -100}%)`,\n    }\n  })\n\n  const animator = {\n    isAnimating: false,\n\n    speed: 0.3,\n\n    order: [] as { to: number, animate?: boolean }[],\n\n    move (from: number, to: number) {\n      const last = props.items.length - 1\n      const firstAfterLast = props.items.length\n\n      if (to === 0 && from === last) {\n        this.order.push({ to: firstAfterLast })\n        this.order.push({ to: 0, animate: false })\n      } else if (to === last && from === 0) {\n        this.order.push({ to: firstAfterLast, animate: false })\n        this.order.push({ to })\n      } else {\n        this.order.push({ to })\n      }\n\n      if (!this.isAnimating) { this.runAnimation() }\n    },\n\n    runAnimation () {\n      this.isAnimating = true\n\n      const animation = this.order.shift()\n\n      if (!animation) { this.isAnimating = false; return }\n\n      sliderToBeShown.value = animation?.to\n\n      if (animation.animate || animation.animate === undefined) {\n        slidesContainerStyle.value.transition = `all ${this.speed}s linear`\n        setTimeout(() => { this.runAnimation() }, this.speed * 1000)\n      } else {\n        slidesContainerStyle.value.transition = 'none'\n        setTimeout(() => { this.runAnimation() }, 16)\n      }\n    },\n  }\n\n  watch(currentSlide, (newValue, oldValue) => {\n    animator.move(oldValue, newValue)\n  })\n\n  /** Animation should control how much slides to display */\n  const slides = computed(() => {\n    if (props.effect === 'fade') {\n      return [props.items[currentSlide.value]]\n    }\n\n    if (props.infinite) {\n      return [...props.items, props.items[0]]\n    }\n\n    return props.items\n  })\n\n  return {\n    start,\n    pause,\n    stop,\n    withPause,\n    computedSlidesStyle,\n    slides,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}