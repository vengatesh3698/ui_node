{"ast":null,"code":"import { ref } from \"vue\";\nimport { i as isDate } from \"../../../../vendor-fff696df.mjs\";\nconst defaultParseDateFunction = text => new Date(Date.parse(text));\nconst isValidDate = d => isDate(d) && !isNaN(d.getTime());\nconst useDateParser = props => {\n  const isMultipleDates = text => text.includes(props.delimiter);\n  const isRange = text => text.includes(props.rangeDelimiter);\n  const isValid = ref(true);\n  const parseDate = text => {\n    const splitDate = text.split(\".\");\n    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join(\"-\") : text;\n    const date = (props.parseDate || defaultParseDateFunction)(valueToParse);\n    isValid.value = isValidDate(date);\n    return date;\n  };\n  const parseDateInputValue = text => {\n    isValid.value = true;\n    if (props.parse) {\n      return props.parse(text, isValid);\n    }\n    if (isMultipleDates(text)) {\n      return text.split(props.delimiter).map(parseDate);\n    }\n    if (isRange(text)) {\n      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);\n      return {\n        start,\n        end\n      };\n    }\n    return parseDate(text);\n  };\n  return {\n    parseDateInputValue,\n    isValid\n  };\n};\nexport { defaultParseDateFunction as d, useDateParser as u };","map":{"version":3,"names":["defaultParseDateFunction","text","Date","parse","isValidDate","d","isDate","isNaN","getTime","useDateParser","props","isMultipleDates","includes","delimiter","isRange","rangeDelimiter","isValid","ref","parseDate","splitDate","split","valueToParse","length","reverse","join","date","value","parseDateInputValue","map","start","end"],"sources":["../../../../../../src/components/va-date-input/hooks/input-text-parser.ts"],"sourcesContent":["import { DateInputRange, DateInputValue } from './../types'\nimport { Ref, ref } from 'vue'\nimport isDate from 'lodash/isDate.js'\n\nexport const defaultParseDateFunction = (text: string) => new Date(Date.parse(text))\n\nconst isValidDate = (d: Date) => isDate(d) && !isNaN(d.getTime())\n\nexport const useDateParser = (props: {\n  parse?: (input: string, isValidRef?: Ref<boolean>) => DateInputValue,\n  parseDate?: (input: string) => Date,\n  delimiter: string,\n  rangeDelimiter: string,\n}) => {\n  const isMultipleDates = (text: string) => text.includes(props.delimiter)\n  const isRange = (text: string) => text.includes(props.rangeDelimiter)\n\n  const isValid = ref(true)\n\n  const parseDate = (text: string) => {\n    /**\n     * for american locales 01.02.2000 will be parsed as 02 Jan 2000 (not 01 Feb 2000)\n     * iso 8601 (YYYY-MM-DD) solves this problem\n     */\n    const splitDate = text.split('.')\n    const valueToParse = splitDate?.length === 3 ? splitDate.reverse().join('-') : text\n\n    const date = (props.parseDate || defaultParseDateFunction)(valueToParse)\n\n    isValid.value = isValidDate(date)\n\n    return date\n  }\n\n  const parseDateInputValue = (text: string) => {\n    isValid.value = true\n\n    if (props.parse) {\n      return props.parse(text, isValid)\n    }\n\n    if (isMultipleDates(text)) {\n      return text.split(props.delimiter).map(parseDate)\n    }\n\n    if (isRange(text)) {\n      const [start, end] = text.split(props.rangeDelimiter).map(parseDate)\n      return { start, end }\n    }\n\n    return parseDate(text)\n  }\n\n  return {\n    parseDateInputValue,\n    isValid,\n  }\n}\n"],"mappings":";;AAIa,MAAAA,wBAAA,GAA4BC,IAAA,IAAiB,IAAIC,IAAA,CAAKA,IAAA,CAAKC,KAAA,CAAMF,IAAI,CAAC;AAEnF,MAAMG,WAAA,GAAeC,CAAA,IAAYC,MAAA,CAAOD,CAAC,KAAK,CAACE,KAAA,CAAMF,CAAA,CAAEG,OAAA,EAAS;AAEnD,MAAAC,aAAA,GAAiBC,KAAA,IAKxB;EACJ,MAAMC,eAAA,GAAmBV,IAAA,IAAiBA,IAAA,CAAKW,QAAA,CAASF,KAAA,CAAMG,SAAS;EACvE,MAAMC,OAAA,GAAWb,IAAA,IAAiBA,IAAA,CAAKW,QAAA,CAASF,KAAA,CAAMK,cAAc;EAE9D,MAAAC,OAAA,GAAUC,GAAA,CAAI,IAAI;EAElB,MAAAC,SAAA,GAAajB,IAAA,IAAiB;IAK5B,MAAAkB,SAAA,GAAYlB,IAAA,CAAKmB,KAAA,CAAM,GAAG;IAC1B,MAAAC,YAAA,IAAeF,SAAA,oBAAAA,SAAA,CAAWG,MAAA,MAAW,IAAIH,SAAA,CAAUI,OAAA,CAAQ,EAAEC,IAAA,CAAK,GAAG,IAAIvB,IAAA;IAE/E,MAAMwB,IAAA,IAAQf,KAAA,CAAMQ,SAAA,IAAalB,wBAAA,EAA0BqB,YAAY;IAE/DL,OAAA,CAAAU,KAAA,GAAQtB,WAAA,CAAYqB,IAAI;IAEzB,OAAAA,IAAA;EAAA;EAGH,MAAAE,mBAAA,GAAuB1B,IAAA,IAAiB;IAC5Ce,OAAA,CAAQU,KAAA,GAAQ;IAEhB,IAAIhB,KAAA,CAAMP,KAAA,EAAO;MACR,OAAAO,KAAA,CAAMP,KAAA,CAAMF,IAAA,EAAMe,OAAO;IAClC;IAEI,IAAAL,eAAA,CAAgBV,IAAI,GAAG;MACzB,OAAOA,IAAA,CAAKmB,KAAA,CAAMV,KAAA,CAAMG,SAAS,EAAEe,GAAA,CAAIV,SAAS;IAClD;IAEI,IAAAJ,OAAA,CAAQb,IAAI,GAAG;MACX,OAAC4B,KAAA,EAAOC,GAAG,IAAI7B,IAAA,CAAKmB,KAAA,CAAMV,KAAA,CAAMK,cAAc,EAAEa,GAAA,CAAIV,SAAS;MAC5D;QAAEW,KAAA;QAAOC;MAAA;IAClB;IAEA,OAAOZ,SAAA,CAAUjB,IAAI;EAAA;EAGhB;IACL0B,mBAAA;IACAX;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}