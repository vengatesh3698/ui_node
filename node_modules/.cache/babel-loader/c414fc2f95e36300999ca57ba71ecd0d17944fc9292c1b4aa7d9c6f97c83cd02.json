{"ast":null,"code":"import { computed, ref, watch } from \"vue\";\nfunction useSyncProp(propName, props, emit, defaultValue) {\n  if (defaultValue === void 0) {\n    return [computed({\n      set(value) {\n        emit(`update:${propName}`, value);\n      },\n      get() {\n        return props[propName];\n      }\n    })];\n  }\n  const currentValue = props[propName];\n  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);\n  watch(() => props[propName], newVal => {\n    if (newVal === void 0) {\n      return;\n    }\n    statefulValue.value = newVal;\n  });\n  return [computed({\n    set(value) {\n      statefulValue.value = value;\n      emit(`update:${propName}`, value);\n    },\n    get() {\n      return props[propName] === void 0 ? statefulValue.value : props[propName];\n    }\n  })];\n}\nexport { useSyncProp as u };","map":{"version":3,"names":["useSyncProp","propName","props","emit","defaultValue","computed","set","value","get","currentValue","statefulValue","ref","watch","newVal"],"sources":["../../../../src/composables/useSyncProp.ts"],"sourcesContent":["import { ref, computed, watch, UnwrapRef } from 'vue'\n\n/**\n * Returns computed that emits update:${propName} on edit.\n *\n * @tutorial\n * ```\n * const [prop] = useSyncProp('name', props, emit)\n *\n * prop.value = 'New name'\n *\n * $nextTick(() => console.log(prop.value)) // 'New name'\n * ```\n *\n * @notice\n * Be careful, that property is not updating in current render\n * cycle. Be sure to use $nextTick if you need to use this property after change.\n */\nexport function useSyncProp<\n  T,\n  PropName extends string,\n  Props extends { [key in PropName]?: T },\n  Emit extends (event: any, newValue: Props[PropName]) => any,\n  ReturnValue extends NonNullable<Props[PropName]>\n> (propName: PropName, props: Props, emit: Emit, defaultValue?: ReturnValue) {\n  if (defaultValue === undefined) {\n    return [\n      computed<ReturnValue>({\n        set (value: ReturnValue) {\n          emit(`update:${propName}`, value)\n        },\n        get () {\n          return props[propName] as ReturnValue\n        },\n      }),\n    ]\n  }\n\n  const currentValue = props[propName] as ReturnValue\n  const statefulValue = ref(currentValue === undefined ? defaultValue : currentValue)\n\n  watch(() => props[propName], (newVal) => {\n    if (newVal === undefined) { return }\n\n    statefulValue.value = newVal as UnwrapRef<ReturnValue>\n  })\n\n  return [\n    computed<ReturnValue>({\n      set (value: ReturnValue) {\n        statefulValue.value = value as UnwrapRef<ReturnValue>\n        emit(`update:${propName}`, value)\n      },\n      get (): ReturnValue {\n        return (props[propName] === undefined ? statefulValue.value : props[propName]) as ReturnValue\n      },\n    }),\n  ]\n}\n"],"mappings":";AAkBO,SAASA,YAMbC,QAAA,EAAoBC,KAAA,EAAcC,IAAA,EAAYC,YAAA,EAA4B;EAC3E,IAAIA,YAAA,KAAiB,QAAW;IACvB,QACLC,QAAA,CAAsB;MACpBC,IAAKC,KAAA,EAAoB;QAClBJ,IAAA,WAAUF,QAAA,IAAYM,KAAK;MAClC;MACAC,IAAA,EAAO;QACL,OAAON,KAAA,CAAMD,QAAQ;MACvB;IAAA,CACD;EAEL;EAEM,MAAAQ,YAAA,GAAeP,KAAA,CAAMD,QAAQ;EACnC,MAAMS,aAAA,GAAgBC,GAAA,CAAIF,YAAA,KAAiB,SAAYL,YAAA,GAAeK,YAAY;EAElFG,KAAA,CAAM,MAAMV,KAAA,CAAMD,QAAQ,GAAIY,MAAA,IAAW;IACvC,IAAIA,MAAA,KAAW,QAAW;MAAE;IAAO;IAEnCH,aAAA,CAAcH,KAAA,GAAQM,MAAA;EAAA,CACvB;EAEM,QACLR,QAAA,CAAsB;IACpBC,IAAKC,KAAA,EAAoB;MACvBG,aAAA,CAAcH,KAAA,GAAQA,KAAA;MACjBJ,IAAA,WAAUF,QAAA,IAAYM,KAAK;IAClC;IACAC,IAAA,EAAoB;MAClB,OAAQN,KAAA,CAAMD,QAAQ,MAAM,SAAYS,aAAA,CAAcH,KAAA,GAAQL,KAAA,CAAMD,QAAQ;IAC9E;EAAA,CACD;AAEL"},"metadata":{},"sourceType":"module","externalDependencies":[]}