{"ast":null,"code":"import { ref } from \"vue\";\nconst parse = text => {\n  const m = text.match(/[0-9]{1,2}/g);\n  if (!m) {\n    return [];\n  }\n  return m.map(s => Number(s));\n};\nconst parsePeriod = text => {\n  const m = text.match(/pm|am/i);\n  if (!m) {\n    return null;\n  }\n  return Number(m[0].toLowerCase() === \"pm\");\n};\nconst defaultParseDateFunction = text => {\n  const d = /* @__PURE__ */new Date();\n  const [h, m, s] = parse(text);\n  const period = parsePeriod(text);\n  if (!h) {\n    return null;\n  }\n  const is12format = period !== null && h <= 12;\n  const isPM = is12format && !!period;\n  const fh = is12format ? h === 12 ? 0 : h : h;\n  d.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));\n  d.setMinutes(Math.min(m || 0, 60));\n  d.setSeconds(Math.min(s || 0, 60));\n  return d;\n};\nconst useTimeParser = props => {\n  const getParseDateFn = () => props.parse || defaultParseDateFunction;\n  const isValid = ref(true);\n  const parseDate = text => {\n    const parse3 = getParseDateFn();\n    const result = parse3(text);\n    if (!result) {\n      isValid.value = false;\n    }\n    return result;\n  };\n  const parse2 = text => {\n    isValid.value = true;\n    return parseDate(text);\n  };\n  return {\n    parse: parse2,\n    isValid\n  };\n};\nexport { useTimeParser as u };","map":{"version":3,"names":["parse","text","m","match","map","s","Number","parsePeriod","toLowerCase","defaultParseDateFunction","d","Date","h","period","is12format","isPM","fh","setHours","Math","min","setMinutes","setSeconds","useTimeParser","props","getParseDateFn","isValid","ref","parseDate","parse3","result","value","parse2"],"sources":["../../../../../../src/components/va-time-input/hooks/time-text-parser.ts"],"sourcesContent":["import { Ref, ref } from 'vue'\n\nconst parse = (text: string) => {\n  const m = text.match(/[0-9]{1,2}/g)\n\n  if (!m) { return [] }\n\n  return m.map((s) => Number(s))\n}\n\nconst parsePeriod = (text: string) => {\n  const m = text.match(/pm|am/i)\n\n  if (!m) { return null }\n\n  return Number(m[0].toLowerCase() === 'pm')\n}\n\nconst defaultParseDateFunction = (text: string) => {\n  const d = new Date()\n\n  const [h, m, s] = parse(text)\n  const period = parsePeriod(text)\n\n  if (!h) { return null }\n\n  const is12format = period !== null && h <= 12\n  const isPM = is12format && !!period\n  // Switch 12 to 0, because of 12h format\n  const fh = is12format ? (h === 12 ? 0 : h) : h\n\n  d.setHours(Math.min((fh || 0), is12format ? 12 : 24) + (isPM ? 12 : 0))\n  d.setMinutes(Math.min(m || 0, 60))\n  d.setSeconds(Math.min(s || 0, 60))\n\n  return d\n}\n\nexport const useTimeParser = (props: {\n  parse?: (input: string, isValidRef?: Ref<boolean>) => Date,\n}) => {\n  // const isTextIsMultipleDates = (text: string) => text.includes(props.delimiter)\n  // const isTextIsDateRange = (text: string) => text.includes(props.rangeDelimiter)\n\n  const getParseDateFn = () => props.parse || defaultParseDateFunction\n\n  const isValid = ref(true)\n\n  const parseDate = (text: string) => {\n    const parse = getParseDateFn()\n\n    const result = parse(text)\n\n    if (!result) { isValid.value = false }\n\n    return result\n  }\n\n  const parse = (text: string) => {\n    isValid.value = true\n\n    // if (props.parse) {\n    //   return props.parse(text, isValid)\n    // }\n\n    // if (isTextIsMultipleDates(text)) {\n    //   return text.split(props.delimiter).map((dateText) => parseDate(dateText))\n    // }\n\n    // if (isTextIsDateRange(text)) {\n    //   const [start, end] = text.split(props.rangeDelimiter).map((dateText) => parseDate(dateText))\n    //   return { start, end }\n    // }\n\n    return parseDate(text)\n  }\n\n  return {\n    parse,\n    isValid,\n  }\n}\n"],"mappings":";AAEA,MAAMA,KAAA,GAASC,IAAA,IAAiB;EACxB,MAAAC,CAAA,GAAID,IAAA,CAAKE,KAAA,CAAM,aAAa;EAElC,IAAI,CAACD,CAAA,EAAG;IAAE,OAAO;EAAG;EAEpB,OAAOA,CAAA,CAAEE,GAAA,CAAKC,CAAA,IAAMC,MAAA,CAAOD,CAAC,CAAC;AAC/B;AAEA,MAAME,WAAA,GAAeN,IAAA,IAAiB;EAC9B,MAAAC,CAAA,GAAID,IAAA,CAAKE,KAAA,CAAM,QAAQ;EAE7B,IAAI,CAACD,CAAA,EAAG;IAAS;EAAK;EAEtB,OAAOI,MAAA,CAAOJ,CAAA,CAAE,CAAC,EAAEM,WAAA,OAAkB,IAAI;AAC3C;AAEA,MAAMC,wBAAA,GAA4BR,IAAA,IAAiB;EAC3C,MAAAS,CAAA,sBAAQC,IAAA;EAEd,MAAM,CAACC,CAAA,EAAGV,CAAA,EAAGG,CAAC,IAAIL,KAAA,CAAMC,IAAI;EACtB,MAAAY,MAAA,GAASN,WAAA,CAAYN,IAAI;EAE/B,IAAI,CAACW,CAAA,EAAG;IAAS;EAAK;EAEhB,MAAAE,UAAA,GAAaD,MAAA,KAAW,QAAQD,CAAA,IAAK;EACrC,MAAAG,IAAA,GAAOD,UAAA,IAAc,CAAC,CAACD,MAAA;EAE7B,MAAMG,EAAA,GAAKF,UAAA,GAAcF,CAAA,KAAM,KAAK,IAAIA,CAAA,GAAKA,CAAA;EAE3CF,CAAA,CAAAO,QAAA,CAASC,IAAA,CAAKC,GAAA,CAAKH,EAAA,IAAM,GAAIF,UAAA,GAAa,KAAK,EAAE,KAAKC,IAAA,GAAO,KAAK,EAAE;EACtEL,CAAA,CAAEU,UAAA,CAAWF,IAAA,CAAKC,GAAA,CAAIjB,CAAA,IAAK,GAAG,EAAE,CAAC;EACjCQ,CAAA,CAAEW,UAAA,CAAWH,IAAA,CAAKC,GAAA,CAAId,CAAA,IAAK,GAAG,EAAE,CAAC;EAE1B,OAAAK,CAAA;AACT;AAEa,MAAAY,aAAA,GAAiBC,KAAA,IAExB;EAIE,MAAAC,cAAA,GAAiBA,CAAA,KAAMD,KAAA,CAAMvB,KAAA,IAASS,wBAAA;EAEtC,MAAAgB,OAAA,GAAUC,GAAA,CAAI,IAAI;EAElB,MAAAC,SAAA,GAAa1B,IAAA,IAAiB;IAClC,MAAM2B,MAAA,GAAQJ,cAAA;IAER,MAAAK,MAAA,GAASD,MAAA,CAAM3B,IAAI;IAEzB,IAAI,CAAC4B,MAAA,EAAQ;MAAEJ,OAAA,CAAQK,KAAA,GAAQ;IAAM;IAE9B,OAAAD,MAAA;EAAA;EAGH,MAAAE,MAAA,GAAS9B,IAAA,IAAiB;IAC9BwB,OAAA,CAAQK,KAAA,GAAQ;IAehB,OAAOH,SAAA,CAAU1B,IAAI;EAAA;EAGhB;IACLD,KAAA,EAAA+B,MAAA;IACAN;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}