{"ast":null,"code":"import { defineComponent, shallowRef, computed, ref, onMounted, nextTick, onBeforeUnmount } from \"vue\";\nimport { n as noop } from \"../../../vendor-fff696df.mjs\";\nimport { g as getWindow } from \"../../utils/ssr-fd33979c.mjs\";\nimport { u as useComponentPresetProp } from \"../../composables/useComponentPreset-0dfbd395.mjs\";\nimport { u as useEventsHandlerWithThrottle, h as handleThrottledEvent, g as getWindowHeight } from \"./VaAffix-utils-fd4e2f0c.mjs\";\nconst _sfc_main = defineComponent({\n  name: \"VaAffix\",\n  emits: [\"change\"],\n  props: {\n    ...useComponentPresetProp,\n    offsetTop: {\n      type: Number,\n      default: void 0\n    },\n    offsetBottom: {\n      type: Number,\n      default: void 0\n    },\n    target: {\n      type: [Object, Function],\n      default: getWindow\n    }\n  },\n  setup(props, {\n    emit\n  }) {\n    const element = shallowRef();\n    const getTargetElement = () => typeof props.target === \"function\" ? props.target() : props.target;\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);\n    const state = ref({\n      isTopAffixed: false,\n      isBottomAffixed: false\n    });\n    const getState = () => state.value;\n    const setState = newState => {\n      state.value = newState;\n      emit(\"change\", isAffixed);\n    };\n    const calculateTop = () => {\n      const target = getTargetElement();\n      if (!target) {\n        return 0;\n      }\n      if (props.offsetTop === void 0) {\n        return;\n      }\n      if (!(target instanceof Window)) {\n        const {\n          top\n        } = target.getBoundingClientRect();\n        return top + props.offsetTop;\n      }\n      return props.offsetTop;\n    };\n    const calculateBottom = () => {\n      const target = getTargetElement();\n      if (!target) {\n        return 0;\n      }\n      if (props.offsetBottom === void 0) {\n        return;\n      }\n      if (!(target instanceof Window)) {\n        const {\n          bottom\n        } = target.getBoundingClientRect();\n        const {\n          borderTopWidth,\n          borderBottomWidth\n        } = getComputedStyle(target);\n        const {\n          offsetHeight,\n          clientHeight\n        } = target;\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;\n      }\n      return props.offsetBottom;\n    };\n    const convertToPixels = calculate => {\n      const result = calculate();\n      return result === void 0 ? void 0 : `${result}px`;\n    };\n    const computedClass = computed(() => [{\n      \"va-affix--affixed\": isAffixed\n    }]);\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,\n      width: `${state.value.width}px`\n    }));\n    const initialPosition = ref();\n    const throttledEventHandler = (eventName, event) => {\n      const context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value,\n        target: getTargetElement(),\n        setState,\n        getState\n      };\n      if (!eventName || eventName === \"resize\") {\n        handleThrottledEvent(eventName, context);\n      } else if (event && event.target) {\n        const target = getTargetElement();\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context);\n        } else {\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false\n          });\n        }\n      }\n    };\n    let clearEventListeners = noop;\n    onMounted(() => {\n      var _a;\n      initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();\n      const events = [\"scroll\", \"resize\"];\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler\n      });\n      nextTick(() => {\n        throttledEventHandler(null);\n      });\n    });\n    onBeforeUnmount(clearEventListeners);\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element\n    };\n  }\n});\nexport { _sfc_main as _ };\nimport '../../../VaAffix.css';","map":{"version":3,"names":["_sfc_main","defineComponent","name","emits","props","useComponentPresetProp","offsetTop","type","Number","default","offsetBottom","target","Object","Function","getWindow","setup","emit","element","shallowRef","getTargetElement","isAffixed","computed","state","value","isTopAffixed","isBottomAffixed","ref","getState","setState","newState","calculateTop","Window","top","getBoundingClientRect","calculateBottom","bottom","borderTopWidth","borderBottomWidth","getComputedStyle","offsetHeight","clientHeight","scrollBarHeight","parseInt","getWindowHeight","convertToPixels","calculate","result","computedClass","computedStyle","width","initialPosition","throttledEventHandler","eventName","event","context","handleThrottledEvent","clearEventListeners","noop","onMounted","_a","events","useEventsHandlerWithThrottle","handler","nextTick","onBeforeUnmount"],"sources":["../../../../../src/components/va-affix/VaAffix.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, nextTick, onMounted, onBeforeUnmount, shallowRef } from 'vue'\nimport noop from 'lodash/noop.js'\n\nimport { getWindow } from '../../utils/ssr'\nimport { useComponentPresetProp } from '../../composables/useComponentPreset'\n\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    ...useComponentPresetProp,\n    offsetTop: { type: Number, default: undefined },\n    offsetBottom: { type: Number, default: undefined },\n    target: { type: [Object, Function] as PropType<HTMLElement | Window | (() => HTMLElement | Window)>, default: getWindow },\n  },\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n\n    const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target)\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state = ref<State>({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (!target) {\n        return 0\n      }\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (!target) { return 0 }\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }))\n\n    const initialPosition = ref<DOMRect>()\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n\n    onMounted(() => {\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      const events = ['scroll', 'resize']\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    onBeforeUnmount(clearEventListeners)\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}