{"ast":null,"code":"import { ref, computed, watch } from \"vue\";\nimport { i as isRange, p as parseModelValue } from \"./model-value-parser-460087fd.mjs\";\nconst useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {\n  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));\n  const valueComputed = computed({\n    get: () => bufferValue.value,\n    set: value => {\n      if (disabled.value) {\n        modelValue.value = value;\n      }\n      if (!value) {\n        modelValue.value = value;\n        return;\n      }\n      if (isRange(value)) {\n        if (value.end !== null) {\n          modelValue.value = value;\n        }\n      } else {\n        modelValue.value = value;\n      }\n      bufferValue.value = value;\n    }\n  });\n  watch(modelValue, newValue => {\n    bufferValue.value = newValue;\n  });\n  const reset = () => {\n    if (bufferValue.value && isRange(bufferValue.value)) {\n      bufferValue.value = modelValue.value && parseValue(modelValue.value);\n    }\n  };\n  return {\n    valueComputed,\n    reset\n  };\n};\nexport { useRangeModelValueGuard as u };","map":{"version":3,"names":["useRangeModelValueGuard","modelValue","disabled","parseValue","parseModelValue","bufferValue","ref","value","valueComputed","computed","get","set","isRange","end","watch","newValue","reset"],"sources":["../../../../../../src/components/va-date-input/hooks/range-model-value-guard.ts"],"sourcesContent":["import { computed, Ref, ref, watch } from 'vue'\n\nimport { parseModelValue, isRange } from './model-value-parser'\nimport { DateInputModelValue } from '../types'\n\n/**\n * This guard is used to prevent updating modelValue if range end is not specified.\n * This guard provides reset method, that allow us to reset VaDateInput value if dropdown is closed.\n */\nexport const useRangeModelValueGuard = (\n  modelValue: Ref<DateInputModelValue>,\n  disabled: Ref<boolean>,\n  parseValue = parseModelValue,\n) => {\n  const bufferValue = ref<DateInputModelValue>(modelValue.value && parseValue(modelValue.value))\n\n  const valueComputed = computed({\n    get: () => bufferValue.value,\n    set: (value) => {\n      if (disabled.value) {\n        modelValue.value = value\n      }\n\n      if (!value) {\n        modelValue.value = value\n        return\n      }\n\n      if (isRange(value)) {\n        if (value.end !== null) {\n          modelValue.value = value\n        }\n      } else {\n        modelValue.value = value\n      }\n\n      bufferValue.value = value\n    },\n  })\n\n  watch(modelValue, (newValue) => {\n    bufferValue.value = newValue\n  })\n\n  const reset = () => {\n    if (bufferValue.value && isRange(bufferValue.value)) {\n      bufferValue.value = modelValue.value && parseValue(modelValue.value)\n    }\n  }\n\n  return {\n    valueComputed,\n    reset,\n  }\n}\n"],"mappings":";;AASO,MAAMA,uBAAA,GAA0BA,CACrCC,UAAA,EACAC,QAAA,EACAC,UAAA,GAAaC,eAAA,KACV;EACH,MAAMC,WAAA,GAAcC,GAAA,CAAyBL,UAAA,CAAWM,KAAA,IAASJ,UAAA,CAAWF,UAAA,CAAWM,KAAK,CAAC;EAE7F,MAAMC,aAAA,GAAgBC,QAAA,CAAS;IAC7BC,GAAA,EAAKA,CAAA,KAAML,WAAA,CAAYE,KAAA;IACvBI,GAAA,EAAMJ,KAAA,IAAU;MACd,IAAIL,QAAA,CAASK,KAAA,EAAO;QAClBN,UAAA,CAAWM,KAAA,GAAQA,KAAA;MACrB;MAEA,IAAI,CAACA,KAAA,EAAO;QACVN,UAAA,CAAWM,KAAA,GAAQA,KAAA;QACnB;MACF;MAEI,IAAAK,OAAA,CAAQL,KAAK,GAAG;QACd,IAAAA,KAAA,CAAMM,GAAA,KAAQ,MAAM;UACtBZ,UAAA,CAAWM,KAAA,GAAQA,KAAA;QACrB;MAAA,OACK;QACLN,UAAA,CAAWM,KAAA,GAAQA,KAAA;MACrB;MAEAF,WAAA,CAAYE,KAAA,GAAQA,KAAA;IACtB;EAAA,CACD;EAEKO,KAAA,CAAAb,UAAA,EAAac,QAAA,IAAa;IAC9BV,WAAA,CAAYE,KAAA,GAAQQ,QAAA;EAAA,CACrB;EAED,MAAMC,KAAA,GAAQA,CAAA,KAAM;IAClB,IAAIX,WAAA,CAAYE,KAAA,IAASK,OAAA,CAAQP,WAAA,CAAYE,KAAK,GAAG;MACnDF,WAAA,CAAYE,KAAA,GAAQN,UAAA,CAAWM,KAAA,IAASJ,UAAA,CAAWF,UAAA,CAAWM,KAAK;IACrE;EAAA;EAGK;IACLC,aAAA;IACAQ;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}