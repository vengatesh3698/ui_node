{"ast":null,"code":"import { defineComponent, shallowRef, ref, onMounted, computed, watch } from \"vue\";\nimport { b as clamp, e as isNumber, f as isString } from \"../../../vendor-fff696df.mjs\";\nimport { u as useSplitDraggerProps, a as useSplitDragger } from \"./useSplitDragger-885ad0e9.mjs\";\nimport { w as warn } from \"../../utils/console-42c8e8cc.mjs\";\nimport { V as VaDivider } from \"../va-divider/index-98d76699.mjs\";\nimport { u as useComponentPresetProp } from \"../../composables/useComponentPreset-0dfbd395.mjs\";\nimport { a as useStatefulProps, u as useStatefulEmits, b as useStateful } from \"../../composables/useStateful-50e4a6b9.mjs\";\nimport { u as useResizeObserver } from \"../../composables/useResizeObserver-97916f85.mjs\";\nimport { u as useBem } from \"../../composables/useBem-10a5bc6e.mjs\";\nimport { u as useTranslation } from \"../../composables/useTranslation-acf7d88d.mjs\";\nconst _sfc_main = defineComponent({\n  name: \"VaSplit\",\n  components: {\n    VaDivider\n  },\n  props: {\n    ...useComponentPresetProp,\n    ...useSplitDraggerProps,\n    ...useStatefulProps,\n    modelValue: {\n      type: Number,\n      default: 50,\n      validator: v => v <= 100\n    },\n    maximization: {\n      type: Boolean,\n      default: false\n    },\n    maximizeStart: {\n      type: Boolean,\n      default: false\n    },\n    limits: {\n      type: Array,\n      default: () => [0, 0]\n    },\n    snapping: {\n      type: Array,\n      default: void 0\n    },\n    snappingRange: {\n      type: [Number, String],\n      default: 4\n    },\n    ariaLabel: {\n      type: String,\n      default: \"$t:splitPanels\"\n    }\n  },\n  emits: [...useStatefulEmits],\n  setup: (props, {\n    emit\n  }) => {\n    const splitPanelsContainer = shallowRef();\n    const {\n      valueComputed\n    } = useStateful(props, emit);\n    const containerSize = ref();\n    const bodyFontSize = ref(16);\n    const handleContainerResize = () => {\n      var _a;\n      const {\n        width,\n        height\n      } = ((_a = splitPanelsContainer.value) == null ? void 0 : _a.getBoundingClientRect()) || {\n        width: 0,\n        height: 0\n      };\n      containerSize.value = props.vertical ? height : width;\n      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);\n    };\n    onMounted(handleContainerResize);\n    useResizeObserver([splitPanelsContainer], handleContainerResize);\n    const convertToPercents = (v, type) => {\n      let numberValue = \"\";\n      let measureValue = \"\";\n      if (isNumber(v)) {\n        return v;\n      }\n      v.split(\"\").filter(char => char && char !== \" \").forEach(char => {\n        !isNaN(+char) ? numberValue += char : measureValue += char;\n      });\n      switch (measureValue) {\n        case \"%\":\n          return +numberValue;\n        case \"px\":\n          return +numberValue / containerSize.value * 100;\n        case \"rem\":\n          return +numberValue * bodyFontSize.value / containerSize.value * 100;\n        case \"any\":\n          return [\"min\", \"snapping\"].includes(type) ? 0 : 100;\n        case \"\":\n          return 100;\n        default:\n          warn(\"Invalid limits measure!\");\n          return 0;\n      }\n    };\n    const getPanelMinMax = v => {\n      if (v === \"undefined\" || !containerSize.value) {\n        return;\n      }\n      let minPercents = 0;\n      let maxPercents = 100;\n      if (isString(v) || isNumber(v)) {\n        minPercents = convertToPercents(v, \"min\");\n      }\n      if (Array.isArray(v)) {\n        minPercents = convertToPercents(v[0], \"min\");\n        maxPercents = convertToPercents(v[1], \"max\");\n      }\n      if (minPercents > maxPercents) {\n        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);\n        maxPercents = minPercents;\n      }\n      return {\n        min: minPercents ?? 0,\n        max: maxPercents ?? 100\n      };\n    };\n    const startPanelMinMax = computed(() => getPanelMinMax(props.limits[0]) ?? {\n      min: 0,\n      max: 100\n    });\n    const endPanelMinMax = computed(() => getPanelMinMax(props.limits[1]) ?? {\n      min: 0,\n      max: 100\n    });\n    const endPanelMinChecked = computed(() => {\n      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);\n      if (!passedCheck) {\n        warn(\"The sum of different panels min sizes should be lesser or equal to 100% of the container size!\");\n      }\n      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;\n    });\n    const panelsMinMax = computed(() => {\n      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {\n        warn(\"The sum of different panels max sizes should be equal to 100% of the container size!\");\n      }\n      return {\n        start: {\n          min: startPanelMinMax.value.min,\n          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)\n        },\n        end: {\n          min: endPanelMinChecked.value,\n          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)\n        }\n      };\n    });\n    const checkSnappingLimitsCondition = el => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;\n    const snappingMarksPosition = computed(() => {\n      if (!Array.isArray(props.snapping) || !containerSize.value) {\n        return;\n      }\n      let result = props.snapping.map(el => convertToPercents(el, \"snapping\"));\n      if (!result.every(checkSnappingLimitsCondition)) {\n        const filteredMarks = result.filter(checkSnappingLimitsCondition);\n        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join(\"-\")} / ${Object.values(panelsMinMax.value.end).join(\"-\")}) and will be removed (${filteredMarks})!`);\n        result = filteredMarks;\n      }\n      const checkSnappingRange = () => {\n        return result.every((el, index, array) => {\n          if (!array[index + 1]) {\n            return true;\n          }\n          return Math.abs(el - array[index + 1]) > Number(props.snappingRange);\n        });\n      };\n      if (!checkSnappingRange()) {\n        warn(\"Distance between some snapping marks is lesser than snapping range!\");\n      }\n      return result;\n    });\n    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, \"snapping\"));\n    const splitterPosition = ref(valueComputed.value);\n    const splitterPositionComputed = computed(() => {\n      if (snappingMarksPosition.value) {\n        const nearestSnappingMark = snappingMarksPosition.value.find(el => {\n          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;\n        });\n        if (nearestSnappingMark) {\n          return nearestSnappingMark;\n        }\n      }\n      return clamp(splitterPosition.value, Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max), Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min));\n    });\n    const {\n      isDragging,\n      startDragging,\n      currentSplitterPosition\n    } = useSplitDragger(containerSize, splitterPositionComputed, props);\n    const maximizePanel = () => {\n      if (!props.maximization || props.disabled) {\n        return;\n      }\n      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;\n    };\n    watch(valueComputed, v => {\n      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {\n        warn(\"Incorrect `modelValue`. Check current `limits` prop value.\");\n      }\n      splitterPosition.value = v;\n    }, {\n      immediate: true\n    });\n    watch(currentSplitterPosition, v => {\n      splitterPosition.value = v;\n    });\n    watch(isDragging, v => {\n      if (!v) {\n        valueComputed.value = splitterPositionComputed.value;\n      }\n      document.documentElement.style.cursor = v ? \"var(--va-split-dragging-cursor)\" : \"\";\n    });\n    const sizePropertyComputed = computed(() => props.vertical ? \"height\" : \"width\");\n    const getPanelStyle = position => {\n      let sizeValue = position === \"start\" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;\n      if (sizeValue < 0) {\n        sizeValue = 0;\n      }\n      if (sizeValue > 100) {\n        sizeValue = 100;\n      }\n      return {\n        [sizePropertyComputed.value]: `${sizeValue}%`\n      };\n    };\n    const draggerStyleComputed = computed(() => {\n      if (props.disabled) {\n        return {};\n      }\n      if (isDragging.value) {\n        return {\n          cursor: \"var(--va-split-dragging-cursor)\"\n        };\n      }\n      return {\n        cursor: props.vertical ? \"var(--va-split-vertical-dragger-cursor)\" : \"var(--va-split-horizontal-dragger-cursor)\"\n      };\n    });\n    const classComputed = useBem(\"va-split\", () => ({\n      horizontal: !props.vertical,\n      vertical: props.vertical,\n      dragging: isDragging.value\n    }));\n    return {\n      ...useTranslation(),\n      splitPanelsContainer,\n      containerSize,\n      startDragging,\n      getPanelStyle,\n      maximizePanel,\n      classComputed,\n      draggerStyleComputed\n    };\n  }\n});\nexport { _sfc_main as _ };\nimport '../../../VaSplit.css';","map":{"version":3,"names":["_sfc_main","defineComponent","name","components","VaDivider","props","useComponentPresetProp","useSplitDraggerProps","useStatefulProps","modelValue","type","Number","default","validator","v","maximization","Boolean","maximizeStart","limits","Array","snapping","snappingRange","String","ariaLabel","emits","useStatefulEmits","setup","emit","splitPanelsContainer","shallowRef","valueComputed","useStateful","containerSize","ref","bodyFontSize","handleContainerResize","width","height","_a","value","getBoundingClientRect","vertical","parseFloat","getComputedStyle","document","documentElement","fontSize","onMounted","useResizeObserver","convertToPercents","numberValue","measureValue","isNumber","split","filter","char","forEach","isNaN","includes","warn","getPanelMinMax","minPercents","maxPercents","isString","isArray","min","max","startPanelMinMax","computed","endPanelMinMax","endPanelMinChecked","passedCheck","panelsMinMax","Math","ceil","start","end","checkSnappingLimitsCondition","el","snappingMarksPosition","result","map","every","filteredMarks","Object","values","join","checkSnappingRange","index","array","abs","snappingRangeParsed","splitterPosition","splitterPositionComputed","nearestSnappingMark","find","clamp","isDragging","startDragging","currentSplitterPosition","useSplitDragger","maximizePanel","disabled","watch","immediate","style","cursor","sizePropertyComputed","getPanelStyle","position","sizeValue","draggerStyleComputed","classComputed","useBem","horizontal","dragging","useTranslation"],"sources":["../../../../../src/components/va-split/VaSplit.vue"],"sourcesContent":["<template>\n  <section\n    ref=\"splitPanelsContainer\"\n    class=\"va-split\"\n    :class=\"classComputed\"\n    :aria-label=\"tp($props.ariaLabel)\"\n  >\n    <div\n      class=\"va-split__panel\"\n      :style=\"getPanelStyle('start')\"\n    >\n      <slot name=\"start\" v-bind=\"{ containerSize }\" />\n    </div>\n    <div class=\"va-split__dragger\">\n      <div\n        class=\"va-split__dragger__overlay\"\n        :style=\"draggerStyleComputed\"\n        @mousedown.prevent=\"startDragging\"\n        @touchstart.prevent=\"startDragging\"\n        @dblclick.prevent=\"maximizePanel\"\n        @contextmenu.prevent\n        @dragstart.prevent\n      >\n        <slot name=\"grabber\">\n          <va-divider\n            class=\"va-split__dragger__default\"\n            :vertical=\"!$props.vertical\"\n          />\n        </slot>\n      </div>\n    </div>\n    <div\n      class=\"va-split__panel\"\n      :style=\"getPanelStyle('end')\"\n    >\n      <slot name=\"end\" v-bind=\"{ containerSize }\" />\n    </div>\n  </section>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, ref, shallowRef, computed, watch, onMounted } from 'vue'\nimport isString from 'lodash/isString.js'\nimport isNumber from 'lodash/isNumber.js'\nimport clamp from 'lodash/clamp.js'\n\nimport {\n  useBem,\n  useComponentPresetProp,\n  useStateful, useStatefulEmits, useStatefulProps,\n  useResizeObserver,\n  useTranslation,\n} from '../../composables'\nimport { useSplitDragger, useSplitDraggerProps } from './useSplitDragger'\n\nimport { warn } from '../../utils/console'\n\nimport { SplitLimit, SnappingMark } from './types'\n\nimport { VaDivider } from '../va-divider'\n\nexport default defineComponent({\n  name: 'VaSplit',\n\n  components: { VaDivider },\n\n  props: {\n    ...useComponentPresetProp,\n    ...useSplitDraggerProps,\n    ...useStatefulProps,\n    modelValue: {\n      type: Number,\n      default: 50,\n      validator: (v: number) => v <= 100,\n    },\n    maximization: { type: Boolean, default: false },\n    maximizeStart: { type: Boolean, default: false },\n    limits: {\n      type: Array as any as PropType<[SplitLimit, SplitLimit]>,\n      default: () => [0, 0],\n    },\n    snapping: {\n      type: Array as any as PropType<SnappingMark[]>,\n      default: undefined,\n    },\n    snappingRange: { type: [Number, String] as PropType<number | string>, default: 4 },\n\n    ariaLabel: { type: String, default: '$t:splitPanels' },\n  },\n\n  emits: [...useStatefulEmits],\n\n  setup: (props, { emit }) => {\n    const splitPanelsContainer = shallowRef<HTMLElement>()\n\n    const { valueComputed } = useStateful(props, emit)\n\n    const containerSize = ref()\n    const bodyFontSize = ref(16)\n\n    const handleContainerResize = () => {\n      const { width, height } = splitPanelsContainer.value?.getBoundingClientRect() || { width: 0, height: 0 }\n      containerSize.value = props.vertical ? height : width\n      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize)\n    }\n    onMounted(handleContainerResize)\n    useResizeObserver([splitPanelsContainer], handleContainerResize)\n\n    const convertToPercents = (v: string | number, type: 'min' | 'max' | 'snapping') => {\n      let numberValue = ''\n      let measureValue = ''\n\n      if (isNumber(v)) { return v }\n\n      v.split('')\n        .filter((char) => char && char !== ' ')\n        .forEach((char) => {\n          !isNaN(+char) ? numberValue += char : measureValue += char\n        })\n\n      switch (measureValue) {\n        case '%':\n          return +numberValue\n        case 'px':\n          return (+numberValue / containerSize.value) * 100\n        case 'rem':\n          return ((+numberValue * bodyFontSize.value) / containerSize.value) * 100\n        case 'any':\n          return ['min', 'snapping'].includes(type) ? 0 : 100\n        case '':\n          return 100\n        default:\n          warn('Invalid limits measure!')\n          return 0\n      }\n    }\n    const getPanelMinMax = (v: SplitLimit) => {\n      if (v === 'undefined' || !containerSize.value) { return }\n\n      let minPercents = 0\n      let maxPercents = 100\n\n      if (isString(v) || isNumber(v)) { minPercents = convertToPercents(v, 'min') }\n\n      if (Array.isArray(v)) {\n        minPercents = convertToPercents(v[0], 'min')\n        maxPercents = convertToPercents(v[1], 'max')\n      }\n\n      if (minPercents > maxPercents) {\n        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`)\n        maxPercents = minPercents\n      }\n\n      return { min: minPercents ?? 0, max: maxPercents ?? 100 }\n    }\n\n    const startPanelMinMax = computed(() => getPanelMinMax(props.limits[0]) ?? { min: 0, max: 100 })\n    const endPanelMinMax = computed(() => getPanelMinMax(props.limits[1]) ?? { min: 0, max: 100 })\n\n    const endPanelMinChecked = computed(() => {\n      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100)\n      if (!passedCheck) {\n        warn('The sum of different panels min sizes should be lesser or equal to 100% of the container size!')\n      }\n      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min\n    })\n    const panelsMinMax = computed(() => {\n      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {\n        warn('The sum of different panels max sizes should be equal to 100% of the container size!')\n      }\n\n      return {\n        start: {\n          min: startPanelMinMax.value.min,\n          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value),\n        },\n        end: {\n          min: endPanelMinChecked.value,\n          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min),\n        },\n      }\n    })\n\n    const checkSnappingLimitsCondition = (el: number) =>\n      el >= panelsMinMax.value.start.min &&\n      el >= panelsMinMax.value.end.min &&\n      el <= panelsMinMax.value.start.max &&\n      el <= panelsMinMax.value.end.max\n\n    const snappingMarksPosition = computed(() => {\n      if (!Array.isArray(props.snapping) || !containerSize.value) { return }\n\n      let result = props.snapping.map((el) => convertToPercents(el, 'snapping'))\n\n      if (!result.every(checkSnappingLimitsCondition)) {\n        const filteredMarks = result.filter(checkSnappingLimitsCondition)\n        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join('-')} / ${Object.values(panelsMinMax.value.end).join('-')}) and will be removed (${filteredMarks})!`)\n        result = filteredMarks\n      }\n\n      const checkSnappingRange = () => {\n        return result.every((el, index, array) => {\n          if (!array[index + 1]) { return true }\n          return Math.abs(el - array[index + 1]) > Number(props.snappingRange)\n        })\n      }\n\n      if (!checkSnappingRange()) {\n        warn('Distance between some snapping marks is lesser than snapping range!')\n      }\n\n      return result\n    })\n\n    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, 'snapping'))\n\n    const splitterPosition = ref(valueComputed.value)\n    const splitterPositionComputed = computed(() => {\n      if (snappingMarksPosition.value) {\n        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {\n          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el\n        })\n        if (nearestSnappingMark) { return nearestSnappingMark }\n      }\n\n      return clamp(\n        splitterPosition.value,\n        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),\n        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min),\n      )\n    })\n\n    const {\n      isDragging,\n      startDragging,\n      currentSplitterPosition,\n    } = useSplitDragger(containerSize, splitterPositionComputed, props)\n\n    const maximizePanel = () => {\n      if (!props.maximization || props.disabled) { return }\n\n      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max\n    }\n\n    watch(valueComputed, (v) => {\n      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {\n        warn('Incorrect `modelValue`. Check current `limits` prop value.')\n      }\n\n      splitterPosition.value = v\n    }, { immediate: true })\n\n    watch(currentSplitterPosition, (v) => {\n      splitterPosition.value = v\n    })\n\n    watch(isDragging, (v) => {\n      if (!v) { valueComputed.value = splitterPositionComputed.value }\n      document.documentElement.style.cursor = v ? 'var(--va-split-dragging-cursor)' : ''\n    })\n\n    const sizePropertyComputed = computed(() => props.vertical ? 'height' : 'width')\n    const getPanelStyle = (position: 'start' | 'end') => {\n      let sizeValue = position === 'start' ? splitterPositionComputed.value : 100 - splitterPositionComputed.value\n      if (sizeValue < 0) { sizeValue = 0 }\n      if (sizeValue > 100) { sizeValue = 100 }\n\n      return { [sizePropertyComputed.value]: `${sizeValue}%` }\n    }\n\n    const draggerStyleComputed = computed(() => {\n      if (props.disabled) { return {} }\n      if (isDragging.value) { return { cursor: 'var(--va-split-dragging-cursor)' } }\n      return { cursor: props.vertical ? 'var(--va-split-vertical-dragger-cursor)' : 'var(--va-split-horizontal-dragger-cursor)' }\n    })\n\n    const classComputed = useBem('va-split', () => ({\n      horizontal: !props.vertical,\n      vertical: props.vertical,\n      dragging: isDragging.value,\n    }))\n\n    return {\n      ...useTranslation(),\n      splitPanelsContainer,\n      containerSize,\n\n      startDragging,\n      getPanelStyle,\n      maximizePanel,\n\n      classComputed,\n      draggerStyleComputed,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import 'variables';\n@import '../../styles/resources';\n\n.va-split {\n  position: relative;\n  display: flex;\n\n  &__dragger {\n    position: relative;\n\n    &__overlay {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      left: 0;\n      display: var(--va-split-dragger-display);\n      z-index: 1;\n    }\n  }\n\n  &__panel {\n    overflow: var(--va-split-panel-overflow);\n\n    @include va-scroll();\n  }\n\n  &--dragging {\n    & .va-split__panel {\n      user-select: none;\n      cursor: var(--va-split-dragging-cursor);\n    }\n  }\n\n  &__dragger__default {\n    opacity: 0.7;\n  }\n\n  &:focus,\n  &:hover {\n    .va-split__dragger__default {\n      opacity: 1;\n    }\n  }\n\n  &--vertical {\n    flex-direction: column;\n\n    & > .va-split__dragger {\n      height: 0;\n\n      .va-split__dragger__overlay {\n        top: calc((var(--va-split-dragger-overlay-size) / -2));\n        height: var(--va-split-dragger-overlay-size);\n        align-items: var(--va-split-dragger-align-items);\n      }\n\n      .va-split__dragger__default {\n        width: 100%;\n      }\n    }\n  }\n\n  &--horizontal {\n    flex-direction: row;\n\n    & > .va-split__dragger {\n      width: 0;\n\n      .va-split__dragger__overlay {\n        left: calc((var(--va-split-dragger-overlay-size) / -2));\n        width: var(--va-split-dragger-overlay-size);\n        justify-content: var(--va-split-dragger-justify-content);\n      }\n\n      .va-split__dragger__default {\n        height: 100%;\n      }\n    }\n  }\n}\n</style>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}