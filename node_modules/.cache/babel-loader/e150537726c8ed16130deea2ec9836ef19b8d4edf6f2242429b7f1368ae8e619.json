{"ast":null,"code":"import { computed } from \"vue\";\nconst useParsable = (parsable, parse, format) => {\n  const text = computed({\n    get() {\n      const value2 = parsable.value;\n      if (typeof value2 === \"string\") {\n        return value2;\n      }\n      return format(value2);\n    },\n    set(v) {\n      if (typeof parsable.value === \"string\") {\n        parsable.value = v;\n      } else {\n        parsable.value = parse(v);\n      }\n    }\n  });\n  const value = computed({\n    get() {\n      if (typeof parsable.value === \"string\") {\n        return parse(parsable.value);\n      }\n      return parsable.value;\n    },\n    set(v) {\n      if (typeof parsable.value === \"string\") {\n        parsable.value = format(v);\n      } else {\n        parsable.value = v;\n      }\n    }\n  });\n  return {\n    text,\n    value\n  };\n};\nexport { useParsable as u };","map":{"version":3,"names":["useParsable","parsable","parse","format","text","computed","get","value2","value","set","v"],"sources":["../../../../src/composables/useParsable.ts"],"sourcesContent":["import { computed, Ref } from 'vue'\n\ntype Not<P, N> = P extends N ? never : P\n\nexport const useParsable = <Text extends string | number, Original, Value extends Not<Original, Text>>(\n  parsable: Ref<Original>,\n  parse: (t: Text) => Value,\n  format: (v: Value) => Text,\n) => {\n  const text = computed({\n    get () {\n      const value = parsable.value\n      if (typeof value === 'string') {\n        return value as any\n      }\n      return format(value as unknown as Value)\n    },\n    set (v: Text) {\n      if (typeof parsable.value === 'string') {\n        parsable.value = v as any\n      } else {\n        parsable.value = parse(v)\n      }\n    },\n  })\n\n  const value = computed<Value>({\n    get () {\n      if (typeof parsable.value === 'string') {\n        return parse(parsable.value as any)\n      }\n\n      return parsable.value as unknown as Value\n    },\n    set (v: Value) {\n      if (typeof parsable.value === 'string') {\n        parsable.value = format(v as any) as any\n      } else {\n        parsable.value = v\n      }\n    },\n  })\n\n  return {\n    text,\n    value,\n  }\n}\n"],"mappings":";AAIO,MAAMA,WAAA,GAAcA,CACzBC,QAAA,EACAC,KAAA,EACAC,MAAA,KACG;EACH,MAAMC,IAAA,GAAOC,QAAA,CAAS;IACpBC,IAAA,EAAO;MACL,MAAMC,MAAA,GAAQN,QAAA,CAASO,KAAA;MACnB,WAAOD,MAAA,KAAU,UAAU;QACtB,OAAAA,MAAA;MACT;MACA,OAAOJ,MAAA,CAAOI,MAAyB;IACzC;IACAE,IAAKC,CAAA,EAAS;MACR,WAAOT,QAAA,CAASO,KAAA,KAAU,UAAU;QACtCP,QAAA,CAASO,KAAA,GAAQE,CAAA;MAAA,OACZ;QACIT,QAAA,CAAAO,KAAA,GAAQN,KAAA,CAAMQ,CAAC;MAC1B;IACF;EAAA,CACD;EAED,MAAMF,KAAA,GAAQH,QAAA,CAAgB;IAC5BC,IAAA,EAAO;MACD,WAAOL,QAAA,CAASO,KAAA,KAAU,UAAU;QAC/B,OAAAN,KAAA,CAAMD,QAAA,CAASO,KAAY;MACpC;MAEA,OAAOP,QAAA,CAASO,KAAA;IAClB;IACAC,IAAKC,CAAA,EAAU;MACT,WAAOT,QAAA,CAASO,KAAA,KAAU,UAAU;QAC7BP,QAAA,CAAAO,KAAA,GAAQL,MAAA,CAAOO,CAAQ;MAAA,OAC3B;QACLT,QAAA,CAASO,KAAA,GAAQE,CAAA;MACnB;IACF;EAAA,CACD;EAEM;IACLN,IAAA;IACAI;EAAA;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}